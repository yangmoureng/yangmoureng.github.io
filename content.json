{"meta":{"title":"YangBlog","subtitle":"","description":"","author":"yang","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.134Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.135Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.136Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.137Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-23T00:25:03.742Z","updated":"2021-07-12T08:00:19.138Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.137Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-23T00:25:03.742Z","updated":"2021-07-12T08:00:19.139Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringClound","slug":"springclound","date":"2021-10-19T07:20:57.000Z","updated":"2022-01-07T06:26:36.665Z","comments":true,"path":"2021/10/19/springclound/","link":"","permalink":"http://example.com/2021/10/19/springclound/","excerpt":"","text":"springcloud的组件哪些? Eureka,Ribbon,Feign Eureka - 治理服务 -SOA架构 Eureka-server - 服务中心 - 可以做集群 - 降低各个服务之间耦合.服务于服务之间不需要关心具体怎么通信. Eureka-client - 服务客户端,每次启动客户端的时候,需要将客户端的信息[名称,网络信息]注册到eureka-server 每30s会向eureka-server发送一次心跳 - 目的是为了告诉eureka-server它还活着,想要续约.如果超过90s,eureka-server接受不到该客户的心跳,那么再比例[失败的比例如果低于85%],那么就会剔除. Ribbon 提供负载均衡策略,rest方式[RestTemplate + ribbon] Feign 基于Ribbon,Feign最主要的作用是用来提供服务于服务之间的通信的问题.默认提供了负载均衡 nginx负载均衡(服务器端)和Feign/Ribbon负载均衡(客户端)区别 - 负载均衡的策略 SpringCloud2020版本开始,剔除了netflix项目[不进行更新了,仍然会继续维护bug]的组件,保留了Eureka组件. 概念 分布式 - 将一个庞大的系统按照模块进行拆分,拆分成若干个子模块[微服务] , 进行分布式的部署[各个服务部署在不同的服务器] 着重点 - 有无进行分布式部署 - 部署的方式 微服务 - 架构风格,微服务不一定是分布式的.但是分布式微服务架构的. “每个微服务都是单独的独立的工程项目,可以进行单独的部署 = 不同的人做不同的事情” 集群 - “很多人做同一件事情” - 分布式上的每个节点[微服务]都是可以进行集群的. 解决”三高” - 高并发,高性能,高可用 单体架构 - 整个项目都在一个工程里面,一起进行部署的.弊端 - 如果项目中的某个模块修改了,需要整体重新打包,重新部署. 如果某个模块”坏掉了” - 导致整个项目都”崩” 微服务 什么是我服务? 微服务是一种架构风格，也是一种服务； 微服务的颗粒比较小，一个大型复杂软件应用由多个微服务组成，比如Netflix目前由500多个的微服务组成； 它采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。 微服务架构图 微服务好处 技术异构性：在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。 弹性：如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。 扩展：可以只对那些需要扩展的服务进行扩展。简化部署：各个服务的部署是独立的，这样就可以更快地对特定部分的代码进行部署。 与组织结构相匹配：可以很好地将架构与组织结构相匹配，避免出现过大的代码库，从而获得理想团队大小及生产力。 可组合性：不同服务模块的接口可以再进行重用，成为其他产品中的一个组件； 对可替代性的优化：可以在需要时轻易地重写服务，或者删除不再使用的服务 微服务缺点 运维开销更多的服务也就意味着更多的运维，产品团队需要保证所有的相关服务都有完善的监控等基础设施，传统的架构开发者只需要保证一个应用正常运行，而现在却需要保证几十甚至上百道工序高效运转，这是一个艰巨的任务。 DevOps要求使用微服务架构后，开发团队需要保证一个Tomcat集群可用，保证一个数据库可用，这就意味着团队需要高品质的DevOps和自动化技术。而现在，这样的全栈式人才很少。 隐式接口服务和服务之间通过接口来“联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做调整。 重复劳动在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这个时候可能不同的服务团队都会单独开发这一功能，重复的业务逻辑，这违背了良好的软件工程中的很多原则。 分布式系统的复杂性微服务通过REST API或消息来将不同的服务联系起来，这在之前可能只是一个简单的远程过程调用。分布式系统也就意味着开发者需要考虑网络延迟、容错、消息序列化、不可靠的网络、异步、版本控制、负载等，而面对如此多的微服务都需要分布式时，整个产品需要有一整套完整的机制来保证各个服务可以正常运转。 事务、异步、测试面临挑战跨进程之间的事务、大量的异步处理、多个微服务之间的整体测试都需要有一整套的解决方案，而现在看起来，这些技术并没有特别成熟。 SpringCloud介绍 springcloud是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。 通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。 SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix 下面简单介绍下经常用的5个: 服务发现——Netflix Eureka 客服端负载均衡——Netflix Ribbon(重点掌握Netflix Feign) 断路器——Netflix Hystrix 服务网关——Netflix Zuul 分布式配置——Spring Cloud Config Eureka 作用：实现服务治理（服务注册与发现） 简介：Spring Cloud Eureka是Spring Cloud Netflix[停止更新]项目下的服务治理模块。 由两个组件组成：Eureka服务端和Eureka客户端。 Eureka服务端用作服务注册中心。支持集群部署。 Eureka客户端是一个java客户端，用来处理服务注册与发现。 在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。 Ribbon 作用：Ribbon，主要提供客户侧的软件负载均衡算法。 简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。 注意看上图，关键点就是将外界的rest调用，根据负载均衡策略转换为微服务调用。Ribbon有比较多的负载均衡策略，以后专门讲解。 Hystrix 作用：断路器，保护系统，控制故障范围。 简介：为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 Zuul 作用：api网关，路由，负载均衡等多种作用 简介：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。 在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。 config 作用：配置管理 简介：SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。 这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。 相关组件架构图 从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。 其中Eureka负责服务的注册与发现，很好将各服务连接起来 Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。 Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示 Spring Cloud Config 提供了统一的配置中心服务 当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息 所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用 最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析 为什么要使用springcloudSpring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利。 微服务架构是一种趋势，Spring Cloud提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。 Eureka服务与注册为什么需要服务中心过去，每个应用都是一个CPU，一个主机上的单一系统。然而今天，随着大数据和云计算时代的到来，任何独立的程序都可以运行在多个计算机上。并且随着业务的发展，访问用户量的增加，开发人员或小组的增加，系统会被拆分成多个功能模块。拆分后每个功能模块可以作为一个独立的子系统提供其职责范围内的功能。而多个子系统中，由于职责不同并且会存在相互调用，同时可能每个子系统还需要多个实例部署在多台服务器或者镜像中，导致了子系统间的相互调用形成了一个错综复杂的网状结构 对于微服务之间错综复杂的调用关系，通过eureka来管理，可以让每个服务之间不用关心如何调用的问题，专注于自己的业务功能实现。 Eureka的管理 服务需要有一个统一的名称（或服务ID）并且是唯一标识，以便于接口调用时各个接口的区分。并且需要将其注册到Eureka Server中，其他服务调用该接口时，也是根据这个唯一标识来获取。 服务下有多个实例，每个实例也有一个自己的唯一实例ID。因为它们各自有自己的基础信息如：不同的IP。所以它们的信息也需要注册到Eureka Server中，其他服务调用它们的服务接口时，可以查看到多个该服务的实例信息，根据负载策略提供某个实例的调用信息后，调用者根据信息直接调用该实例。 Eureka如何管理服务调用 在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。然后进行2调用当前服务器节点中的其他服务信息，保存到Eureka Client中。当服务间相互调用其它服务时，在Eureka Client中获取服务信息（如服务地址，端口等）后，进行第3步，根据信息直接调用服务。（注：服务的调用通过http(s)调用） 当某个服务仅需要调用其他服务，自身不提供服务调用时。在Eureka Client启动后会拉取Eureka Server的其他服务信息，需要调用时，在Eureka Client的本地缓存中获取信息，调用服务。 Eureka Client通过向Eureka Serve发送心跳（默认每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 以此来确保当前服务还“活着”，可以被调用。 来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次），以此来确保调用到的服务是“活的”。并且当某个服务被更新或者新加进来，也可以调用到新的服务。 Eureka Server和Eureka Client Eureka Server 提供服务注册：各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如服务信息和网络信息），Eureka Server会存储该服务的信息。 提供服务信息提供：服务消费者在调用服务时，本地Eureka Client没有的情况下，会到Eureka Server拉取信息。 提供服务管理：通过Eureka Client的Cancel、心跳监控、renew等方式来维护该服务提供的信息以确保该服务可用以及服务的更新。 信息同步：每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过P2P复制的方式完成服务注册表的同步 Eureka Client Eureka Client是一个Java客户端，用于简化与Eureka Server的交互。并且管理当前微服务，同时为当前的微服务提供服务提供者信息。 Eureka Client会拉取、更新和缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。 Eureka Client在微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）。 服务续约、下线、剔除 服务续约 Application Service内的Eureka Client后台启动一个定时任务，跟Eureka Server保持一个心跳续约任务，每隔一段时间(默认30S)向Eureka Server发送一次renew请求，进行续约，告诉Eureka Server我还活着，防止被Eureka Server的Evict任务剔除。 服务下线 Application Service应用停止后，向Eureka Server发送一个cancel请求，告诉注册中心我已经退出了，Eureka Server接收到之后会将其移出注册列表，后面再有获取注册服务列表的时候就获取不到了，防止消费端消费不可用的服务。 服务剔除 Eureka Server启动后在后台启动一个Evict任务，对一定时间内没有续约的服务进行剔除。 服务通讯方式 服务间使用标准的REST方式通讯，所以Eureka服务注册中心并不仅适用于Java平台，其他平台也可以纳入到服务治理平台里面。 自我保护 本地调试Eureka的程序时，会出现： 该警告是触发了Eureka Server的自我保护机制。 Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果低于，就会将当前实例注册信息保护起来，让实例不会过期，尽可能保护这些注册信息。 但是如果在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。这个时候客户端的容错机制就很重要了。（重新请求，断路器） 保护机制，可能会导致服务实例不能够被正确剔除。 在本地开发时，可使用：eureka.server.enable-self-preservation=false关闭保护机制，使不可用实例能够正常下线。 Eureka和Zookeeper区别Eureka：可以在发生因网络问题导致的各节点失去联系也不会暂停服务，但是最新的数据可能不统一。 Zookeeper：如果发生网络问题导致的Master和其他节点失去联系，就会使得其他的节点推选出新的Master，但是推选的时间内无法提供服务，但是可以保证任何时候的数据都是统一的。 基于idea多模块搭建eureka注册中心 首先创建父工程parent-demo,父工程pom.xml配置如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;modules&gt; &lt;module&gt;eureka-demo&lt;/module&gt; &lt;module&gt;user-demo&lt;/module&gt; &lt;module&gt;order-demo&lt;/module&gt; &lt;module&gt;zuul-demo&lt;/module&gt; &lt;module&gt;config-server-demo&lt;/module&gt; &lt;module&gt;config-client-demo&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;tech.aistar&lt;/groupId&gt; &lt;artifactId&gt;parent-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;parent-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建注册中心模块moudle eureka-demo模块,pom.xml文件如下: 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;tech.aistar&lt;/groupId&gt; &lt;artifactId&gt;parent-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;tech.aistar&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; eureka-demo的application.yml文件配置如下: 1234567891011121314151617181920spring: application: name: eureka-demo server: port: 8888eureka: instance: # 注册到eurekaip地址 hostname: localhost client: # 因为自己是注册中心,不需要自己注册自己 register-with-eureka: false # 因为自己是注册中心,不需要检索服务 fetch-registry: false service-url: # 服务注册中心的配置内容，指定服务注册中心的位置 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ preferIpAddress: true 添加启动类: 123456789@SpringBootApplication//开启注册中心@EnableEurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 访问网页,查看EurekaServer 生产者和消费者注册及调用实战生产者 - user-demo 创建用户user-demo用户服务,pom.xml文件如下: 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; user-demo的application.yml文件配置如下: 123456789101112131415161718spring: application: name: user-demoserver: port: 8885eureka: instance: # 注册到eurekaip地址 hostname: localhost client: register-with-eureka: true fetch-registry: true service-url: # 服务注册中心的配置内容，指定服务注册中心的位置 defaultZone: http://localhost:8888/eureka/ preferIpAddress: true user-demo的启动类 12345678910@SpringBootApplication//开启eureka的客户端注解@EnableEurekaClient@EnableDiscoveryClientpublic class UserDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserDemoApplication.class, args); &#125;&#125; 消费者 - order-demo 创建moudle - order-demo订单服务,pom.xml文件如下: 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; order-demo的application.yml 123456789101112131415161718spring: application: name: order-demoserver: port: 8882eureka: instance: # 注册到eurekaip地址 hostname: localhost client: register-with-eureka: true fetch-registry: true service-url: # 服务注册中心的配置内容，指定服务注册中心的位置 defaultZone: http://localhost:8888/eureka/ preferIpAddress: true order-demo的启动类 123456789@SpringBootApplication@EnableEurekaClientpublic class OrderDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderDemoApplication.class, args); &#125;&#125; 最后,一次启动服务注册中心eureka-demo,user-demo和order-demo Feign介绍Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果 简而言之： Feign 采用的是基于接口的注解 RestTemplate和feign区别使用RestTemplate时，URL参数是以编程方式构造的，数据被发送到其他服务。 Feign是Spring Cloud Netflix库，用于在基于REST的服务调用上提供更高级别的抽象。Spring Cloud Feign在声明性原则上工作。使用Feign时，我们在客户端编写声明式REST服务接口，并使用这些接口来编写客户端程序。开发人员不用担心这个接口的实现。 实战需求:在order-demo服务中调用user-demo服务的程序. 在user-demo服务中添加controller - UserController.java 123456789101112@RestControllerpublic class UserController &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id)&#123; if(id == 1)&#123; return &quot;min&quot;; &#125;else&#123; return &quot;驰星&quot;; &#125; &#125;&#125; 修改order-demo服务pom.xml文件,添加如下配置: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 修改order-demo服务,添加FeignService.java 123456@FeignClient(value = &quot;user-demo&quot;)public interface FeignService &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id);&#125; 修改order-demo服务,添加controller - OrderController.java 12345678910111213@RestControllerpublic class OrderController &#123; @Autowired private FeignService feignService; @GetMapping(&quot;/order&quot;) public String getOrder(Integer id,String name)&#123; //调用user-demo的信息 String result = feignService.get(id); return &quot;商品名称:&quot;+name+&quot;,生成订单:&quot;+result; &#125; 修改order-demo的启动类 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class OrderDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderDemoApplication.class, args); &#125;&#125; 测试 分别启动eureka-demo,user-demo,order-demo Feign负载均衡效果测试 启动eureka-demo 启动user-demo 再次启动第二个实例user-demo,在启动之前,修改user-demo的application.yml 和UserController.java 123# 修改端口号server: port: 8886 UserController.java 为了体现俩个服务实例的区别,把”驰星”修改成”驰星1” 123456789101112@RestControllerpublic class UserController &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id)&#123; if(id == 1)&#123; return &quot;min&quot;; &#125;else&#123; return &quot;驰星1&quot;; &#125; &#125;&#125; 启动order-demo 测试1 - http://localhost:8882/order?id=2&amp;name=tom 测试2 - http://localhost:8882/order?id=2&amp;name=tom 采用”轮询”的方式进行调用! 测试3 - 断掉其中一个user-demo的服务实例,再次输入上面的地址进行测试 Eureka会将服务端的服务信息缓存到本地测试将eureka-demo服务停止,测试order-demo是否能够调用user-demo 结论:是可以正常调用的! hystrix熔断器为什么要使用熔断器? 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 为了解决这个问题，业界提出了断路器模型。 熔断器简介Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图： 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。 hystrix特性 请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力. 服务降级：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。 依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放，后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。 请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。 请求缓存是在同一请求多次访问中保证只调用一次这个服务提供者的接口，在这同一次请求第一次的结果会被缓存，保证同一请求中同样的多次访问返回结果相同。 请求合并：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。 hystrix流程结构解析 流程说明: 12345678910111213141516171819201:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.2:执行execute()/queue做同步或异步调用.3:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤.4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤.5:调用HystrixCommand的run方法.运行依赖逻辑5a:依赖逻辑调用超时,进入步骤8.6:判断逻辑是否调用成功6a:返回成功调用结果6b:调用出错，进入步骤8.7:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.8:getFallback()降级逻辑. 以下四种情况将触发getFallback调用： (1):run()方法抛出非HystrixBadRequestException异常。 (2):run()方法调用超时 (3):熔断器开启拦截调用 (4):线程池/队列/信号量是否跑满8a:没有实现getFallback的Command将直接抛出异常8b:fallback降级逻辑调用成功直接返回8c:降级逻辑调用失败抛出异常9:返回执行成功结果 服务降级实战 修改order-demo的pom.xml,增加 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; order-demo,启动类开启 1@EnableHystrix //启用熔断器 order-demo的application.yml开启hystrix功能 1234# yml开启hystrix功能feign: circuitbreaker: enabled: true order-demo服务中添加fallback类 123456789101112/** * @author success * @version 1.0 * @description:本类用来演示:调用user服务的时候,如果出现错误,则调用此处的代码 */@Componentpublic class MyFallback implements FeignService&#123; @Override public String get(Integer id) &#123; return &quot;error get(Integer id)&quot;; &#125;&#125; 修改order-demo的FeignService.java 在@FeignClient注解中添加fallback=MyFallback.class 123456@FeignClient(value = &quot;user-demo&quot;,fallback = MyFallback.class)public interface FeignService &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id);&#125; 测试 - 将user-demo服务停止,然后输入 http://localhost:8882/order?id=2&amp;name=tom 出现MyFallback类中的实现语句: 1商品名称:tom,生成订单:error get(Integer id) 依赖隔离 添加OrderCommand.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.service.pool;import com.netflix.hystrix.*;/** * @author success * @version 1.0 * @description:本类用来演示:依赖隔离 * @date 2019/8/26 0026 */public class OrderCommand extends HystrixCommand&lt;String&gt;&#123; private String value; public OrderCommand(String value) &#123; super(Setter.withGroupKey( //服务分组 HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;)) //线程分组 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;)) //线程池配置 .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter() .withCoreSize(10) .withKeepAliveTimeMinutes(5) .withMaxQueueSize(10) .withQueueSizeRejectionThreshold(10000)) .andCommandPropertiesDefaults( HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))); this.value = value; &#125; @Override protected String run() throws Exception &#123; String threadName = Thread.currentThread().getName(); return threadName + &quot; || &quot; + value; &#125;&#125; 添加UserCommand.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.service.pool;import com.netflix.hystrix.*;/** * @author success * @version 1.0 * @description:本类用来演示: * @date 2019/8/26 0026 */public class UserCommand extends HystrixCommand&lt;String&gt;&#123; private String value; public UserCommand(String value) &#123; super(Setter.withGroupKey( //服务分组 HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;)) //线程分组 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;)) //线程池配置 .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter() .withCoreSize(10) .withKeepAliveTimeMinutes(5) .withMaxQueueSize(10) .withQueueSizeRejectionThreshold(10000)) .andCommandPropertiesDefaults( HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))); this.value = value; &#125; @Override protected String run() throws Exception &#123; String threadName = Thread.currentThread().getName(); return threadName + &quot; || &quot; + value; &#125;&#125; 添加OrderService.java 12345678910111213141516171819202122232425262728@Servicepublic class OrderService &#123; @Autowired private FeignService feignService; // 测试依赖隔离 public String testPool() &#123; UserCommand userCommand = new UserCommand(&quot;库里&quot;); OrderCommand orderCommand1 = new OrderCommand(&quot;篮球&quot;); OrderCommand orderCommand2 = new OrderCommand(&quot;足球&quot;); // 同步调用 String val1 = userCommand.execute(); String val2 = orderCommand1.execute(); String val3 = orderCommand2.execute(); // 异步调用// Future&lt;String&gt; f1 = userCommand.queue();// Future&lt;String&gt; f2 = userCommand.queue();// Future&lt;String&gt; f3 = userCommand.queue(); return &quot;val1=&quot; + val1 + &quot;val2=&quot; + val2 + &quot;val3=&quot; + val3; // return &quot;f1=&quot; + f1.get() + &quot;f2=&quot; + f2.get() + &quot;f3=&quot; + f3.get(); &#125;&#125; order-demo控制层添加 1234@GetMapping(&quot;/testpool&quot;)public String testPool()&#123; return orderService.testPool();&#125; 测试:http://localhost:8882/testpool 1val1=hystrix-UserPool-1 || 库里val2=hystrix-OrderPool-1 || 篮球val3=hystrix-OrderPool-2 || 足球 请求合并 如图，多个客户端发送请求调用(消费者)项目中的findOne方法，这时候在这个项目中的线程池中会发申请与请求数量相同的线程数，对EurekaServiceProvider(服务提供者)的getUserById方法发起调用，每个线程都要调用一次，在高并发的场景下，这样势必会对服务提供者项目产生巨大的压力。 请求合并就是将单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法 请求合并的原理NetFlix在Hystrix为我们提供了应对高并发的解决方案—-请求合并，如下图 通过请求合并器设置延迟时间，将时间内的，多个请求单个的对象的方法中的参数（id）取出来，拼成符合服务提供者的多个对象返回接口（getUsersByIds方法）的参数，指定调用这个接口（getUsersByIds方法），返回的对象List再通过一个方法（mapResponseToRequests方法），按照请求的次序将结果对象对应的装到Request对应的Response中返回结果。 请求合并适用场景在服务提供者提供了返回单个对象和多个对象的查询接口，并且单个对象的查询并发数很高，服务提供者负载较高的时候，我们就可以使用请求合并来降低服务提供者的负载 请求合并带来的问题 我们为这个请求人为的设置了延迟时间，这样在并发不高的接口上使用请求缓存，会降低响应速度 实现请求合并比较复杂 使用注解配置 OrderService.java中添加 12345678910111213141516171819202122/** * 演示请求合并 * @param id * @return */ @HystrixCollapser(batchMethod = &quot;findAll&quot;,collapserProperties = &#123; @HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;,value = &quot;300&quot;) &#125;) public Future&lt;String&gt; findOne(Integer id)&#123; System.out.println(&quot;被合并的请求!&quot;); return null; &#125; @HystrixCommand public List&lt;String&gt; findAll(List&lt;Integer&gt; ids)&#123; System.out.println(&quot;合并的请求&quot;); List&lt;String&gt; results = new ArrayList&lt;&gt;(); for(Integer id:ids)&#123; results.add(feignService.get(id)); &#125; return results; &#125; OrderController.java中添加 123456789101112131415161718/** * 请求合并 * @return */@GetMapping(&quot;/getMerge&quot;)public String getMerge() throws ExecutionException, InterruptedException &#123; HystrixRequestContext context = HystrixRequestContext.initializeContext(); //必须是异步 Future&lt;String&gt; r1 = orderService.findOne(1); Future&lt;String&gt; r2 = orderService.findOne(2); // Thread.sleep(1000); Future&lt;String&gt; r3 = orderService.findOne(1); //context.close(); return &quot;u1:&quot;+r1.get()+&quot;,u2:&quot;+r2.get()+&quot;r3:&quot;+r3.get();&#125; 测试 1http://localhost:8882/getMerge 观察控制台 - order-demo控制台只会出现一次”合并的请求” 1合并的请求 请求缓存 OrderService.java 12345678910111213/** * 请求缓存,如果俩次请求的cacheKey是一样的,则此处的代码仅仅会执行一次 * 此处是采用注解的配置方式 * @param id * @param cacheKey * @return */ @CacheResult @HystrixCommand(commandKey = &quot;cache-user&quot;) public String getUser(Integer id,@CacheKey Long cacheKey)&#123; System.out.println(&quot;请求缓存,如果cacheKey是一样的,则不会再执行!&quot;); return feignService.get(id); &#125; 控制层 12345678910111213141516/** * 请求缓存 * @return */ @GetMapping(&quot;/getCache&quot;) public String getCache()&#123; HystrixRequestContext context = HystrixRequestContext.initializeContext(); Long key = 9999L; String u1 = orderService.getUser(1,key); String u2 = orderService.getUser(2,9998L); context.close(); return &quot;u1:&quot;+u1+&quot;,u2:&quot;+u2; &#125; 路由网关zuul为什么需要服务网关 在分布式系统系统中，有商品、订单、用户、广告、支付等等一大批的服务，前端怎么调用呢？和每个服务一个个打交道？这显然是不可能的，这就需要有一个角色充当所有请求的入口，这个角色就是服务网关（API gateway） 客户端直接与微服务通讯的问题 客户端会多次请求不同的微服务，增加了客户端的复杂性。 存在跨域请求，在一定场景下处理相对复杂。 认证复杂，每个服务都需要独立认证。 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通讯，那么重构将会很难实施。 网关的优点 易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。 易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。 减少了客户端与各个微服务之间的交互次数。 什么是网关？服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 使用zuul 新建zuul-demo模块 pom.xml文件 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; application.xml 1spring: application: name: zuul-demoserver: port: 9000eureka: instance: hostname: localhost client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8888/eureka/ preferIpAddress: truezuul: routes: # 配置统一前缀访问 api-order: path: /api-order/** serviceId: order-demo api-user: path: /api-user/** serviceId: user-demo 启动类 1@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient// 开启zuul功能@EnableZuulProxypublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 测试路由访问 1# 测试1:http://localhost:9000/api-order/testpool# 测试2:http://localhost:9000/api-user/user/1# 测试3:http://localhost:9000/user-demo/user/1# 测试4:http://localhost:9000/order-demo/testpool 都是允许访问的 配置统一前缀访问 1zuul: routes: # 配置统一前缀访问 api-order: path: /api-order/** serviceId: order-demo api-user: path: /api-user/** serviceId: user-demo #前缀访问 prefix: /parent 测试路由访问: 1# http://localhost:9000/parent/api-order/testpool# http://localhost:9000/parent/order-demo/testpool 忽略服务名serviceId访问 1zuul: routes: # 配置统一前缀访问 api-order: path: /api-order/** serviceId: order-demo api-user: path: /api-user/** serviceId: user-demo # 前缀访问 prefix: /parent # 忽略服务名serviceId访问 ignored-services: &quot;*&quot; 测试路由访问 1#测试 http://localhost:9000/parent/api-order/testpool -&gt;ok#测试http//localhost:9000/parent/order-demo/testpool -&gt;error 配url绑定映射 1zuul: routes: testurl: # url: http://www.iduoan.com url: http://localhost:8885/ path: /testurl/** 测试路由访问: 1# 测试 http://localhost:9000/testurl/user/1 配置URL映射负载 1ribbon: eureka: enabled: false#Ribbon请求的微服务serviceIdsuccess-user: ribbon: listOfServers: http://www.huya.com,http://www.douyu.comzuul: routes: testurl: serviceId: success-user path: /testurl/** zuul过滤器Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能，zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器，简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。 添加过滤器类1package tech.aistar.filter;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.exception.ZuulException;import com.sun.scenario.effect.FilterContext;import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;import org.springframework.stereotype.Component;/** * @author success * @version 1.0 * @description:本类用来演示: * Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能， * zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器， * 简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。 */@Componentpublic class MyFilter01 extends ZuulFilter&#123; /** * 类型包含 pre post route error * pre 代表在路由代理之前执行 * route 代表代理的时候执行 * error 代表出现错的时候执行 * post 代表在route 或者是 error 执行完成后执行 */ @Override public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; @Override public int filterOrder() &#123; // 优先级，数字越大，优先级越低 return 1; &#125; @Override public boolean shouldFilter() &#123; // 是否执行该过滤器，true代表需要过滤 return true; &#125; @Override public Object run() throws ZuulException &#123; System.out.println(&quot;1111111111111111111&quot;); return null; &#125;&#125; 高可用分布式配置中心在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 没有使用统一配置中心时，所存在的问题 配置文件分散在各个项目里，不方便维护 配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的 更新配置后，项目需要重启 有哪些开源配置中心spring-cloud/spring-cloud-confighttps://github.com/spring-cloud/spring-cloud-configspring出品，可以和spring cloud无缝配合diamondhttps://github.com/takeseem/diamonddisconfhttps://github.com/knightliao/disconfctrip apollohttps://github.com/ctripcorp/apollo/Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。 快速入门config-server 创建config-server-demo工程 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 启动类 1@SpringBootApplication@EnableConfigServerpublic class ConfigServerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerDemoApplication.class, args); &#125;&#125; 配置文件 1server: port: 9100spring: application: name: config-server-demo cloud: config: server: git: uri: https://gitee.com/guancg/config-server-demo.git 创建码云仓库 https://gitee.com/guancg/config-server-demo.git 创建测试的配置文件 文件名-环境名.后缀 config支持我们使用的请求的参数规则为： / { 应用名 } / { 环境名 } [ / { 分支名 } ]http://localhost:9100/config-server-demo/dev / { 应用名 } - { 环境名 }.yml/ { 应用名 } - { 环境名 }.propertieshttp://localhost:9100/config-server-demo-dev.properties / { 分支名 } / { 应用名 } - { 环境名 }.yml/ { 分支名 } / { 应用名 } - { 环境名 }.propertieshttp://localhost:9100/master/config-server-demo-dev.properties 快速入门config-client 创建config-client-demo模块 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 启动类 1@SpringBootApplicationpublic class ConfigClientDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientDemoApplication.class, args); &#125;&#125; 测试controller 1@RestController//刷新消息组件@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; @GetMapping(&quot;/value&quot;) public String getName()&#123; return name; &#125;&#125; bootstrap.yml 1server: port: 9201spring: application: name: config-client-demo # 指定了配置文件的应用名 cloud: config: uri: http://localhost:9100/ #Config server\\的uri profile: dev #指定的环境 label: master #指定的分支 http://localhost:9201/value Config+Bus : 实现动态刷新 config-client-demo模块添加依赖 1&lt;!--消息总件组件--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加注解 1//刷新消息组件@RefreshScopepublic class ConfigClientController &#123;&#125; 启动rabbitmq消息队列 修改配置文件 1server: port: 9201spring: application: name: config-client-demo # 指定了配置文件的应用名 cloud: config: uri: http://localhost:9100/ #Config server\\的uri profile: dev #指定的环境 label: master #指定的分支 rabbitmq: host: 192.168.2.49 port: 5672 username: guest password: guestmanagement: # 暴露总线消息地址` endpoints: web: exposure: include: &quot;bus-refresh&quot; cors: allowed-origins: &quot;*&quot; allowed-methods: &quot;*&quot; #测试 - http://localhost:9201/actuator/bus-refresh 本次测试地址：POST请求 1http://localhost:9201/actuator/bus-refresh RabbitMQ简介消息队列中间件消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。其使用场景为：异步处理，应用解耦，流量削锋和消息通讯四个场景。 什么是RabbitMQRabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括： 可靠性(Reliability)：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 灵活的路由(Flexible Routing)：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 消息集群(Clustering)：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 高可用(Highly Available Queues)：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 多种协议(Multi-protocol)：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 多语言客户端(Many Clients)：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 管理界面(Management UI)：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 跟踪机制(Tracing)：如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 插件机制(Plugin System)：RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件 架构图 主要概念RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。 Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytes， Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。 Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。 VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用. 安装自己搞定 RabbitMQ三种模式直接模式 我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。 一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。 这种模式下不需要将Exchange进行任何绑定(binding)操作消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。 创建队列 首先在浏览器登录RabbitMQ：http://192.168.2XX.129:15672 ，按照下图创建一个队列就可以了: 代码 添加依赖 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; yml 1server: port: 8010spring: application: name: rabbitmq-demo rabbitmq: host: 192.168.2.49 启动类 1@SpringBootApplicationpublic class RabbitmqDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RabbitmqDemoApplication.class, args); &#125;&#125; 接下来我们写生产者代码（生产者采用Junit和SpringBoot整合） 1@RunWith(SpringRunner.class)@SpringBootTestpublic class RabbitmqDemoApplicationTests &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 直接模式 */ @Test public void contextLoads() &#123; //在直接模式的队列中放入数据 rabbitTemplate.convertAndSend(&quot;j05_direc&quot;,&quot;我是直接模式!&quot;); &#125;&#125; 此时你运行生产者函数时，在消息队列的界面会显示一条消息（Ready） 消费者代码 1/** * 运行方式:直接启动springboot的启动类,在控制台观察msg * @author success * @version 1.0 * @description:本类用来演示:消费直接模式消息队列中的数据 * @date 2019/9/2 0002 */@Component@RabbitListener(queues = &quot;j05_direc&quot;)public class DirectionController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;直接模式j05_direc-&gt;msg:&quot;+msg); &#125;&#125; 当你运行消费者代码时，在run栏会打印出： 当然，你想设置多个消费者时，我们可以将springboot单例运行选项去掉 然后改掉配置文件的端口号，重新把程序跑一次，这样，就有两个消费者了，再改端口号，再运行就是三个消费者了。多运行几次生产者的测试函数，三个消费者会轮流输出（因为这里是默认负载均衡的，所有会轮流输出）。 分裂模式当我们需要将消息一次发给多个队列时，需要使用这种模式。如下图： 任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。 可以理解为路由表的模式 这种模式不需要RouteKey 这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。 如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃. 交换器绑定队列 创建三个队列 j05_direc和cctv1和cctv2 创建j05_alls交换器 将j05_alls交换器和三个队列进行绑定 这样向j05_alls交换器里发消息，交换器就会向绑定的三个消息队列里面发消息（）。 测试 生产者 1/** * 分裂模式 */@Testpublic void testFadeIn()&#123; //在分裂模式中的exchanges中放入数据 rabbitTemplate.convertAndSend(&quot;j05_alls&quot;,&quot;&quot;,&quot;我是分裂模式!&quot;);&#125; 三个消费者 消费者1 1@Component@RabbitListener(queues = &quot;j05_direc&quot;)public class DirectionController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;直接模式j05_direc-&gt;msg:&quot;+msg); &#125;&#125; 消费者2 1@Component@RabbitListener(queues = &quot;cctv1&quot;)public class FadeOutController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;分裂模式-cctv1-&gt;msg:&quot;+msg); &#125;&#125; 消费者3 1@Component@RabbitListener(queues = &quot;cctv2&quot;)public class TopicController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;主题模式模式cctv2-&gt;msg:&quot;+msg); &#125;&#125; 运行后可得下面结果 主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上 如上图所示此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.newsusa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。 注：交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上 这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。这种模式需要RouteKey，也许要提前绑定Exchange与Queue。在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息 创建队列与绑定和分裂模式一样，只是在Exchanges设置里面添加Routing Key 代码编写 分裂模式一样，只需要在3个Customer类里面修改下convertAndSend的参数就可以了 1/** * 主题模式 */@Testpublic void testTopic()&#123; //分别测试 rabbitTemplate.convertAndSend(&quot;j05_topic&quot;,&quot;good.log&quot;,&quot;我是主题模式!&quot;);&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"}]},{"title":"数组排序","slug":"各数组排序","date":"2021-08-10T09:54:17.000Z","updated":"2022-01-10T02:16:58.543Z","comments":true,"path":"2021/08/10/各数组排序/","link":"","permalink":"http://example.com/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"数组排序简介:重点掌握冒泡,选择,快速排序 冒泡排序相邻的俩个进行俩俩比较. 每一轮比较完 - 确定一个最值 9 3 1 7 5 2 1 3 9 1 7 5 2 1 3 1 9 7 5 2 1 3 1 7 9 5 2 1 3 1 7 5 9 2 1 3 1 7 5 2 9 1 3 1 7 5 2 1 9 选择排序9 3 1 7 5 2 6 arr[0] -&gt; 依次和 后面所有的元素进行比较 3 9 1 7 5 2 6 1 9 3 7 5 2 6 确定最值 arr[1] -&gt; 依次和后面的所有的元素进行比较 1 2 9 7 5 3 6 直接插入排序简介:最简单的 将数组中剩余的值(从数组中第2个位置开始)依次直接插入到前面,保证前面的序列仍然是一个有序的序列 {3,1,2,5,4,6} {3,1,2,5,4,6} {1,3,2,5,4,6} {1,2,3,5,4,6} … 快速排序 算法思想: 分治思想:比大小,再分区 从数组中取出一个数,作为基准数 分区:将比这个数[基准数]大或者等于的数全部放在它的右边,小于它的数全部放在它的左边 再对左右分区间重复第二步骤,直到各分区只有一个数 实现思路: 挖坑填数 将基准数挖出形成第一个坑 由后向前找比它小的数,找到后挖出此数填到前一个坑中 由前向后找比它大或等于的数,找到后也挖出此数填到前一个坑中 再重复执行2,3两步骤.例如对5391672408 元素 5 3 9 1 6 7 2 4 0 8 坑位 坑1 坑3 坑5 坑7 坑6 坑4 坑2 0 3 4 1 2 基准数5 7 6 9 8 坑位 pos 元素 5[基准数] 3 9 1 6 7 2 4 0 8 坑位 坑1 坑3 坑5 坑7 坑6 坑4 坑2 0 3 4 1 2 基准数5 7 6 9 8 坑位 第一次重合的位置 第一轮以数组中的第一个元素5为基准数 - 经过一轮循环走完 - 以5位置为基准,左边的都是比5小的值,右边的都是大于或者等于5的数字 - 关键就是找到重合的位置!!!(分区 - 递归调用) int[] arr = {5,3,9,1,6,7,2,4,0,8}; t 其他排序 希尔排序 堆排序 归并排序6t","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day16","slug":"day16","date":"2021-08-01T11:02:10.000Z","updated":"2022-01-07T09:04:19.548Z","comments":true,"path":"2021/08/01/day16/","link":"","permalink":"http://example.com/2021/08/01/day16/","excerpt":"","text":"反射定义 反射式编程（英语：reflective programming）或反射（英语：reflection)或者内省 是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 “通俗讲” - 通过反射技术在程序的运行过程中,来获取类/接口的信息[修饰符,类的名称,父类],属性的信息[修饰符,数据类型,属性名],方法的信息[修饰符,数据类型,名称]等. 在运行的时候才知道我操作的是哪个类 掌握目标: 3-1. 通过反射技术来动态获取属性的信息以及操作属性[反射的技术来对属性的值进行设置和获取] 3-2. 通过反射技术来动态调用类中的构造方法以及获取构造方法的信息[修饰符,方法名,参数列表] 3-3. 通过反射技术来动态获取类里面的方法的信息[修饰符,数据类型,方法名以及方法参数列表]以及反射调用方法 api包 - java.lang.reflect 反射优势 - “很流氓” - 破坏封装性. 学好反射和设计模式 - 帮助我们未来来读懂一些框架源码的.所有的框架的底层都是基于反射技术来实现的. java.lang.Class class实例 - 一个类无论被实例化多少次,那么它在JVM中的class实例永远只有1个. 它是学习反射技术的必备的类 - 提供了很多api来完成掌握目标中的动作. 所有被类加载器加载到内存中的类都是属于Class的对象 - Class类是用来描述类的类[用来描述类的元信息] 我们的类在Class面前,就是一个Class的对象而已 反射相关api Field getDeclaredField(String name);//根据属性的名称来得到Field对象 Field[] getDeclaredFields();//获取类里面所有的[包括私有的]声明的属性对应的Field数组 123只能获取到非私有的1. Field getField(String name);2. Field[] getFields(); String getName();//获取类的全限定名 String getSimpleName();//获取类的简称 T newInstance();//调用空参构造 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes); 根据指定的参数类型来得到指定的构造对应的实例Constructor对象. 如果什么参数都不传入,拿到的就是空参构造对应的Constructor对应的实例. Constructor&lt;?&gt;[] getDeclaredConstructors(); 直接获取类中的所有的构造,每个构造对应一个Constructor. Method getDeclaredMethod(String methodName,Class&lt;?&gt;… parameterTypes); Method][] getDeclaredMethods(); 获取类的Class实例的方式 类名.class 调用java.lang.Object类提供的方法Class&lt;?&gt; getClass(); 框架底层喜欢的使用一种,更加灵活 Class类中提供的static Class&lt;?&gt; forName(“类的全限定名”);//需要抓取一个非运行时异常java.lang.ClassNotFoundException类型找不到异常 基本类型.class demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day16;/** * 本类用来演示: java.lang.Class&lt;T&gt; * * * @author: success * @date: 2021/8/12 10:26 上午 */public class ClassDemo &#123; public static void main(String[] args) &#123; //获取类的class实例的方式 //每个类在JVM中的class实例永远只有1个 - 无论构建了多少个对象 //1. 类名.class Class&lt;?&gt; c1 = Point.class; Class&lt;?&gt; c2 = Point.class; System.out.println(c1);//class tech.aistar.day16.Point System.out.println(c1 == c2); Class&lt;?&gt; c3 = String.class; System.out.println(c3);//class java.lang.String //2. 对象.getClass(); Point p1 = new Point(); Point p2 = new Point(); Class&lt;?&gt; c4 = p1.getClass();//对象的类型 Class&lt;?&gt; c5 = p2.getClass(); // 类型判断 对象 instanceof 类 System.out.println(c4);//class tech.aistar.day16.Point System.out.println(c4 == c5);//true //3. Class类中提供的static Class&lt;?&gt; forName(&quot;类的全限定名&quot;); //TODO... 为甚鼓励使用这种 ??? try &#123; Class&lt;?&gt; c6 = Class.forName(&quot;tech.aistar.day16.Point&quot;); System.out.println(&quot;c6:&quot;+c6);//c6:class tech.aistar.day16.Point &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; //4. 基本类型.class Class&lt;?&gt; c7 = int.class; System.out.println(c7);//int &#125;&#125; Field字段实例 java.lang.reflect.Field api int getModifiers();返回由该 Field对象表示的字段的Java语言修饰符，作为整数。 1234//默认的 - 0//public -1//private - 2//protected - 4 Class&lt;?&gt; getType();//返回属性的数据类型 String getName();//属性的名称 void set(Object obj,Object value);//通过属性对应的Field对象来告知JVM,应该把value设置到哪个obj对象上去. void setAccessible(boolean on);//反射操作私有属性,必须要设置为true,否则会抛出-java.lang.IllegalAccessException Object get(Object obj);//返回obj中属性字段的对应的属性值. Constructor构造实例调用空参构造 直接调用java.lang.Class提供的方法T newsIntance(); java.lang.reflect.Constructor提供了方法 1234public T newInstance(Object... initargs) Constructor&lt;?&gt; c1 = c.getDeclaredConstructor();Point p2 = (Point) c1.newInstance();//可变长列表的方法 调用带参构造 java.lang.reflect.Constructor - 提供的方法 public T newInstance(Object … initargs) 常用方法 int getModifiers();//获取修饰符对应的数字 String getName();//构造方法的名称 - [类的全限定名] void setAccessible(boolean on);//如果设置true,直接调用私有的的构造方法 1反射可以破坏单例 Modifier java.lang.reflect 传入一个修饰符对应的数字,来返回修饰的具体的中文的名称 1234567891011121314151617181920212223public static String toString(int mod) &#123; StringBuilder sb = new StringBuilder(); int len; if ((mod &amp; PUBLIC) != 0) sb.append(&quot;public &quot;); if ((mod &amp; PROTECTED) != 0) sb.append(&quot;protected &quot;); if ((mod &amp; PRIVATE) != 0) sb.append(&quot;private &quot;); /* Canonical order */ if ((mod &amp; ABSTRACT) != 0) sb.append(&quot;abstract &quot;); if ((mod &amp; STATIC) != 0) sb.append(&quot;static &quot;); if ((mod &amp; FINAL) != 0) sb.append(&quot;final &quot;); if ((mod &amp; TRANSIENT) != 0) sb.append(&quot;transient &quot;); if ((mod &amp; VOLATILE) != 0) sb.append(&quot;volatile &quot;); if ((mod &amp; SYNCHRONIZED) != 0) sb.append(&quot;synchronized &quot;); if ((mod &amp; NATIVE) != 0) sb.append(&quot;native &quot;); if ((mod &amp; STRICT) != 0) sb.append(&quot;strictfp &quot;); if ((mod &amp; INTERFACE) != 0) sb.append(&quot;interface &quot;); if ((len = sb.length()) &gt; 0) /* trim trailing space */ return sb.toString().substring(0, len-1); return &quot;&quot;;&#125; 拓展应用反射可以破坏单例 反射破坏不了枚举单例 12345678910111213141516171819202122232425262728293031323334353637383940414243package tech.aistar.day16;import tech.aistar.design.singleton.version03.Singleton03;import tech.aistar.design.singleton.version04.Singleton04;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * 本类用来演示: 反射可以破坏单例 * * @author: success * @date: 2021/8/12 2:25 下午 */public class ReflectPoSingleton &#123; public static void main(String[] args) &#123; //1. 获取单例的Class实例 try &#123; Class&lt;?&gt; c = Class.forName(&quot;tech.aistar.design.singleton.version03.Singleton03&quot;); //2. 获取空参构造对应的Constructor实例 Constructor&lt;?&gt; c1 = c.getDeclaredConstructor(); //3. 调用私有的空参构造 c1.setAccessible(true); //4. 调用 Singleton03 s1 = (Singleton03) c1.newInstance(); //反射连续调用俩次私有的空参构造 Singleton03 s2 = (Singleton03) c1.newInstance(); System.out.println(s1 == s2);//false &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 为何破坏不了枚举类型单例分析-NoSuchMethodException123//记载类,初始化静态属性,调用空参构造 Class&lt;?&gt; c5 = Class.forName(&quot;tech.aistar.design.singleton.version05.Singleton05&quot;);Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(); 12345678控制台效果比较繁琐的操作的事情,费时费力的事情//不存在一个空参构造的方法让我们去调用java.lang.NoSuchMethodException: tech.aistar.design.singleton.version05.Singleton05.&lt;init&gt;() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at tech.aistar.day16.ReflectPoSingleton.main(ReflectPoSingleton.java:36) 控制台 hello.java 123public enum hello&#123; INSTANCE&#125; 1234确认jdk-bin-jad.exe - 没有下载 - http://varaneckas.com/jad/javac hellojad -s java hello反编译之后出来之后 hello(String.class,int.class) 解决方案1Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,int.class); 分析 - IllegalArgumentException 12345678910//加载这个类Class&lt;?&gt; c5 = Class.forName(&quot;tech.aistar.design.singleton.version05.Singleton05&quot;);Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,int.class);//java.lang.NoSuchMethodException - 抛出一个不存在这个方法cc.setAccessible(true);//Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: // Cannot reflectively create enum objectsSingleton05 s05 = (Singleton05) cc.newInstance(); 原因剖析newInstance方法 1234567891011@CallerSensitivepublic T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException&#123; //判断是否为枚举类型,如果是枚举类型直接抛出了这个异常了. if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)&#123; throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); &#125; return inst;&#125; 结论 - 不允许我们用反射的技术来构建枚举类型的实例,底层会进行类型的判断,发现如果是枚举类型对应的class实例,直接抛出异常 作业 一个对象的中的所有String类型的成员变量所对应的字符串内容中的”b”改为”a” 123456789101112131415public class Obj&#123; private int age = 10; private String s2 = &quot;b&quot;; private String name = &quot;tbm&quot;; private String s1 = &quot;adminb&quot;; //...&#125;//反射技术 - 所有字段拿出来 - Field数组中 //获取到Field的类型,判断是不是String类型//如果是String-&quot;b&quot;改为&quot;a&quot; 反射工厂 回忆工厂设计模式[GOF] 简单工厂方法,多方法工厂,静态方法工厂 - 本质上不属于GOF 工厂方法设计模式以及抽象工厂[专注于产品族] - 属于GOF 反射工厂 - 工厂类中利用反射技术来构建某个类的/接口的具体的实例. 补充Properties 属于集合框架的类 - 属于Map[I] java.util.Properties extends java.util.Hashtable[哈希表,多线程安全的] 作用:通过io流把本地的.properties文件读取到内存中,然后映射到Properties对象 Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. File - 本地磁盘的文件在java内存中的映射的那个对象. 存储数据的格式然后是一个键值对的形式 123# key=value - key也是不要重复的.username=tompassword=123 根据key来获取value的方法 1String getProperty(String key); demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day16.prop; import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.Properties; /** * 本类用来演示: 读取Properties文件 * * @author: success * @date: 2021/8/13 8:41 上午 */public enum ReadPropDemo &#123; INSTANCE; // 定义一个Properties属性 private Properties properties; ReadPropDemo()&#123; //可以在构造方法 - 初始化的 //Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. properties = new Properties(); //读取属性文件 //InputStream in = new FileInputStream(&quot;src/tech/aistar/day16/prop.bean.properties&quot;); //固定的语法 - 死记住 //获取属性文件字节输入流 InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream(&quot;tech/aistar/day16/prop/bean.properties&quot;); //加载 try &#123; //Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //普通方法 public String getValue(String key)&#123; //确认properties不为null return properties == null?null:properties.getProperty(key); &#125;&#125; 单元测试 1234567891011121314package tech.aistar.day16.prop; /** * 本类用来演示: * * @author: success * @date: 2021/8/13 8:47 上午 */public class ReadPropDemoTest &#123; public static void main(String[] args) &#123; String value = ReadPropDemo.INSTANCE.getValue(&quot;username&quot;); System.out.println(value); &#125;&#125; 反射工厂demo 简单工厂的缺点 - 如果有新的产品的加入,需要修改工厂类的 - 违背了软件开发的设计原则 - “开闭原则” 优点 - 够简单 工厂方法设计模式 - 优点:一个工厂类只负责生产一个产品,如果有新的产品的加入.不需要修改工厂类,只需要增加一个工厂类 缺点 - 项目中会存在很多的工厂类. 抽象工厂 - 负责创建一个产品族. 反射工厂既能够保证在新增一个产品的时候,能够遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类. 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.design.factory.reflect;/** * 本类用来演示: 反射工厂 - 反射工厂既能够保证在新增一个产品的时候,能够遵守&quot;开闭原则&quot;, * 又能够保证始终仅仅只有一个工厂类. * * Properties + 反射 + 泛型方法/泛型类 * * @author: success * @date: 2021/8/13 9:13 上午 */public class BaseFactory&lt;T&gt;&#123; //面向接口编程 //泛型方法 - 静态方法&lt;T&gt;,同时也要设置泛型类 public static&lt;T&gt; T getInstance(String type)&#123; T t = null; //如果传入进来的是type - 是某个类的全限定名,比如 //tech.aistar.design.factory.reflect.TeacherDaoImpl //获取class实例的方式 try &#123; Class&lt;?&gt; c = Class.forName(type); //反射调用空参构造 try &#123; //Point p = (Point) c.newInstance(); t = (T) c.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return t; &#125;&#125; Method java.lang.reflect.Method 常用方法 int getModifiers();返回由该 method对象表示的字段的Java语言修饰符，作为整数。 1234//默认的 - 0//public -1//private - 2//protected - 4 Class&lt;?&gt; getReturnType();//返回方法的返回类型 String getName();//方法的名称 Class&lt;?&gt;[] getParameterTypes();//返回方法的参数列表. Object invoke(Object obj,Object… args);//反射调用方法 void setAccessible(boolean on);//调用私有方法需要调用之前来设置可见性 - true Array java.lang.reflect.Array - Array类提供静态方法来动态创建和访问Java数组 - 反射技术操作java数组 面试题 - Arrays和Array的区别! java.util.Arrays - 数组工具类. 常用用法 static int getLength(Object array)返回指定数组对象的长度，如 int 。 static Object get(Object array, int index)返回指定数组对象中的索引组件的值。 static Object newInstance(Class&lt;?&gt; componentType, int length)创建具有指定组件类型和长度的新数组。 static void set(Object array, int index, Object value)将指定数组对象的索引组件的值设置为指定的新值。 demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package tech.aistar.day16;import java.lang.reflect.Array;import java.util.Arrays;/** * 本类用来演示: 反射操作java数组 * * @author: success * @date: 2021/8/13 1:32 下午 */public class ArrayDemo &#123; public static void main(String[] args) &#123; Integer[] arr1 = &#123;10,20,30&#125;; String[] arr2 = &#123;&quot;java&quot;,&quot;python&quot;,&quot;db&quot;,&quot;web&quot;&#125;; //用一个方法,来遍历上面俩个不同元素类型数组 //反射技术来遍历数组 printArr(arr1); System.out.println(&quot;====华丽丽的分割线====&quot;); printArr(arr2); System.out.println(&quot;===反射动态创建数组===&quot;); //对任何元素类型的数组,都可以进行扩容操作 //1. 确定新的数组的长度 - 原来数组的长度+扩容长度[反射创建新的数组] //2. 读取原来数组中的每个下标的数据[反射读取]一一复制到新的数组中[反射设置值] //3. 返回类型确定[扩容之后的] - Object Integer[] temp = (Integer[]) extendsArr(arr1); printArr(temp); System.out.println(&quot;---&quot;); String[] strTemp = (String[]) extendsArr(arr2); printArr(strTemp); &#125; //数组的扩容 public static Object extendsArr(Object arr)&#123; //1. 创建数组必不可少的俩个条件.a. 数组的元素类型 b.数组的长度 //获取旧数组长度 int len = Array.getLength(arr); //确定新的数组的长度 int newLen = len*2; //2. 获取原来数组的组件的类型 - 数组的元素类型 Class&lt;?&gt; type = arr.getClass().getComponentType(); //3. 反射创建新的数组了 Object newArr = Array.newInstance(type,newLen); //4. 把arr旧数组中的元素拷贝新的数组中去 for (int i = 0; i &lt; len; i++) &#123; //根据下标获取值 Object o = Array.get(arr,i); //把o设置到newArr数组的下标i处 Array.set(newArr,i,o); &#125; return newArr; &#125; //反射访问 //Integer[] String[] - 数组 - extends Object //并不是extends Object[] private static void printArr(Object arr) &#123; //1. 数组的长度 int len = Array.getLength(arr); //2. 遍历这个数组 for (int i = 0; i &lt; len; i++) &#123; //反射的技术通过下标去取元素 Object obj = Array.get(arr,i); System.out.println(obj); &#125; &#125;&#125; 注解 只要了解即可.jdk5.0开始引入了注解的机制. 现在框架的配置,框架的使用 - 1. 基于xml的配置方式 2. 基于注解的配置/开发方式 - 简洁 学习注解的目的是为了以后能够知道我们框架的使用中遇到注解,知道这个注解背后是个大概什么底层即可. 内置注解 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 @SuppressWarnings(“all”) - 抑制所有的警告 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 自定义注解 使用@interface来修饰注解,自定义的注解默认都会继承java.lang.Annotation @Target - 指定你这个注解可以在什么地方被使用 哪些地方 - 类,方法,参数,接口,局部变量上,属性,构造 值可以设置成枚举类型java.lang.annotation.ElementType中的枚举常量 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; @Retention(RetentionPolicy.RUNTIME) 可以在程序的运行过程中,通过反射的技术来得到注解的信息. 注解中只有方法的概念,没有的属性的概念 反射获取注解的值 有办法来判断类或者方法是否加入了注解 有办法通过反射技术来获取类/方法上加入注解的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.day16.anno;import java.lang.reflect.Method;import java.util.Arrays;/** * 本类用来演示: 反射获取注解的值 * * @author: success * @date: 2021/8/13 2:39 下午 */public class MyAnnoTest &#123; public static void main(String[] args) &#123; //1. 判断某个类或者某个方法上是否有注解 //有注解 - 标志 - 对这个有注解的类该干嘛干嘛... //注解还配置了属性值 - 需要取出属性值,然后再进行进一步的处理... //类 Class&lt;?&gt; c = UseMyAnno.class; //1. 判断类上是否加入了MyAnno注解 boolean flag = c.isAnnotationPresent(MyAnno.class); if(flag)&#123; System.out.println(c.getSimpleName()+&quot;加入了注解!&quot;); //获取注解的属性值 - 前提是有 MyAnno myAnno = c.getAnnotation(MyAnno.class); //获取属性值 String[] arr = myAnno.value(); System.out.println(Arrays.toString(arr)); &#125;else&#123; System.out.println(c.getSimpleName()+&quot;上没有加入注解!&quot;); &#125; System.out.println(&quot;====方法上的注解的信息 - 反射技术===&quot;); try &#123; Method m = c.getDeclaredMethod(&quot;add&quot;); if(m.isAnnotationPresent(MyAnno.class))&#123; System.out.println(&quot;方法上有注解!&quot;); MyAnno myAnno = m.getAnnotation(MyAnno.class); String[] arr = myAnno.value(); System.out.println(Arrays.toString(arr)); &#125;else&#123; System.out.println(&quot;方法上没有注解...&quot;); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; mybatis注解开发方法 mybatis底层使用到的是jdbc技术 - 和数据库打交道的技术 12345678910jdbc步骤很繁琐,步骤比较多~打开Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;);String sql=&quot;delete from user&quot;;PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery();关闭rs.close();pstmt.close();con.close(); mybatis就是会对jdbc的代码进行一个封装 12345678public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 尝试走一遍mybatis作者的路线 自定义一个注解 123public @interface Select&#123; String value();&#125; 注解本身是不会完成任何的业务逻辑的. 123456789101112通过反射的技术-&gt;select * from user 工具类&#123; Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;); String sql=&quot;反射技术获取的&quot;; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); 关闭 rs.close(); pstmt.close(); con.close();&#125; 第一阶段corejava总结 JVM内存模型+GC算法 - 面试必问 静态代理和动态代理 - 设计模式 体系回顾 part01-基础语法-数组的排重/排序算法/递归算[阶乘,杨辉,斐波那契数列] part02 封装,继承,多态 四种访问修饰符 static关键字,final,abstract修饰符 String,StringBuffer,StringBuilder 包装类型Integer - [IntegerCache缓冲区,-128~127] 设计模式 - 单例[双重锁检测]+工厂+模板+装饰器 Object - equals&amp;hashcode,clone,toString,wait,notify,notifyAll,finalize,getClass() Date&amp;Calendar&amp;SimpleDateFormat&amp;BigInteger - 常用的内置的api part03 - 集合框架 ArrayList&amp;LinkedList&amp;Vector HashSet&amp;TreeSet HashMap&amp;Properties 多线程体系 反射+注解 第二阶段的知识点 周一之前 - mysql环境装好 围绕数据库 mysql学习 - 关系型数据 jdbc学习 - java和db进行交互的技术 myabtis框架学习 - 持久层技术,对jdbc的封装 相关知识点 - mybatis-plus框架,redis - 非关系型数据","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day15","slug":"day15","date":"2021-07-29T10:02:10.000Z","updated":"2022-01-07T09:05:45.563Z","comments":true,"path":"2021/07/29/day15/","link":"","permalink":"http://example.com/2021/07/29/day15/","excerpt":"","text":"进程和线程 一个程序至少一个进程，一个进程至少一个线程。线程不能单独执行运行的,它一定是运行在进程的内部的 进程[正在执行中的应用程序]：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念， 竞争计算机系统资源的基本单位。 - “多任务操作系统” - “多个进程在**”同时”**在运行” - CPU分配资源 - “分时分片” 处理器[cpu]调度的基本单位 线程：是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个进程可以拥有多个线程的同一个进程内部的多个线程是可以共享进程资源的. 比如启动Java程序1234567891. 启动Java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言] 开启一个JVM进程 - jvm.exe[windows中的可执行文件.C语言写的程序直接编译成了.exe可执行文件] 2. 当JVM进程启动之后,同时开启俩个线程 - 分别是main主线程以及一个GC线程[后台守护线程] 守护线程 - 如果后台只剩下守护线程在执行的时候,那么进程就会结束. 进程的结束不需要等到守护线程全部执行完才会结束. 3. main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束 GC线程负责进行垃圾对象的回收 创建线程的传统的方式 写一个类去继承java.lang.Thread类 - 重写里面的run方法 写一个类去实现java.lang.Runnable接口 - 重写里面的run方法 12需要用到java.lang.Thread类中的构造方法Thread(Runnable r); Thread和Runnable区别 第一种方式extends Thread方式 - 共享代码,不共享资源 只有将资源设置成静态的 - 也是进行一个资源的共享的 第二种方式implements Runnable接口 - 共享代码,共享资源 第三种方式Callable接口 推荐配合Future+线程池一起使用 Callable和Runnable接口的区别 Callable可以通过Future来得到异步计算的结果 - 拿到线程执行之后的结果. Callable调用的是call方法,Runnable调用的是run方法. call方法是可以抛出一个异常列表的,但是run方法是不允许抛出异常列表的 Callable+FutureTask1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day15.callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * 本类用来演示: 拿到线程执行之后的结果 * Callable+FutureTask -&gt; 线程执行的结果 * * @author: success * @date: 2021/8/12 8:40 上午 */public class CallableDemo &#123;&#125;class C1 implements Callable&lt;Integer&gt;&#123; public static void main(String[] args) &#123; System.out.println(&quot;main-begin...&quot;); Callable&lt;Integer&gt; c = new C1(); //FutureTask - 异步任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(c); //利用异步任务来构建Thread对象 Thread t = new Thread(task); t.start();//启动线程 System.out.println(&quot;线程已经启动了...&quot;); try &#123; //拿线程计算的结果 //get()方法一定是要等到线程执行结束之后 - 才会停止 System.out.println(&quot;result:&quot;+task.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;main-end...&quot;); &#125; @Override public Integer call() throws Exception &#123; int total = 0; for (int i = 1; i &lt;= 100 ; i++) &#123; total+=i; &#125; //故意模拟一个比较费时费力的任务 Thread.sleep(2000); return total;//5050 &#125;&#125; Callable+Future+线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package tech.aistar.day15.callable;import java.util.concurrent.*;/** * 本类用来演示: Callable+Future&lt;T&gt; + 缓存线程池 * * @author: success * @date: 2021/8/12 8:53 上午 */public class CallablePoolDemo &#123; public static void main(String[] args) &#123; //构建一个可缓存的线程池对象 ExecutorService executorService = Executors.newCachedThreadPool(); //向这个缓存池中提交任务 //第一个任务 - 负责计算1~100 Future&lt;Integer&gt; future1 = executorService.submit(new C2());// 准备启动一个线程 //再向这个缓存池中提交一个任务 //第二个任务 - 负责计算1~10 Future&lt;Integer&gt; future2 = executorService.submit(new CC()); //任务的数量和线程的数量一定一样吗??? //有个效果 -&gt; 俩个线程 - 同时执行这俩个异步任务 //pool-1-thread-1-正在计算1~100 //pool-1-thread-2正在计算1~10 //需要将俩个线程执行的结果进行一个相加的操作 try &#123; //get()方法肯定是会等到线程执行完之后.才会继续走 Integer result1 = future1.get(); Integer result2 = future2.get(); //如果俩个线程get()方法不走完,那么main线程也是不会继续执行的 System.out.println(&quot;开始整合...&quot;); int result = result1 + result2; //main线程 //5050+55 = 5105 System.out.println(Thread.currentThread().getName()+&quot;:&quot;+result); //System.out.println(future1.get()+future2.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService.shutdown(); &#125;&#125;class C2 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()+&quot;-正在计算1~100&quot;); int total = 0; for (int i = 1; i &lt;= 100 ; i++) &#123; total += i; &#125; Thread.sleep(2000); return total; &#125;&#125;class CC implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()+&quot;正在计算1~10&quot;); int total = 0; for (int i = 1; i &lt;=10; i++) &#123; total+=i; &#125; Thread.sleep(2000); return total; &#125;&#125; 线程安全的类和线程非安全的类 StringBuilder - 线程非安全的字符串类,StringBuffer - 线程安全的字符串类 ArrayList - 线程非安全的集合,Vector - 线程安全的集合 HashMap - 线程非安全的集合,Hashtable - 线程安全的集合 以上线程安全的类 - api方法使用到了synchronized方法进行了修饰 - 在某个时刻,只能由一个线程去访问,其他线程都是出于等待状态 Thread提供的常用方法 static Thread currentThread();//返回当前正在执行的线程的引用对象 String getName();//返回线程的名称 void start();//启动线程,本质当t1.start()方法的时候底层会让JVM去启动线程,我们的程序是没有资格和能力去真正的把一个线程给启动起来的. CPU调度JVM进程-调用t1线程. void setName(String name);//给线程设置名称 void setPriority(int n);//设置线程的优先级,数字[1~10].注意点:数字越大,优先级越高.但是并不是优先级越高的线程就一定会优先执行.只是希望它先执行.最终还是要cpu的. void setDaemon(boolean on);//设置成true,这个线程成为了一个后台守护线程了. synchronized关键字 Java语言的关键字， 可用来给对象和方法或者代码块加锁 当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候，同一时刻最多只有一个线程执行这段代码 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 非公平锁 如果同步代码块中出现了异常,那么仍然还是会自动释放锁资源的 基础方法 在java中,每个对象有且仅有一个同步锁,并且同步锁是依赖于对象存在的.当我们调用对象的synchronized修饰的同步方法时候,就是获取了该对象的同步锁. 修饰普通方法 - 对象锁 - 不同的对象拥有独立的”一把锁”,每个对象的”锁”是不冲突的 - “自助餐” **修饰静态方法 - “类锁” - **作用于这个类下的所有的对象 - 这个类实例化出来的所有的对象竞争的是”同一把锁” - 类锁 - “一个桌子上” 修饰代码块synchronized(this) - 对象锁 修饰代码块(XXX.class) - “类锁” synchronized特性 原子性 123456所谓的原子性代表一个操作或者多个操作,要么执行全部并且执行的过程中不能被任何因素打断.要么就不执行.比如i++,i+=2,i=i+1;这些操作都不是原子操作[读取,计算,赋值].这三个步骤不是原子性 - 三个步骤中的任何一个步骤在执行的过程.其他都可能去打断它.int x = 10;//原子操作特殊的 - 了解即可double x = 3.0d或者long x1 = 20L - 不具备原子性的. 可见性 原因:遇到synchronized之后,清空本地工作内存,重新从主存去拷贝最新的值 1多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是可见的 有序性 在同一个时刻,只能由一个线程进入. 可重入性 当一个线程申请到锁资源并且执行完毕之后[释放],仍然还有机会再去继续申请曾经申请过的锁资源. JMM JMM就是Java内存模型(java memory model - 不是JVM内存模型 Java内存模型规定所有的变量都存储在主内存中，包括实例变量[类中的非静态属性]，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。 不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。 描述i++过程 - 多线程安全问题 前提: 线程是不能够操作对主存中的数据进行直接的操作的,必须是在本地的工作内存中去完成的.完成之后,刷回主存的 线程之间是隔离的.每个线程去执行方法的时候,都会在本地开辟一块区域[栈帧 - 线程栈],每个线程在本地工作内存中 对资源的修改,那么这个资源的信息,状态对其他线程都是不可见的. add方法没有使用synchronized进行修饰的流程 脏数据 - 本地工作内存中的变量的数据和主存中的变量的数据的值已经不一样,违背了”JMM中的缓存一致性”的原则. 1234567891011121314151617i++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=0) =&gt; T1 `T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=0)` =&gt; T0 `T0线程直接进行了计算,赋值,重新刷回到主存[i=1]` =&gt; T0 `T0线程刷回i到主存之后,此时主存的i=1,T0线程让出cpu执行权` ②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i =&gt; T1 `T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本` `所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是0]` `T1线程i = i + 1,刷回到主存[i=1]` `因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存] =&gt; T1 [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中 获取变量的副本,重复执行①②③) 隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的 看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了1次的结果. 如何解决问题 使用synchronized对i++所在的方法进行修饰. 当某个对象调用add方法,得到锁资源的时候,会先清空本地工作内存.清空的目的是为了让后面的操作重新从主存中拷贝最新的值. 123public synchronized void add()&#123; i++;&#125; 因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻,只能由一个线程[获得锁资源的]进去执行 [读取,计算,赋值] - 三个步骤中.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞. 当正在执行的线程释放锁资源之前,它会将本地工作内存中的改变刷回到主存. 什么时候工作内存中的改变会同步到主存中单线程 当前的单线程执行方法结束的时候 ###多线程 线程释放锁资源的时候 线程切换 分析可见性代码先写再读 读线程为什么可以终止循环. 1234567891011 //如果先写后读t1.start(); //x=5//此处的睡一秒,已经足够让我们的写线程把x=5的最终结果刷回到主存了呀try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t2.start();//发现x变成了5 先读再写 多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是不可见的 12345678910 //如果先读后写t2.start();//读try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t1.start();//写 synchronized深入 特点 - 对象重新获得锁资源的时候,会先清空本地工作内存.强制从主存中去拷贝已经更新的变量. 12345678910111213141516先读再写,仅仅是在循环体中添加了一行代码 public void readX()&#123; //写线程过了许久之后,x=5的改变刷回到主存 //但是读线程在执行循环 - 循环体中出现了同步代码块 - 遇到synchronized //一旦遇到synchronized - 尝试去获取锁资源 - 会清空本地工作内存[把x清空掉了] //继续循环又会使用到x,由于本地工作内存已经清空了呀,所以读线程只能到主存中去强制再去拷贝一份x的变量到本地工作内存 //拿到的肯定是写线程已经更新之后的那个值x=5 while(x!=5)&#123; // System.out.println();//增加的代码 - read线程跳出了循环 - 发现了新的x,重新拷贝最新的x &#125; if(x==5) &#123; System.out.println(&quot;-----stopped---&quot;); &#125;&#125; 原因 1234567891011121314System.out.println()这个println方法的内部底层是 - 同步代码块 - synchronizedprivate void newLine() &#123; try &#123; synchronized (this) &#123; //... &#125; &#125; catch (InterruptedIOException x) &#123; Thread.currentThread().interrupt(); &#125; catch (IOException x) &#123; trouble = true; &#125;&#125; 如何保证可见性 - 解决方案 使用synchronized来保证可见性 使用volatile来修饰实例变量 作用1:强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去. 作用2:禁止指令重排的 - 单例 12345678910Student s = new Student();指令重排 - JVM指令优化之后①给对象分配空间②空间地址立即给s,s保存到栈③对象的初始化 volatile Student s = new Student();//禁止指令重排①给对象分配空间③对象的初始化②空间地址立即给s,s保存到栈 volatile关键字的作用 保证可见性 volatile是不会造成阻塞的 禁止指令重排 不能保证原子性 123456789101112131415161718192021222324volatile int i = 0;//i对于俩个线程而言都是可见的.主存中一旦改变了.另外一个线程肯定就能够&quot;看到&quot; - 自己会强制再去重新拷贝 //一份到本地缓存中 @Overridepublic void run()&#123; add();&#125; public void add()&#123; i++;&#125; t1.start();t2.start(); //诱导 - //强制让程序遵守&quot;缓存一致性&quot;协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去. //最终的i出来的结果&lt;200000 -&gt; 不能保证原子性 //t1执行到最后一步,在自己的工作内存中已经计算结束了 ,i已经自增完毕,i=1&lt;---其他线程介入了----------&gt;但是还没有来得及刷回到主存. t0线程直接计算完,i=1,刷回到主存,结束 但是t1已经对i操作已经结束了,t1的内部已经不会再去操作i 只剩下最后一个动作-&gt;i=1也会刷回到主存中 volatile和synchronized区别 volatile只能作用于变量，而synchronized可以作用于变量、方法和代码块 多线程访问volatile不会发生阻塞，而synchronized关键字可能发生阻塞。 volatile能够保证数据的可见性，就是在多个线程之间是可见的，不能保证原子性，而synchronized关键字都可以保证。 volatile关键字主要解决的是多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性。 volatile是可以禁止jvm指令重排的,但是synchronized是不能的. synchronized的底层原理 了解即可 每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。 进程和线程区别 线程是存在于进程内部的.一个进程内部可以拥有多个线程的. 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 进程与进程之间是独立的. 同一个进程内部的多个线程是可以共享进程资源的. 123比如:没有国[进程]就没有家[线程] 家[进程] - 拥有多个家庭成员的[线程] 资源拥有：同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。 -进程重量级的单位(创建,切换,销毁 - 费时) *-**线程轻量级的单位(*创建,切换,销毁 - 比较高) 线程是处理器调度的基本单位，但是进程不是。 程序在执行过程中分配和管理资源的基本单位 - 系统是把资源[内存]分给给进程,这个进程内部的线程才会去共享进程得到的这些资源. 两者均可并发执行。 一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程资源分配给进程，同一进程中所有线程共享该进程的所有资源。 线程状态 - 线程生命周期 简介:线程的生命周期. New：新建状态/瞬态，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread() Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()此线程立即就会执行 Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。 Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态 Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期 （1）就绪状态是进入到运行状态的唯一入口（2）线程想要进入到运行状态执行，首先必须处于就绪状态中（3）根据阻塞产生的原因，阻塞状态又可以分为三种： 【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态 【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态 【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入. 作业-synchronized Account(id,accno,balance=100) - “临界资源” - “多个线程需要竞争的共享 - 多个线程需要操作的同一个对象” 写一个线程类 - 同步方法[取钱-10] - 一定是只能在某个时刻只能由一个线程进去执行 创建俩个线程对象 - 老公和老婆 -&gt; 调用同步取钱的方法 无论哪个线程在执行 - 100 - 90 - 80 - …. 0 效果 12345678老公正在取钱....余额为:90老公正在取钱....余额为:80老公正在取钱....余额为:70老婆正在取钱....余额为:60老公正在取钱....余额为:50....... 0 守护线程 GC - 运行在后台的 - 负责回收垃圾对象的. 核心:线程结束的时候不需要关心后台的守护线程是否也运行结束.线程是不会等后台的守护线程全部运行结束才结束. 当后台只有守护线程在执行的时候,就可以认为线程可以结束了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package tech.aistar.day15.thread02;/** * 本类用来演示: 后台的守护线程 * * @author: success * @date: 2021/8/11 9:03 上午 */public class DaemonDemo &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); Thread t2 = new T2(); //将打印数字的线程 - 设置成后台守护线程 //如果后台只剩下守护线程在执行 - 可以结束了. //不需要等待所有的守护线程运行结束才结束. t2.setDaemon(true); //如果t1和t2都不是守护线程 - main线程一定是等待俩个线程全部执行完之后,才会结束 t1.start(); t2.start(); &#125;&#125;//业务线程class T1 extends Thread&#123; @Override public void run() &#123; for (int i = 65; i &lt;=90 ; i++) &#123; System.out.println((char)i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class T2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Lock - 同步代码简介:它是一个接口,下面有很多实现类,笔试题lock和synchronized的区别! lock是接口,synchronized它是一个关键字 lock锁是一个显示锁(手动申请锁,手动释放锁),synchronized隐式锁(自动申请/释放锁) lock手动申请锁**(对象锁)** lock是锁代码块 lock出现异常的时候,是不会主动释放资源的. demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package tech.aistar.day15.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 本类用来演示: Lock同步代码 - 同步代码块 * * 申请的是对象锁 - 相同的对象才会去竞争一把锁. * * 如果出现了异常 - 是不会主动释放锁的. * * @author: success * @date: 2021/8/11 1:32 下午 */public class LockHelloDemo &#123; //构建lock对象 - 接口 Lock lock = new ReentrantLock(); public void add()&#123; try &#123; //begin.. //多个线程就会去竞争&quot;锁资源&quot; lock.lock();//手动申请&quot;锁资源&quot; - 显示锁 //在某个时刻只能由一个线程进入去执行... //同步代码开始 System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; //sleep如果出现同步代码中,它并不会释放锁资源,只会让出cpu时间片段 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); //end... //同步代码结束 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock();//手动释放锁 &#125; &#125; public static void main(String[] args) &#123; LockHelloDemo hello = new LockHelloDemo(); //1. 创建第一个线程对象 Thread t1 = new Thread(()-&gt;&#123; hello.add(); &#125;); Thread t2 = new Thread(()-&gt;&#123; hello.add(); &#125;); t1.setName(&quot;one&quot;); t2.setName(&quot;two&quot;); t1.start(); t2.start(); &#125;&#125; 面试题-synchronized和Lock有什么区别？ synchronized和lock都是属于独占锁. 实现层面不一样。synchronized 是 Java 关键字，JVM层面 实现加锁和释放锁；Lock 是一个接口，在代码层面实现加锁和释放锁 是否自动释放锁。synchronized 在线程代码执行完或出现异常时自动释放锁；Lock 不会自动释放锁，需要再 finally {} 代码块显式地中释放锁 是否一直等待。synchronized 会导致线程拿不到锁一直等待；Lock 可以设置尝试获取锁或者获取锁失败一定时间超时 1234567Lock接口中提供的方法1. void lock();//手动上锁2. boolean tryLock();//如果获取锁失败 - 直接返回false,如果获取锁成功,返回true if(lock.tryLock())&#123; &#125;3. boolean tryLock(long time, TimeUnit unit);//如果在尝试获取锁的过程中等待超过了time,那么就会导致获取锁失败 获取锁成功是否可知。synchronized 无法得知是否获取锁成功；Lock 可以通过 tryLock 获得加锁是否成功 功能复杂性。synchronized 加锁可重入、不可中断、非公平；Lock 可重入、可中断、可公平和不公平、细分读写锁提高效率 读锁 - java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock - 共享锁 - 允许多个线程去读. 写锁 - java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock - 互斥锁 - 一次只能由一个线程去写. 123不可中断synchronized - A线程竞争到锁资源 - 顺利进入同步代码块执行 - 只要A资源不释放这个锁资源.B线程只能在外面等待. 可中断Lock -&gt; A线程顺利执行同步代码,B线程如果tryLock方法话,那么B线程不断尝试获取锁资源.如果设置了超时等待时间.B线程等太久.已经超过了设置的时间.B线程将不会再傻乎乎继续等待下去[可中断],B线程就有可能去干别的事情了. 锁 乐观锁,悲观锁[synchronized] - 数据库的时候 互斥锁 - synchronized和lock 读写锁 锁升级 锁粗化 偏向锁 分布式锁 线程的通信 - 重点 同程公司笔试题 - 循环打印abc ABC 123 abc ABC 123 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 保证必须按照上面的顺序进行输出 - synchronized - wait和notify/notifyAll不能解决原因是notify随机唤醒,notifyAll唤醒所有 使用Lock中的同步队列 - 解决方案 - 唤醒指定的等待队列上的某个线程. Lock接口中提供的构建等待队列的方法 - Condition newCondition(); Contion提供的关于线程通信的俩个方法 - 出现在同步代码内部 - lock()-&gt;unlock()内部 void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的 void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒 demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package tech.aistar.day15.lock; import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock; /** * 本类用来演示: * * 同程公司笔试题 - 循环打印abc ABC 123 abc ABC 123 * * 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 * * 使用Lock中的同步队列 - 解决方案 - **唤醒指定的等待队列上的某个线程.** * * @author: success * @date: 2021/8/11 2:29 下午 */public class LockTongxinDemo &#123; private Lock lock = new ReentrantLock(); //有几个线程,就构建几个队列 //打印小写字母的 private Condition c1 = lock.newCondition(); //打印大写字母的 private Condition c2 = lock.newCondition(); //打印数字的 private Condition c3 = lock.newCondition(); //定义了一个标记 private int count = 0; //count = 0,打印小写字母的执行 //count = 1,打印大写字母的执行 //count = 2,打印数字的执行 //1. void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的 //2. void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒 public void printLower()&#123; while(true)&#123; try &#123; lock.lock(); if(count!=0)&#123; //等待 //一开始,第一次count=0,说明打印小写字母的线程正常执行 c1.await(); &#125; System.out.print(&quot;abc&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count=1; c2.signal();//唤醒打印大写字母的线程 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void printUpper()&#123; while(true)&#123; try &#123; lock.lock(); if(count!=1)&#123; try &#123; c2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;ABC&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count=2; c3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void printNum()&#123; while(true)&#123; try &#123; lock.lock(); if(count!=2)&#123; c3.await(); &#125; System.out.print(123); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 0; c1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; LockTongxinDemo demo = new LockTongxinDemo(); Thread t1 = new Thread(()-&gt;&#123; demo.printLower(); &#125;); Thread t2 = new Thread(()-&gt;&#123; demo.printUpper(); &#125;); Thread t3 = new Thread(()-&gt;&#123; demo.printNum(); &#125;); t1.start(); t2.start(); t3.start(); &#125;&#125; 面试题 - 常用方法区别 wait方法和sleep方法的区别? a. wait方法一定是出现在synchronized同步代码内部的.[sleep是可以放在同步/不同步的代码内部的] b. wait方法,执行这个方法的线程就会释放锁,释放cpu.但是sleep是不会释放锁的.只是释放了cpu - 核心的区别 c. sleep - 线程会自动进入到阻塞状态[其他阻塞状态],一旦睡眠时间结束.会自动从阻塞状态恢复到可就绪态 - 等到cpu到来 - 运行态. ​ wait - 线程会自动进入到等待阻塞状态,自己不会主动”醒过来”,必须是其他线程调用notify或者notifyAll,进入到锁定状态[再次尝试 去获取锁] sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。 yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package tech.aistar.day15.thread02; /** * 本类用来演示: * join：一种特殊的wait[等待]，当前运行线程[mother]调用另一个线程[son]的join方法， * 当前线程[mother]进入阻塞状态直到另一个线程[son]运行结束等待该线程终止。 * 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。 * * @author: success * @date: 2021/8/11 9:21 上午 */public class JoinDemo &#123; public static void main(String[] args) &#123; Thread mother = new Mother(); mother.start(); &#125;&#125; class Mother extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;妈妈正在做饭...&quot;); System.out.println(&quot;妈妈发现酱油了...&quot;); System.out.println(&quot;妈妈让熊孩子打酱油...&quot;); //应该是希望儿子的线程介入进来了吧... Thread son = new Son(); son.start();//启动儿子线程 //希望妈妈的线程先暂停一下,然后等儿子的线程跑完,妈妈的线程才继续跑. try &#123; son.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //期望的是这条语句一定是出现在最后的... System.out.println(&quot;妈妈可以继续做饭了~~~&quot;); &#125;&#125; class Son extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;熊孩子接到任务...屁颠颠打酱油去了...&quot;); for (int i = 5; i &gt;=0; i--) &#123; System.out.println(&quot;熊孩子还有&quot;+i+&quot;分钟就回来了...&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;熊孩子把酱油打回来了~~~&quot;); &#125;&#125; 线程之间的通信 wait：Object类的方法(notify()、notifyAll())，必须放在循环体和同步代码块中，执行该方法的线程会释放锁， 进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 生产者和消费者 单个生产者和单个消费者 生产者线程 - 负责生产产品-box[把产品放入到box] 消费者线程 - 负责消费产品-box[从box中去获取产品] 通信的流程 俩条线程并发执行 - 调用的是不同的方法 假设消费者线程先执行 - 直接从box中去获取产品.但是此时此刻box中尚无产品. 消费者线程就需要调用wait方法 - 自己会释放锁资源,消费者线程进入到线程等待池[意味着当前的线程会进入到等待阻塞的状态] -getter方法 假设生产者线程 - setter方法 先执行了.发现box中没有产品的,顺利放入一个产品到box中的.但是放完之后.生产者还是会继续执行.继续执行的时候又会调用 setter方法.这个时候,不能允许生产者线程连续再放 - 就得调用生产者线程的wait方法,同时还需要唤醒消费者线程过来消费. 消费者线程一旦消费成功,它还是会继续执行自己的getter方法.发现box中没有了.回到第2个步骤 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package tech.aistar.day15.thread02;/** * 本类用来演示: 线程之间的通信 - 生产者和消费者 * * 效果是:必须是生产者线程先进去执行. * 放1个 * 取1个 * 放2个 * 取2个 * 放3个 * 取3个 * * 一次性放,一次性取. * 不能连续出现俩次放/取. * * @author: success * @date: 2021/8/11 9:55 上午 */public class ThreadTongXinDemo &#123; public static void main(String[] args) &#123; //典型的不共享代码,但是共享资源. Box box = new Box(); Thread product = new ProductThread(box); Thread customer = new CustomerThread(box); product.setName(&quot;生产者&quot;); customer.setName(&quot;消费者&quot;); product.start(); customer.start(); &#125;&#125;//定义一个临界资源class Box&#123; private int content;//产品 //假设的是是要调用getter方法 - 消费了 - box中没有东西了. //如果box中有东西 - 刚生产完,flag为true //如果box中没有东西 - 刚消费完 - flag为false private boolean flag;//标志 //生产者线程去调用的 //线程通信的方法wait,notify,notifyAll方法必须存在于循环体的同步方法中. public synchronized void setContent(int content) &#123; if(flag)&#123;//box中是有东西的 //一旦调用wait方法之后,线程会释放锁.并且会自动进入到线程等待池中 //进入到一个阻塞的状态. //它自己是不会主动被唤醒的.必须由其他线程调用notify或者notifyAll才能够 //notify - 随机唤醒线程等待池中的一个线程 //notifyAll - 唤醒所有的等待的线程 try &#123; wait();//为了防止生产者线程连续执行.. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //生产者顺利去执行. //设置flag flag = true; this.content = content; //通知一下消费者来消费.消费者很有可能已经处于等待阻塞的状态. notifyAll();//唤醒全部等待阻塞的线程 &#125; //消费者线程去调用的 public synchronized int getContent() &#123; if(!flag)&#123;//1. 保证消费者第一次执行,肯定会进来 try &#123; wait();//释放锁,自己是不会主动&quot;醒过来的&quot; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = false;//消费完了... //唤醒一下生产者 notifyAll(); return content; &#125;&#125;//定义生产者线程class ProductThread extends Thread&#123; private Box box; private int i = 0;//产品 public ProductThread(Box box)&#123; this.box = box; &#125; @Override public void run() &#123; //不断去生产 while(true)&#123; System.out.println(Thread.currentThread().getName()+&quot;=&gt;放&quot;+(++i)+&quot;个&quot;); box.setContent(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//定义一个消费者线程class CustomerThread extends Thread&#123; private Box box; public CustomerThread(Box box)&#123; this.box = box; &#125; @Override public void run() &#123; while(true)&#123; System.out.println(Thread.currentThread().getName()+&quot;-&gt;取&quot;+box.getContent()+&quot;个&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 死锁 - 笔试题“哲学家吃饭的问题” 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程. 死锁产生的条件1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 只要打破四个条件的一个,就可以防止死锁. 死锁是不可避免,但是需要写程序的破坏四个条件中的一个. 静态域容易产生死锁. 四种常见的线程池 - 必考线程池的返回值ExecutorService简介 ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程 Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 作业 Lock和Condition - 生产者和消费者的demo 编写俩个线程,一个线程用来计算2100000之间的素数的个数.第二个线程用来计算1000000200000之间的素数的个数 将俩个线程计算的结果相加. 面试题 - 请你谈谈java.util.concurrent下的api的认识! 主题 - 围绕线程池去问题了. 1234import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day14","slug":"day14","date":"2021-07-28T10:02:10.000Z","updated":"2022-01-07T09:03:22.030Z","comments":true,"path":"2021/07/28/day14/","link":"","permalink":"http://example.com/2021/07/28/day14/","excerpt":"","text":"泛型Generic定义 Java在1.5之后加入了泛型的概念。泛型，即“参数化类型”。 泛型的本质是为了参数化类型(将类型参数化传递)（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数， 这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型只能是对象类型,比如User,Student,内置对象类型比如String,Integer[一定是包装类型] 1234567891011//jdk5.0之前List list = new ArrayList();//集合中可以添加任意类型的数据//jdk5.0开始~jdk7.0之前//类型安全的集合框架List&lt;Integer&gt; list - new ArrayList&lt;Integer&gt;();//在编译期间确定了集合中添加的数据的类型,只能是Integer类型.//jdk7.0开始//结论:泛型只有编译期间的概念,在运行期间将会被擦除.List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 泛型符号 E 元素 K,V - 键值对 N - 数字 T - 类型 ? - 通配符 为何要有泛型呢 对别一下没有泛型,会导致什么结果. 加入了泛型之后,可以保证代码的健壮性 加入了泛型之后,取值的时候,不需要进行强制类型的转换 加入了泛型之后,代码会变得更加简洁 123456789101112131415161718192021222324252627282930313233343536package tech.aistar.day14;import java.util.ArrayList;import java.util.List;/** * 本类用来演示: 泛型的好处 * * @author: success * @date: 2021/8/7 9:05 上午 */public class GenericDemo &#123; public static void main(String[] args) &#123; //jdk5.0之前 List list = new ArrayList();//集合中可以添加任意类型的数据 list.add(10);//10-&gt;java.lang.Integer list.add(&quot;ok&quot;);//字符串 //没有泛型的时候,获取集合中的元素 - 统计的返回类型都是Object类型 //需要进行强制类型的转换.转换的过程中有可能会抛出java.lang.ClassCastException类型转换失败异常 //在类型转换之前,建议先进行类型的判断,使用instanceof关键字 String ok = (String) list.get(1); System.out.println(ok); //jdk7.0开始 //一旦指定了泛型,add方法中的E成了String类型,返回类型也是String类型 List&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;ok&quot;); strList.add(&quot;java&quot;); //根据下标获取 - 不需要进行类型的强制转换了.自动能够识别出返回类型就是你指定的那个泛型. String result = strList.get(1); System.out.println(result); &#125;&#125; 泛型只有编译期间的概念,在运行期间将会被擦除. 结论:泛型是没有多态的 泛型只有编译期间的概念 - 泛型仅仅是在编译期间是有效的 在编译期间一旦确定了泛型,那么在编译期间就只能向这个容器中添加对应类型的数据. 否则编译报错. 运行期间将会被擦除 - 泛型是不存在运行时类型的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package tech.aistar.day14; import tech.aistar.day05.User; import java.util.ArrayList;import java.util.List; /** * 本类用来演示: 泛型只有编译期间的概念,在运行期间将会被擦除. * * @author: success * @date: 2021/8/7 9:16 上午 */public class GenericRuntimeDemo &#123; public static void main(String[] args) &#123; //多态的语法 - 多态的应用 //面向父类编程/面向接口编程 //编译时类型 对象名 = new 运行时类型(); //父类 对象 = new 子类(); //接口 对象 = new 实现类(); //java.lang.Integer extends java.lang.Number //java.lang.Long extends java.lang.Number Number n1 = new Integer(10); Number n2 = new Long(20L); //jdk5.0~jdk7.0之前 List&lt;Integer&gt; list01 = new ArrayList&lt;Integer&gt;(); //思考 - 编译是错误的 //结论:泛型是没有多态的 //原因:泛型只有编译期间的概念,在运行期间将会被擦除. //List&lt;Number&gt; numberList = new ArrayList&lt;Integer&gt;(); List&lt;Long&gt; list02 = new ArrayList&lt;Long&gt;(); //获取对象的运行时类型 //忘记了 - java.lang.Object中的toString方法 getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode()); //Class实例 - 别名:对象的运行时类型 Class&lt;?&gt; c1 = list01.getClass(); Class&lt;?&gt; c2 = list02.getClass(); System.out.println(c1 == c2);//true //结论:获取运行时类型始终都是ArrayList,和&lt;Integer&gt;和&lt;Long&gt;是无关的 //所以泛型仅仅是在编译期间有效,但是在运行期间是无效的[将会被擦除,将会失效] System.out.println(c1);//class java.util.ArrayList System.out.println(c2);//class java.util.ArrayList //结论:一个类无论被实例化多少次,它在JVM中的Class对象/实例永远只有1个// User user1 = new User();// System.out.println(user1.getClass());//class tech.aistar.day05.User//// User user2 = new User();// System.out.println(user2.getClass());//class tech.aistar.day05.User//// System.out.println(user1.getClass() == user2.getClass());//true &#125;&#125; 泛型通配符 **? extends T - 只能是T类型或者T类型的子类 **- 指定类型的上限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day14;import java.util.*;/** * 本类用来演示: 问号的通配符 * * @author: success * @date: 2021/8/7 9:45 上午 */public class WildCardDemo &#123; public static void main(String[] args) &#123; //只能添加添加null// List&lt;?&gt; list = new ArrayList&lt;&gt;();// //list.add(10);//error// //list.add(&quot;ok&quot;);//error// list.add(null);//ok List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); intList.add(10); intList.add(20); intList.add(30); List&lt;Long&gt; longList = new ArrayList&lt;&gt;(); longList.add(100L); longList.add(200L); longList.add(300L); //能否定义一个方法,能够打印上面俩个集合 printList(intList); System.out.println(&quot;=====&quot;); printList(longList); &#125; //泛型是不存在多态的. //假设认为是List&lt;Number&gt; list = new ArrayList&lt;Long&gt;();//error //Integer和Long都是extends Number //? extends T - 只能是T类型或者T类型的子类 - 指定类型的上限 //? super T - 只能是T类型或者T类型的父类 - 指定类型的下限 public static void printList(List&lt;? extends Number&gt; list)&#123; //推荐使用集合的迭代器 //获取集合的迭代器对象 Iterator&lt;? extends Number&gt; iter = list.iterator(); while(iter.hasNext())&#123; //Integer,Long -&gt; extends-&gt;Number-&gt;多态的语法 Number result = iter.next(); System.out.println(result); &#125; &#125;&#125; ? super T - 只能是T类型或者T类型的父类 - 指定类型的下限 泛型类 定义类的时候,给定一个泛型,真正使用的时候,再确定具体的类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package tech.aistar.day14;/** * 本类用来演示: 泛型类 * * @author: success * @date: 2021/8/7 10:11 上午 */public class GenericClassDemo&lt;T&gt; &#123; //定义属性 private T type; public GenericClassDemo() &#123; &#125; //将类型参数化传递 public GenericClassDemo(T type) &#123; this.type = type; &#125; //泛型方法 public T getType() &#123; return type; &#125; //将类型参数化传递 public void setType(T type) &#123; this.type = type; &#125; public static void main(String[] args) &#123; //测试泛型类 GenericClassDemo&lt;String&gt; c1 = new GenericClassDemo&lt;&gt;(&quot;python&quot;); c1.setType(&quot;java&quot;); String result = c1.getType(); System.out.println(&quot;result:&quot;+result); System.out.println(&quot;===华丽丽的分割线===&quot;); GenericClassDemo&lt;Integer&gt; c2 = new GenericClassDemo&lt;&gt;(); c2.setType(10); System.out.println(c2.getType()); &#125;&#125; 泛型方法 如果泛型加在类上面,对整个类内部的泛型的地方都会有影响 可能某个类中就那么几个方法需要使用到泛型,没有必要定义泛型类,只需要定义泛型方法即可. 如果若干个很多个方法都使用到了泛型,有必要定义一个泛型类. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package tech.aistar.day14;/** * 本类用来演示: 泛型方法 * * @author: success * @date: 2021/8/7 10:17 上午 */public class GenericMethodDemo &#123; //非静态方法 - 无返回类型 public &lt;T&gt; void test01(T t)&#123; System.out.println(&quot;test01...&quot;+t); &#125; //非静态方法 - 带返回类型 public &lt;E&gt; E test02(E e)&#123; System.out.println(&quot;e:&quot;+e); return e; &#125; //静态方法 public static &lt;N&gt; N test03(N n)&#123; System.out.println(&quot;n:&quot;+n); return n; &#125; public static void main(String[] args) &#123; GenericMethodDemo m = new GenericMethodDemo(); //如何确定到方法的参数T //JVM根据传入的方法的实参 - 拿到这个实参的类型 -&gt; 方法的参数T m.test01(10);//Integer m.test01(&quot;ok&quot;);//ok //调用带有返回类型 String ok = m.test02(&quot;ok&quot;); System.out.println(ok); Integer t = m.test02(100); System.out.println(t); System.out.println(&quot;====&quot;); //泛型是类型安全的 Integer s = GenericMethodDemo.test03(12); System.out.println(s); &#125;&#125; 泛型应用1234567ObjectInputStream/ObjectOuputStream - 操作对象类型的字节文件输入流和对象类型的文件字节输出流 Object in.readObject()/out.writeObject(Object obj);Jdk没有对readObject方法进行优化,每次调用完之后,进行强制类型的转换操作的. 思考 - 无论是保存/读取User对象或者Book对象 - 用一个方法去实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package tech.aistar.util;import tech.aistar.day13.Book;import tech.aistar.day14.Product;import java.io.*;import java.util.ArrayList;import java.util.List;/** * 本类用来演示: IO流的工具类 * * @author: success * @date: 2021/8/7 10:59 上午 */public class IOUtil &#123; //提供一个方法可以保存任意对象 public static &lt;T&gt; void writeList(List&lt;T&gt; list,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path)))&#123; out.writeObject(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //提供一个方法可以读取文件中的任意对象 //语法如果定义成了一个泛型类,并且是静态方法的话,那么必须要把这个静态方法也设置成泛型方法 //如果是定义成了一个泛型类,但是是普通方法的话,那么这个普通方法是不需要设置成泛型方法的 public static &lt;T&gt; List&lt;T&gt; readList(String path)&#123; List&lt;T&gt; list = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path)))&#123; list = (List&lt;T&gt;) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return list; &#125;&#125;class IOUtilTest&#123; public static void main(String[] args) &#123; Book b1 = new Book(1,&quot;1001&quot;,&quot;python&quot;,100.0d); Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,100.0d); List&lt;Book&gt; books = new ArrayList&lt;&gt;(); books.add(b1); books.add(b2); String path = &quot;src/tech/aistar/util/content.txt&quot;; //写入 //IOUtil.writeList(books,path); //读// List&lt;Book&gt; list = IOUtil.readList(path);// if(null!=list &amp;&amp; list.size()&gt;0)&#123;// for (Book book : list) &#123;// System.out.println(book);// &#125;// &#125; System.out.println(&quot;======&quot;); Product p1 = new Product(1,&quot;macbook&quot;); Product p2 = new Product(2,&quot;linux&quot;); List&lt;Product&gt; products = new ArrayList&lt;&gt;(); products.add(p1); products.add(p2); //IOUtil.writeList(products,path); List&lt;Product&gt; ps = IOUtil.readList(path); if(null!=ps &amp;&amp; ps.size()&gt;0)&#123; for (Product p : ps) &#123; System.out.println(p); &#125; &#125; &#125;&#125; 泛型类的继承 子类不指定具体的类型 子类指定具体的类型 demo1234567891011121314151617181920212223package tech.aistar.day14;/** * 本类用来演示: 泛型类的继承 * * @author: success * @date: 2021/8/9 8:34 上午 */public class GenericExtendsDemo &#123;&#125;//泛型父类class Sup&lt;T&gt;&#123; &#125;//子类继承父类的时候,没有指定具体的类型class Sub&lt;T&gt; extends Sup&lt;T&gt;&#123; &#125;//子类继承父类的时候,指定了具体的类型class Sub01&lt;Product&gt; extends Sup&lt;Product&gt;&#123; &#125; 泛型的具体应用 了解一下即可 场景:在接口的制定中.很多接口具有相同的或者类似的功能.比如 1234567891011121314151617181920//dao层接口 - data access object - 数据访问对象层 - 数据持久层//这一层专门和数据库[crud增删改查操作][文件_IO流操作]打交道//教师的业务接口public interface ITeacherDao&#123; //保存教师 void save(Teacher teacher);&#125;//学生的业务接口public interface IStudentDao&#123; // 保存学生 void save(Student student);&#125;//再去写俩个具体的实现类分别是TeacherDaoImpl.java以及StudentDaoImpl.java//这俩个实现类中 - 具体的代码,现阶段知识点 - 把单个java对象保存到文件中[IO流技术].//未来 - 肯定是要把java对象保存到db中 - 持久化的操作[java内存中的对象保存到DB中]//关于dao层 - java如何操作数据库 - 原生技术jdbc,dao层框架 - Hibernate框架以及mybatis框架//比如现在选取的是所谓的Hibernate框架 Hibernate框架来把java的内存对象保存到DB中 123session.beginTransaction();//开启一个事务session.save(user);//具体的调用的是这个框架中的保存方法session.getTransaction().commit();//提交一个事务 TeacherDaoImpl.java伪代码 12345678public class TeacherDaoImpl implements ITeacherDao&#123; @Override public void save(Teacher teacher)&#123; session.beginTransaction();//开启一个事务 session.save(teacher);//具体的调用的是这个框架中的保存方法 session.getTransaction().commit();//提交一个事务 &#125;&#125; StudentDaoImpl.java 12345678public class StudentDaoImpl implements IStudentDao&#123; @Override public void save(Student student)&#123; session.beginTransaction();//开启一个事务 session.save(student);//具体的调用的是这个框架中的保存方法 session.getTransaction().commit();//提交一个事务 &#125;&#125; 发现在未来使用框架的时候,会发现很多步骤都是重复的.可能就涉及到具体的对象那一行的代码才会不一样而已 1session.save(具体的java对象); 考虑抽象出一个顶级的业务接口出来-IBaseDao&lt;T&gt; 1234567891011/** * 本类用来演示: 顶级的业务接口 * * @author: success * @date: 2021/8/9 8:50 上午 */public interface IBaseDao&lt;T&gt; &#123; //顶级的业务接口中应该存储的就是各个子接口中共性的方法 //这些方法都有共同点 - 大部分的代码是一样的,仅仅是操作的对象不一样而已. void save(T t);&#125; 制定顶级的接口的实现类BaseDaoImpl.java 123456789101112131415161718package tech.aistar.day14.app.dao;/** * 本类用来演示: 顶级接口的实现类 * * @author: success * @date: 2021/8/9 8:53 上午 */public class BaseDaoImpl&lt;T&gt; implements IBaseDao&lt;T&gt; &#123; @Override public void save(T t) &#123;// session.beginTransaction();//开启一个事务// session.save(t);//具体的调用的是这个框架中的保存方法// session.getTransaction().commit();//提交一个事务 System.out.println(t); &#125;&#125; IStudentDao.java继承了顶级的业务接口 12345678910111213package tech.aistar.day14.app.dao;import tech.aistar.day14.app.Student;/** * 本类用来演示: 具体的业务接口去继承这个顶级的业务接口 * * @author: success * @date: 2021/8/9 8:52 上午 */public interface IStudentDao extends IBaseDao&lt;Student&gt;&#123; void taoKe();//子接口中特有的方法&#125; ITeacherDao.java继承了顶级的业务接口 1234567891011121314package tech.aistar.day14.app.dao;import tech.aistar.day14.app.Teacher;/** * 本类用来演示: * * @author: success * @date: 2021/8/9 8:52 上午 */public interface ITeacherDao extends IBaseDao&lt;Teacher&gt;&#123; void buKe();//子接口中特有的方法&#125; 俩个具体的实现类 - 需要继承顶级的BaseDaoImpl.java - save方法已经实现好了.同时还需要各自实现自己的接口 123456789101112131415161718package tech.aistar.day14.app.dao;import tech.aistar.day14.app.Student;/** * 本类用来演示: 具体的学生接口的实现类 * * @author: success * @date: 2021/8/9 8:55 上午 *///泛型继承 - 指定了泛型类public class StudentDaoImpl extends BaseDaoImpl&lt;Student&gt; implements IStudentDao&#123; @Override public void taoKe() &#123; System.out.println(&quot;逃课...&quot;); &#125;&#125; 12345678910111213141516package tech.aistar.day14.app.dao;import tech.aistar.day14.app.Teacher;/** * 本类用来演示: * * @author: success * @date: 2021/8/9 9:02 上午 */public class TeacherDaoImpl extends BaseDaoImpl&lt;Teacher&gt; implements ITeacherDao&#123; @Override public void buKe() &#123; System.out.println(&quot;补课...&quot;); &#125;&#125; 单元测试 1234567891011121314151617181920212223package tech.aistar.day14.app.dao;import tech.aistar.day14.app.Student;import tech.aistar.day14.app.Teacher;/** * 本类用来演示: * * @author: success * @date: 2021/8/9 8:56 上午 */public class TestBase &#123; public static void main(String[] args) &#123; Student s = new Student(1,&quot;tom&quot;); IStudentDao studentDao = new StudentDaoImpl(); studentDao.save(s); Teacher teacher = new Teacher(1,&quot;仓考试&quot;); ITeacherDao teacherDao = new TeacherDaoImpl(); teacherDao.save(teacher); &#125;&#125; 枚举类型 枚举常量 - 类型安全的常量 - 公共的静态的常量[final]属性 - 不可变的 jdk5.0开始提供的,以前的作用就是用来替代常量接口的 回忆常量接口 - 管理和维护项目中所有的常量的 12345678910public interface IConsts&#123; //最全的写法 - 接口中只能出现公开的静态的常量属性 //public static final int Car = 1; //精简的写法 //public int CAR = 1; //最精简的写法 int CAR = 1;&#125; 关键字 使用enum关键字来定义一个枚举类型的 switch()中的参数类型可以是byte,short,int,char,enum,String,Byte,Short,Integer 特点 枚举常量,多个枚举常量,使用,隔开.最后一个枚举常量不需要使用逗号了. 如果最后一个枚举常量下面还有代码的话,那么需要使用分号隔开 允许存在构造 - 访问修饰符不能是公开的,protected 枚举类型是不能够被实例化的 枚举类型中可以提供普通属性 每个枚举类型默认都会自动继承java.lang.Enum&lt;E extends Enum&gt; 枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法 枚举类型不支持再去extends另外一个枚举类型 枚举类型不支持再去手动extends另外一个类 应用 如果某些属性具有固定的一些标识,就可以考虑定义成枚举类型. 比如:User实体类中维护了一个性别属性Gender[性别的枚举类型] 比如:Order实体类也会存在固定的状态 - 未付款,已付款.已下单未付款.取消订单等… 字符串-&gt;枚举常量 比如一个注册页面 用户名 tom 性别 单选按钮 男 单选按钮 女 确定按钮 未来.当点击确定按钮,后台接受到M,F - 后台接受到的数据都是字符串数据. 我们是不能够直接将这个字符串数据设置到实体类中的枚举常量属性上的. 每个自定义的枚举类型Gender.java默认都会继承java.lang.Enum&lt;E extends Enum&gt; 123public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123;&#125; 1234567891011121314151617181920212223242526272829package tech.aistar.day14.enums;/** * 本类用来演示: String-&gt;枚举类型 * * @author: success * @date: 2021/8/9 10:10 上午 */public class StringToEnumDemo &#123; public static void main(String[] args) &#123; String gender = &quot;F&quot;;//接受到页面传过来的数据 - 都是字符串类型 //字符串类型是不能够直接设置给实体类的那个枚举常量属性上的 //System.out.println(FString.class); // System.out.println(Integer.class); //Class&lt;?&gt; c = String.class; //System.out.println(c); //将字符串转换成枚举常量类型 //注意 - 字符串的值一定是和枚举常量的名称是保持一致的. //否则 - java.lang.IllegalArgumentException: // No enum constant tech.aistar.day14.enums.Gender.S Gender g = Enum.valueOf(Gender.class,gender); User user = new User(1,&quot;tom&quot;,g); System.out.println(user); &#125;&#125; 枚举单例 它是effective java作者极力推荐的写法 - 枚举实例 - 1. 枚举类型天生就是线程安全的.2. 可以防止序列化或者反射来破坏这种单例的. 单例 - 保证在整个应用程序中,某个类的具体的实例永远只有1个. 什么时候需要把类做成单例的 - 这个类是一个重量级的类[类的创建和销毁的成本比较高.] 枚举常量是类型安全的常量???12345678910111213141516171819public enum Gender&#123; F,M&#125;因为使用枚举常量 - 第一步肯定是先加载枚举类型Gender - JVM通过类加载器[java.lang.ClassLoader]来加载枚举类型protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; //使用到了synchronized关键字 synchronized (getClassLoadingLock(name)) &#123; //.... 加载类,接口,枚举类型到JVM内存 &#125; &#125;很多线程都在调用Gender.M - &gt; 都想尝试加载Gender枚举类型到JVM内存.但是由于loadClass加载的那块代码使用到了synchronized[锁]只能由一个线程进去执行,并且只会执行一次. 由于每个枚举常量F 本质 就是 public static final Gender F = new Gender();//使用到了static关键字//意味着当枚举类型一旦被加载了,枚举常量立即就会被分配空间以及初始化,并且机会只有一次.所以在整个内存中F常量也就只会存在一份.//无论在哪里被调用.无论被多少给线程调用 - 大家拿到的都是同一个/同一份那个枚举常量. 具体的代码的实现12345678910111213141516171819202122232425262728293031323334353637383940414243package tech.aistar.design.singleton.version04;import java.io.Serializable;/** * 本类用来演示: 枚举单例实现方式 * * @author: success * @date: 2021/8/9 10:45 上午 */public class Singleton04 implements Serializable &#123; private Singleton04()&#123; System.out.println(&quot;私有化构造&quot;); &#125; //内部的枚举类型 private enum SingletonEnum&#123; //枚举常量的实例 INSTANCE;//public static final SingletonEnum INSTANCE = new SingletonEnum(); //final修饰的变量要赋值 private final Singleton04 instance; //枚举类型提供一个空参构造 - 枚举类型是不能new的 SingletonEnum()&#123; instance = new Singleton04(); &#125; //提供一个普通方法 public Singleton04 getInstance()&#123; return instance; &#125; &#125; //外部类肯定是要提供一个方法,返回自己的一个唯一实例的 public static Singleton04 getInstance()&#123; return SingletonEnum.INSTANCE.getInstance(); &#125;&#125;class TestSingle04&#123; public static void main(String[] args) &#123; System.out.println(s1 == s2);//true &#125;&#125; 枚举单例写法1234567891011121314151617181920/** * 本类用来演示: 枚举单例 - 最精简的写法 - 多线程安全的写法 - 饿汉模式 只有最外层的是枚举类型 - 序列化这个枚举类型的单例,才能阻止序列化破坏单例的模式 * * @author: success * @date: 2021/8/9 11:11 上午 */public enum Singleton05 &#123; //public static final Singleton05 INSTANCE = new Singleton05(); INSTANCE; Singleton05()&#123; System.out.println(&quot;比较繁琐的操作的事情,费时费力的事情&quot;); &#125; public static Singleton05 getInstance()&#123; return INSTANCE; &#125;&#125; 对比饿汉模式的写法 123456789101112131415public class Singleton01 &#123; //2. 初始化一个变量,该变量就是该类的唯一实例[对象] private static Singleton01 instance = new Singleton01(); //1. 私有化构造 private Singleton01()&#123; //比较费时费力的代码,可能需要更多的时间 System.out.println(&quot;Singleton01...&quot;); &#125; //3. 提供一个公开的静态的方法来返回这个类的唯一实例 public static Singleton01 getInstance()&#123; return instance; &#125;&#125; 枚举单例阻止序列化的破坏 序列化单例对象s1 反序列化封装到单例对象s3 s1 == s3 ;// 仍然为true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package tech.aistar.design.singleton.version05;import tech.aistar.day14.enums.Gender;import java.io.*;/** * 本类用来演示: 枚举单例 - 最精简的写法 * * @author: success * @date: 2021/8/9 11:11 上午 */public enum Singleton05 &#123; //public static final Singleton05 INSTANCE = new Singleton05(); INSTANCE; Singleton05()&#123; System.out.println(&quot;比较繁琐的操作的事情,费时费力的事情&quot;); &#125; public static Singleton05 getInstance()&#123; return INSTANCE; &#125;&#125;class TestSingleton05&#123; public static void main(String[] args) &#123; Singleton05 s1 = Singleton05.getInstance(); Singleton05 s2 = Singleton05.getInstance(); System.out.println(s1 == s2);//true //序列化 try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;src/tech/aistar/design/ss.txt&quot;)))&#123; //对单例进行序列化操作 out.writeObject(s1); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //反序列化 try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;src/tech/aistar/design/ss.txt&quot;)))&#123; Singleton05 s3 = (Singleton05) in.readObject(); System.out.println(s1 == s3);//true &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 枚举细节 - 抽象方法 枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package tech.aistar.day14.enums;/** * 本类用来演示: 季节的枚举类型 * * @author: success * @date: 2021/8/9 1:43 下午 */public enum Season&#123; //枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法 SPRING(&quot;春天&quot;)&#123; @Override public Season next() &#123; return Season.SUMMER; &#125; &#125;, SUMMER(&quot;夏天&quot;) &#123; @Override public Season next() &#123; return Season.AUTUMN; &#125; &#125;, AUTUMN(&quot;秋天&quot;) &#123; @Override public Season next() &#123; return Season.WINTER; &#125; &#125;, WINTER(&quot;冬天&quot;) &#123; @Override public Season next() &#123; return Season.SPRING; &#125; &#125;; private String sign; Season()&#123; &#125; Season(String sign) &#123; this.sign = sign; &#125; public String getSign() &#123; return sign; &#125; //提供一个抽象方法 - 但是要求所有的枚举常量都要重写这个抽象方法 public abstract Season next();&#125;class TestSeason&#123; public static void main(String[] args) &#123; Season s = Season.SPRING; for(;;)&#123; System.out.println(s+&quot;-&quot;+s.getSign()); try &#123; //让程序睡一秒钟 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; s = s.next(); &#125; &#125;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day13","slug":"day13","date":"2021-07-27T10:02:10.000Z","updated":"2022-01-07T09:02:59.647Z","comments":true,"path":"2021/07/27/day13/","link":"","permalink":"http://example.com/2021/07/27/day13/","excerpt":"","text":"File java.io.File[C] - File包含文件或者文件夹[目录directory] 作用:它是用来操作File本身的元信息的[比如支持File的创建,删除,获取File的名称,获取File的路径等信息] 它并不支持文件里面的内容的读写操作[文件内中的内容的读写操作是交给IO流去实现] 支持本地File以及远程File的操作的. File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射. 构造方法 File(String path);//利用一个路径来构建一个File实例.这个路径可以是文件的路径,也可以是文件夹的路径 路径分成相对路径和绝对路径. 绝对路径 - windows操作系统是以盘符号开头的路径,Linux/mac以/开头的路径 相对路径 - 不是以盘符或者/开头的路径 常用方法 boolean createNewFile();//创建一个文件,该方法是要抓取异常的. String getAbsolutePath();//获取该File的绝对路径 String getName();//获取File的名称 String getParent();//获取该File的父目录的绝对路径 boolean exists();//判断File是否存在 boolean delete();//删除文件或者文件夹 6-1. 文件是否可以直接被删除的 6-2. 如果是空目录 - 直接删除的 6-2. 如果是非空目录 - 将会删除失败 - 递归算法来实现的. boolean mkdir();//创建单层次的目录,一次只能创建一个目录 boolean mkdirs();//既可以创建单层次的目录,又可以同时创建多个不存在的目录. boolean isFile();//判断File实例是否为文件的实例 boolean isDirectory();//判断file实例是否为文件夹的实例 String[] list();//返回的是File的名称,返回的是传入的路径下的第一层的内容. File[] listFiles();//返回的第一层的File实例 File[] listFiles(FilenameFilter filter);//找到指定后缀/前缀/满足条件的这么一个File实例 练习 传入一个目录,输出这个目录下的所有的内容. 如果是文件 - 直接输出名称 如果是文件夹 - 输出绝对路径 作业 删除一个非空目录 IO流 流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]进行有序的输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output) 流想象成是数据传输的那个管道 磁盘中数据加载/读入到内存中 - 输入 java内存中数据写出去到磁盘中 - 输出 流的分类 按照流的方向 - 输入流和输出流 按照流的读取的单位不同 - 字节流[按照单个字节单个字节进行读写,文本文件或者二进制文件]和字符流[单个字符进行读写,只能操作文本字符文件] 按照流的功能 - 节点流[基础流]和拓展流[过滤流或者包装流] - 采用了”装饰器设计模式思想” **节点流才具备真正操作文件的能力.**拓展流只是让流的功能更加强大而已,拓展流脱离了节点流的话,那么是不允许的. 拓展流的使用必须要建立在节点流的基础之上. 字节流字节输入流 java.io.InputStream[C] - 字节输入流的顶级的抽象的父类 java.io.FileInputStream[C] - 文件字节输入流 - 操作文件的读操作. - 典型的节点流 java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - 典型的包装流 java.io.FilterInputStream[C] - 过滤流 java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataInputStream[C] - 操作基本数据类型的字节输入流 字节输出流 java.io.OutputStream[C] - 字节输出流的顶级的抽象的父类 java.io.FileOutputStream[C] - 文件字节输出流 - 操作文件的写操作. - 典型的节点流 java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - 典型的包装流 java.io.FilterOutputStream[C] - 过滤流 java.io.BufferedOutputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流 InputStream常用方法 void close();//关闭流,流本身就是一个对象[占内存 - 昂贵的资源] abstract int read();//单个字节单个字节的读取,如果读不到,返回-1 int read(byte[] b);//从输入流读取一些字节数，并将它们存储到缓冲区 b 。 OutputStream常用方法 void close();//关闭 abstract void write(int b);将指定的字节写入此输出流。 void write(byte[] b, int off, int len); IO流的编程步骤 确定流 - 选什么流 确定源头和目标 循环读取,循环写出 - while 关闭流 缓冲流BufferedInputStream 在它出来之前,可以可以单个字节单个字节进行读写操作 - 弊端:java程序和磁盘的IO交互比较频繁,性能就会低下. 采取了自定义的数组的方式.从磁盘文件中读取一定数量的字节先放入到缓冲数组中.然后再从缓冲数组中一次性写出到磁盘中. 减少了java程序和磁盘的IO交互 - 性能提高. JDK中发现了这点,提供了缓冲流BufferedInputStream 123456789101112131415private static int DEFAULT_BUFFER_SIZE = 8192;//默认的容量8kbprotected volatile byte buf[];//内置的缓冲区public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE);&#125;public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); &#125; buf = new byte[size];//初始化内置的缓冲区数组 - 大小是8kb&#125; 底层利用了”装饰器”思想.这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力. 构建带缓冲功能的流,必须要以节点流作为支撑 构架一个带缓冲功能的能够读取文件的字节输入流 BufferedInputStream in = new BufferedInputStream(new FileInputStream(“路径”)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(“路径”)); 缓冲数组 BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么? 内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的. 12345678910111213141516171819202122232425262728293031323334353637383940414243package tech.aistar.day13;import java.io.*;/** * 本类用来演示: 缓冲流 * * @author: success * @date: 2021/8/5 2:18 下午 */public class BufferDemo &#123; public static void main(String[] args) &#123; BufferedInputStream in = null; BufferedOutputStream out = null; try &#123; //jvm加载磁盘上的数据到内置的byte[]中 in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_副本.gif&quot;)); //自定义一个byte[] //真正的读 byte[] buf = new byte[3*1024]; int len = -1; while(true)&#123; len = in.read(buf); if(len==-1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 读过程 当初始化好缓冲流之后,jvm会立即读取磁盘中的数据到内置的缓冲数组中 当程序中循环读取到的时候 len = in.read(buf); = 程序是直接从内置的缓冲区[内置的缓冲数组中] 一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区. 语法糖 jdk7.0提供的写法 作用 - 把流的关闭交给JVM 12345try(资源对象的声明1;资源对象的声明2)&#123; &#125;catch(..)&#123; ...&#125; 123456789101112131415161718192021222324252627282930313233343536package tech.aistar.day13;import java.io.*;/** * 本类用来演示: 语法糖 - JVM去关闭流 * * @author: success * @date: 2021/8/5 2:39 下午 */@SuppressWarnings(&quot;all&quot;)public class StreamAutoCloseDemo &#123; public static void main(String[] args) &#123; //自动关闭这些资源 try(BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fasts.gif&quot;)))&#123; //自定义一个byte[] byte[] buf = new byte[3*1024]; int len = -1; while(true)&#123; len = in.read(buf); if(len==-1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ObjectInputStream/ObjectOutputStream 操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑 构建一个能够读写对象类型的文件字节输入流/输出流 1ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;path&quot;)) 构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流 1ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(&quot;path&quot;))); 利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响. 对象的序列化 也叫做 - 数据的持久化的过程. - 把内存中的java对象存储到磁盘的文件的过程. 注意点: 如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口 如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常 保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口 关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取. transient1234//有的属性比较敏感,比如员工的工资//如果不希望持久化某个属性值 - 不希望这个属性的数据被写到磁盘中//瞬态关键字private transient double price; 对象的反序列化 java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上]. CURD操作① 实体类 - 接口 - 实现类 - 单元测试 操作文件中的数据 tech.aistar.day13.prj entity - Phone.java[id,name,price] dao - data access object [IPhoneDao.java]数据对象访问 - 数据持久层 - 和文件进行打交道的一层 - 接口 impl - 接口的实现类PhoneDaoImpl.java test - 单元测试 笔试题 文件夹的拷贝② 字符流 它和字节流的区别是读取的单位是不同的 .字节流是按照单个字节进行读写操作. 字符流是按照单个字符的单位进行读写操作.字符流专门用来处理的文本字符文件的.字节流是用来处理文本文件或者二进制文件的. 字符输入流 java.io.Reader[C] - 顶级的字符输入流 - 抽象类 BufferedReader[C] - 带缓冲功能的字符流 123public BufferedReader(Reader in) &#123; this(in, defaultCharBufferSize);&#125; 12提供的方法String readLine();//每次读取文本文件的一整行的数据,如果读取不到[到达文件的末尾了],返回false FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的. demo1234567891011121314151617181920212223242526272829303132333435363738394041424344package tech.aistar.day13;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * 本类用来演示: 字符输入流 * * @author: success * @date: 2021/8/6 1:40 下午 */public class ReaderHelloDemo &#123; public static void main(String[] args) &#123; //1. 确定流 //2. 确定源头 //3. 循环读取 //4. 关闭流 - 可以采取语法糖 - JVM去自行关闭 //demo - 用来读取文本文件,然后将内容输出到控制台上去 try(BufferedReader in = new BufferedReader(new FileReader(&quot;src/tech/aistar/day13/Book.java&quot;)))&#123; //一行一行进行读取 String line = null; //循环读取 while(true)&#123; line = in.readLine();//读取一整行的数据,若读取不到,则返回false //循环退出的条件 if(line == null) break; System.out.println(line); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符输出流 java.io.Writer[C] - 顶级的字符输出流 - 抽象类 PrintWriter[C] - 自带缓存功能 1234567PrintWriter(Writer out);//第二个参数是是否自动刷新缓存//缓存里面的数据什么时候会被同步到磁盘上//1. 缓存中的数据满的时候 - 会自动刷新//2. 缓存中的数据还不足以撑满这个缓存 - close或者flush - 强制刷新缓存PrintWriter(Writer out, boolean autoFlush); FileWriter[C] -字符流中的节点流 - 具备真正的字符文件的读写操作的. 1234构造方法:1. FileWriter(String path);//写到哪里去,目标的绝对/相对路径2. FileWriter(String path,boolean append);//第二个参数代表的是是否追加写入.如果append设置成true.支持分批次的写 和分批次的读 - 都是字符串 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package tech.aistar.day13;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * 本类用来演示: 字符输出流 * * @author: success * @date: 2021/8/6 1:57 下午 */public class WriterHelloDemo &#123; public static void main(String[] args) &#123; test02(); &#125; public static void test03()&#123; //1. 构建一个自动刷新,但是能够实现追加写入的功能. //第一个true - 代表的是是否追加写入 - true //第二个true - 是否自动刷新缓存,设置成true之后,那么就不需要在程序代码中手动刷新,不需要再去写out.flush(); // 推荐 - 1. 构建一个自动刷新的输出流 2. 程序代码的之后还是推荐手动刷新out.flush()3. 依然需要关闭流 - jvm try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true),true))&#123; //因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存. //有可能有部分学生的计算机,它没有达到强制刷新缓存的效果 //场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的] //print方法以及println方法 //print方法写入之后,后面是没有加一个\\n //println方法写入之后,后面是有一个\\n //把内存中的数据持久化到磁盘中的文件中. //out.print(&quot;web前端很好玩!&quot;); out.println(&quot;c不好玩!&quot;); //推荐在结束的时候,手动刷新一下缓存 out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void test02()&#123; //1. 构建一个不自动刷新,但是能够实现追加写入的功能. try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true)))&#123; //因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存. //有可能有部分学生的计算机,它没有达到强制刷新缓存的效果 //场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的] //print方法以及println方法 //print方法写入之后,后面是没有加一个\\n //println方法写入之后,后面是有一个\\n //把内存中的数据持久化到磁盘中的文件中. //out.print(&quot;web前端很好玩!&quot;); out.println(&quot;c不好玩!&quot;); //推荐在结束的时候,手动刷新一下缓存 out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void test01()&#123; //1. 构建的是一个不自动刷新,不追加写入的字符输出流 //每次都会覆盖原来的文件,并且在第一次写入的时候,会自动创建这个文件的. try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;)))&#123; //因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存. //有可能有部分学生的计算机,它没有达到强制刷新缓存的效果 //场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的] //print方法以及println方法 //print方法写入之后,后面是没有加一个\\n //println方法写入之后,后面是有一个\\n //把内存中的数据持久化到磁盘中的文件中. out.print(&quot;python很好玩!&quot;); //推荐在结束的时候,手动刷新一下缓存 out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件的拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day13;import java.io.*;/** * 本类用来演示: 字符流来实现文件的拷贝操作 * * @author: success * @date: 2021/8/6 2:37 下午 */public class FileCopyReaderDemo &#123; public static void main(String[] args) &#123; copyFile(&quot;src/tech/aistar/day13/FileDemo.java&quot;,&quot;src/tech/aistar/day13/FileDemo_副本.java&quot;); &#125; /** * 文件的拷贝 * @param src 原文件的路径 * @param target 目标文件的路径 */ public static void copyFile(String src,String target)&#123; //1. 构建流 - 源头和目标的确定 try(BufferedReader in = new BufferedReader(new FileReader(src)); PrintWriter out = new PrintWriter(new FileWriter(target),true))&#123; //2. 定义一个变量 - 用来保存每次读取到的一行数据 String line = null; //3. 循环读取 while(true)&#123; line = in.readLine();//读取一整行,读不到,则返回null //循环退出的条件 if(line == null) break; //写一行出去 out.println(line); &#125; System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结笔试 常见的字节流和字符流 装饰器的设计模式 难一点的知识点 - 同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别 BufferedInputStream - 内置的缓冲数组 - 8kb 补充 - 破坏单例 单例设计模式 - 保证在整个应用程序中,某个类的具体的实例永远只有1个 - 多线程下也是一个 - 双重锁检测 对象的序列化和反序列化可以破坏这种单例,如何破坏? 解决方案: 单例的第四个版本 - 枚举类型来实现单例模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package tech.aistar.day13;import tech.aistar.design.singleton.version03.Singleton03;import java.io.*;/** * 本类用来演示: 对象的序列化和反序列化可以破坏单例的 * * @author: success * @date: 2021/8/6 3:06 下午 */public class ObjectSingletonDemo &#123; public static void main(String[] args) &#123; Singleton03 s1 = Singleton03.getInstance(); String path = &quot;src/tech/aistar/day13/singleton.txt&quot;; //把这个对象写入到文件中 writeObject(s1,path); //读 Singleton03 s2 = readObject(path);//反序列化之后,并没有走构造,直接操作的内存 System.out.println(s1 == s2);//false &#125; //对象的序列化 public static void writeObject(Singleton03 s,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path)))&#123; //写 out.writeObject(s); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //对象的反序列化 public static Singleton03 readObject(String path)&#123; Singleton03 s = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path)))&#123; //读 s = (Singleton03) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day12","slug":"day12","date":"2021-07-26T10:02:10.000Z","updated":"2022-01-07T09:02:41.435Z","comments":true,"path":"2021/07/26/day12/","link":"","permalink":"http://example.com/2021/07/26/day12/","excerpt":"","text":"SimpleDateFormat java.text.SimpleDateFormat - 日期格式处理类 线程不安全的类. 目标 Date类型转换成String类型 - 按照指定的日期格式. 1234//pattern必须是一个有效的格式化模板,如果传入了一个非法模板//那么就会抛出一个java.lang.IllegalArgumentException - 非法参数异常// Illegal pattern character &#x27;q&#x27;String format(Date date); String类型转换成Date类型. 1234//如果构造中的pattern的格式和日期的字符串的格式不一致,那么在调用//parse方法的时候就会抛出java.text.ParseException: Unparseable date: &quot;2020-09-03&quot;//解析失败异常Date parse(String str); 模板pattern Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 日期工具类 java.util.Date BigDecimal api: java.math 构造方法 BigDecimal(double val) BigDecimal(String val);//处理小数精度的问题 常用方法 BigDecimal add(BigDecimal augend)返回 BigDecimal ，其值是 (this + augend) ，其标为 max(this.scale(), augend.scale()) 。 BigDecimal divide(BigDecimal divisor) 除法 BigDecimal multiply(BigDecimal multiplicand) 乘法 BigDecimal subtract(BigDecimal subtrahend) 减法 笔试题 在java开发中如何处理小数精度丢失的问题 需要使用到的是BigDecimal(String val); 123456789101112131415161718192021222324package tech.aistar.day12;import java.math.BigDecimal;/** * 本类用来演示: 处理小数 * * @author: success * @date: 2021/8/4 9:27 上午 */public class BigDecimalHandlerFloatDemo &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(&quot;0.1&quot;); BigDecimal d2 = new BigDecimal(String.valueOf(0.2)); BigDecimal result = d1.add(d2); //BigDecimal-&gt;double/String double resultDouble = result.doubleValue(); System.out.println(resultDouble); System.out.println(result); &#125;&#125; BigInteger 笔试题 - 递归算法求阶乘 构造:BigInteger(String val); 12345678910111213public class BigIntegerDemo &#123; public static void main(String[] args) &#123; System.out.println(test(6)); &#125; public static BigInteger test(int n)&#123; if(n==1) return BigInteger.ONE; BigInteger current = new BigInteger(String.valueOf(n)); return current.multiply(test(n-1)); &#125;&#125; 四种内部类 看懂别人写的内部类语法即可 成员内部类 - 把内部类看成是外部类的一个成员 a. 成员内部类不能再去定义静态成员 b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态属性 1外部类.内部类 对象名 = 外部类对象.new 内部类(); 静态内部类- 把内部类看成是外部类的一个静态成员 1外部类.内部类 对象名 = new 外部类.内部类(); a. 内部是可以定义静态和非静态属性的 b. 内部的普通方法中是不允许访问外部类的非静态属性的. c. 内部的普通方法中是允许访问外部类的静态属性的 局部内部类 - 内部类是出现在外部类的方法中. a. 内部类是不允许使用访问修饰符,比如不能使用public b. 不能定义静态属性的 c. 访问到外部类的静态和非静态成员的 d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new) 匿名内部类 - 必须掌握的 好处 - 我们可以在程序中少写实现类 jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的. 装饰器模式 IO流使用到了”装饰器”设计模式思想 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 UML Unified Modeling Language- 统一建模语言 BA - 需求分析师 powerndesigner starUML 掌握目标: 看懂箭头即可 类与类之间由弱到强关系是: *没关系 &gt;** **依赖 &gt; 关联 &gt; 聚合 &gt; 组合。* 依赖 虚线+箭头&lt;—— 可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的 123456789101112131415public class A&#123; public void test(B b)&#123; //自己的功能 //B类中的功能 b.test(); &#125;&#125;public class B&#123; &#125; 关联 箭头 实线+箭头&lt;- A类关联了B类 - A依赖于B 1234567public class A&#123; private B b;&#125;public class B&#123; &#125; 组合关系 属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密.整体是可以决定局部的生命周期的. 箭头 - 实线+实心菱形 123456789101112131415161718192021222324package tech.aistar.uml.combination;/** * 本类用来演示:属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密. * 整体是可以决定局部的生命周期的. * * @author: success * @date: 2021/8/4 10:34 上午 */public class Baby &#123; private Eye eye; private Hand hand; public Baby()&#123; this.eye = new Eye(); this.hand = new Hand(); &#125; public static void main(String[] args) &#123; Baby b = new Baby(); &#125;&#125; 聚合关系 属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的 箭头 - 实线+空心菱形 1234567public class Computer &#123; private Cpu cpu; public Computer(Cpu cpu)&#123; this.cpu = cpu; &#125;&#125; Throwable java.lang.Throwable - 异常和错误的顶级的类 两个分支: java.lang.Error - 错误 - 错误一旦发生,程序员是么有办法进行扭转的 - 不需要在代码中进行处理. 1-1. 子类VirtualMachineError虚拟机级别的错误 ​ 1-1-1. 子类java.lang.StackOverflowError 堆栈溢出 - 应用程序因为递归太深没有指定出口的时候. ​ 1-1-2. 子类java.lang.OutOfMemoryError 内存泄漏 - [GC垃圾回收机制 - 后台自动回收垃圾对象] java.lang.Exception - 异常 - 程序在运行的过程中发生了不正常的情况. 异常的分类 运行时异常[RuntimeException]都是非运行时异常的子类[Exception] 运行时异常 - 未检测异常 顶级的父类java.lang.RuntimeException java.lang.NullPointerException - 空指针异常 java.util.InputMismatchException - 输入不匹配异常 12Scanner sc = new Scanner(System.in);int n = sc.nextInt();//只能获取整数.但是输入了一个字符串&quot;abc&quot; java.lang.ArithmeticException - 分母为0 java.lang.IllegalArgumentException - 非法参数异常 12SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);构造中的模板如果传入了一个非法模板 java.lang.IndexOutOfBoundsException - 下标越界异常 - 比如list.get(100); 5-1. java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常 5-2. java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常 java.util.NoSuchElementException - 不存在此元素 12LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;();System.out.println(list.getFirst());//获取栈顶元素,但是栈顶没有元素 java.lang.ClassCastException - 类型转换失败异常 1父类类型转换成子类类型之前,推荐先使用instanceof关键字进行类型的判断 非运行时异常 - 已检测异常 java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配 InterruptedException - 中断异常 - Thread.sleep(1000); java.lang.CloneNotSupportedException - 不允许被clone. 1当调用对象的clone方法,但是这个对象没有去实现java.lang.Cloneable接口 java.io.IOExcetion - IO流异常 4-1. java.io.EOFException - 已经读取到文件的末尾了. 4-2. java.io.FileNotFoundException - 文件找不到异常 java.sql.SQLException - SQL异常,比如程序中的sql语句要是写错了. 异常的处理方式 运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断.稍微谨慎一点. 非运行时异常 - 编译期间就需要立即对其进行处理.处理的方式有俩种.一种是积极处理 - try..catch的方式 另外一种是消极处理. 积极处理方式 语法一 - try….catch….catch….finally 推荐使用到的 - 因为针对每种不同的异常进行单独的日志记录,单独的异常处理. 1234567891011try&#123; //code.. //code..&#125;catch(异常类型1 e1)&#123; &#125;catch(异常类型2 e2)&#123; &#125;finally&#123; //无论是否出现异常,都会执行&#125;注意:上方的异常类型不能是下方的异常类型的父类. 语法二 - jdk7.0提供的新的写法 123456try&#123; //code... //code...&#125;catch(异常类型1 | 异常类型2)&#123; //...&#125; 语法三 - 简单粗暴 12345try&#123; //....&#125;catch(异常总父类)&#123; //...&#125; 消极处理 比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了. 为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理. 原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃. 直接在方法的签名[声明]上使用throws关键字+异常类型1,异常类型2 在方法体中使用throw+异常对象 123456789101112public static void d(int n) throws FileNotFoundException &#123; if(n==0)&#123; //System.out.println(&quot;异常的描述....&quot;); //throw + 运行时异常对象,不需要在方法的签名上抛出异常 - 本身运行时异常就不需要处理呀! //throw new RuntimeException(&quot;发生异常了...&quot;); //throw + 非运行时异常 配合 必须要在方法的签名上throws+非运行时异常类型 throw new FileNotFoundException(&quot;文件不存在!&quot;); &#125; System.out.println(&quot;n:&quot;+n);&#125; 笔试题 - throws和throw有什么区别 笔试题11234567891011121314try&#123; //code... //code.. return;//结束整个方法&#125;catch(异常类型 e)&#123; &#125;catch(异常类型 e)&#123; &#125;finally&#123; //无论是否出现异常,都会执行&#125;假设try&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.1. finally中的代码执行否? - 肯定会执行2. return语句是在finally块之前执行还是之后执行? - 之后 笔试题21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day12.exception;/** * 本类用来演示: 笔试题 * * @author: success * @date: 2021/8/4 3:23 下午 */public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(test());//1 System.out.println(change());//A&#123;age=200&#125; &#125; //finally中修改了基本数据类型 public static int test()&#123; int i = 0;//① //try可以直接和finally一起使用.... try&#123; //此处将i自增后的结果缓存起来了.并且这个缓存的结果就是作为最终返回出去的一个结果 - 对待基本数据类型. return ++i; &#125;finally &#123; ++i;//③ System.out.println(&quot;i:&quot;+i); &#125; &#125; //finally修改了对象类型的属性 public static A change()&#123; A a = new A(); try&#123; a.age = 100; //return是在finally之后执行 return a; &#125;finally &#123; //对待对象类型 - finally中的修改对象的属性值,是对return的结果是产生了影响的. a.age = 200; &#125; &#125;&#125;class A&#123; public int age = 18; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;A&#123;&quot;); sb.append(&quot;age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 笔试题3 final和finally和finalize三者之间的区别? - 一点关系都没有 final a. 修饰的局部变量一旦赋值成功,不可改变 b. 修饰的属性一旦赋值成功,不可改变 c. 修饰的类不可被继承 d. 修饰的方法不可被重写 finally a. 一般是和try..catch搭配使用的.try块中无论是否出现异常,finally块中代码都会执行 b. finally块中一般写的是释放或者关闭资源的代码 finalize - Object类中提供的方法 a. 当GC想去回收一个垃圾对象之前,会去调用这个对象的finalize方法.是由JVM去调用. b. 该方法未必一定会被调用得到. 自定义异常 项目中其实是专门包exception - 专门自定义自己的异常[大量的] jdk内置的异常不够用,不符合实际的业务场景. 步骤 写一个异常类继承java.lang.Exception 提供父类的5个构造方法即可 思考为什么要自定义异常 123System.out.println(&quot;余额小于0&quot;); throw new BalanceLtZeroException(&quot;余额小于0!&quot;); 场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - 显示比如服务器正在维护/升级… 我们应该提供一个异常处理器 - 会监控软件程序在整个项目运行的过程中发生的一切异常. 一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面. SpringMVC/SpringBoot - 异常处理器 - 只认识异常. 复习 重点围绕OO - 面向对象 三大特性 - 封装,继承,多态 抽象类和接口区别 四种访问修饰符的作用权限 方法的重载和方法的重写 单例 - 双重检测锁 简单工厂 static关键字的作用 - static练习 预习 泛型 IO流 - 大头 并发编程 - 多线程 - 大头中的大头 - 最难的最难的最难的 反射技术 - 看懂框架的源码[反射技术 + 设计模式] 动态代理 - [jdk动态代理 + cglib动态代理] 枚举类型","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day11","slug":"day11","date":"2021-07-25T10:02:10.000Z","updated":"2022-01-07T09:02:20.264Z","comments":true,"path":"2021/07/25/day11/","link":"","permalink":"http://example.com/2021/07/25/day11/","excerpt":"","text":"集合框架 就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用. 结构12345678910111213141516api:java.util Collection[I] - List[I] - 有序可重复 - ArrayList[C] - 线程不安全 - LinkedList[C] - Vector[C] - 使用方式和ArrayList一样,但是线程安全的 - 方法都是采用synchronized - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射的对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I] 特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C] 特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低.因为涉及到下标的移动. 分析源码123456789101112131415161718192021222324252627282930 /** * 默认的初始的容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//就是真正的存储数据的数组transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;//构造public ArrayList() &#123; //1. 初始化elementData,长度为0 //2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //this.elementData = &#123;&#125;&#125; 剖析add方法 ArrayList扩容的原理 12345public boolean add(E e) &#123;ensureCapacityInternal(size + 1); // Increments modCount!!elementData[size++] = e;return true;&#125; 扩容方法 123456789private void ensureCapacityInternal(int minCapacity) &#123;//第一次进来1if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;//true //第一次minCapacity = 10 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125;ensureExplicitCapacity(minCapacity);&#125; 继续ensureExplicitCapacity(minCapacity); 12345678private void ensureExplicitCapacity(int minCapacity) &#123;modCount++;// overflow-conscious code//第一次进来10-0&gt;0if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; grow(minCapacity) 123456789101112131415private void grow(int minCapacity) &#123;// 第一次//oldCapacity = 0//newCapacity = 0int oldCapacity = elementData.length;int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//1.5倍if (newCapacity - minCapacity &lt; 0)//第一次会进来 newCapacity = minCapacity;//newCapacity = 10if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity);// minCapacity is usually close to size, so this is a win://第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历 直接输出 增强for循环 - 只读 1234567891011121314151617181920212223242526272829只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常 实际的底层,调用迭代器对象中的next方法 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public E next() &#123; checkForComodification(); //.... &#125; final void checkForComodification() &#123; //modCount是当初调用add方法,添加1个元素,modCount自增1个 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 发现只要调用了remove方法 - modCount++ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 普通for 迭代器 因为不同的集合的底层的数据结构是不一样的.数据结构不一样,它的遍历方式不一样 为了访问/遍历不同数据结构的集合提供一种统一的遍历方式 1234567 //1. 获取集合的迭代器Iterator&lt;Long&gt; iter = list.iterator();//2. 调用hasNext方法while(iter.hasNext())&#123;//判断迭代器中是否仍有下一个元素可被迭代 Long p = iter.next();//获取当前迭代的 System.out.println(p);&#125; jdk8提供的新的遍历方式 12345678910111213list.forEach(new Consumer&lt;Long&gt;() &#123;//匿名内部类 @Override public void accept(Long aLong) &#123; System.out.println(aLong); &#125;&#125;);//lambda表达式来替代匿名内部类的写法//配合函数式接口[只能包含一个抽象方法]System.out.println(&quot;======lambda====&quot;);list.forEach(e -&gt; System.out.println(e)); System.out.println(&quot;========&quot;);list.forEach(System.out::println); LinkedList[C] 有序的序列,底层的数据结构双向链表,jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动. 适合解决栈列和队列的业务题型 - 贪吃蛇 栈列 - 先进后出 队列 - 先进先出 链表结构 相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址. 单向链表 head - 头节点 tail - 尾节点 element - 节点中真正的保存的数据 next - 下一个节点的地址 单向循环链表 尾节点的next又指向了头节点. 双向链表 - LinkedList底层数据结构 增加了一个pre - 保存的是上一个节点的地址. 双向循环链表 剖析源码123456789101112131415161718192021222324252627282930313233343536373839404142//Node代表的是链表的节点 private static class Node&lt;E&gt; &#123; E item;//真正的元素 Node&lt;E&gt; next;//下一个节点的地址 Node&lt;E&gt; prev;//上一个节点的地址 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;//双向链表如何插入一个新的节点public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; //第一次进入last最后一个节点Node - null final Node&lt;E&gt; l = last;//l = null //第二次进入 l = new Node&lt;&gt;(null,&quot;ok&quot;,null) //第一次进入 //newNode = new Node&lt;&gt;(null,&quot;ok&quot;,null) //第二次进入 //newNode = new Node&lt;&gt;(链表中原来的最后一个节点l, &quot;java&quot;, null); final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //新插入的节点肯定是作为最后一个节点 - 尾节点 last = newNode; if (l == null)//第一次进入,链表之前没有任何元素 first = newNode;//新的节点作为头节点 else //原来链表中的最后一个节点的next同时也指向新的节点 l.next = newNode; size++; modCount++;&#125; 查找源码 1234567891011121314151617181920212223 public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125;Node&lt;E&gt; node(int index) &#123;//index = 3 // 假设集合中有10个元素 = size = 10 //index&lt;5 - 链表的坐标 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first;//确定头节点 for (int i = 0; i &lt; index; i++) x = x.next; //① - x第二个 ,i=0 //i=1 x第三个 //i=2 x第四个 return x; &#125; else &#123;//index&gt;=5 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 删除源码 12345678910111213141516171819202122232425262728293031 public E remove(int index) &#123; checkElementIndex(index); //找到index对应的Node对象,传入到了unlink方法中. return unlink(node(index)); &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;//防止删除的是头节点 first = next;//需要删除的那个节点的下一个节点作为头节点了. &#125; else &#123;//删除的是中间节点 prev.next = next;//原来节点的上一个节点的next指向原来节点的下一个节点 x.prev = null;//优化,更快让GC会回收pre指针. &#125; if (next == null) &#123;//删除的是尾结点 last = prev;//原来节点的上一个节点作为尾节点 &#125; else &#123;//删除的是中间节点 next.prev = prev;//原来节点的下一个节点指向原来节点的上一个节点 x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 练习-括号匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.day11.homework;import java.util.LinkedList;import java.util.Scanner;/** * 本类用来演示: 括号匹配 * * @author: success * @date: 2021/7/29 1:51 下午 */public class BracketsDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;输入括号:&gt;&quot;); String line = sc.nextLine(); if(matches(line))&#123; System.out.println(&quot;匹配&quot;); &#125;else&#123; System.out.println(&quot;不匹配&quot;); &#125; &#125; private static boolean matches(String line) &#123; //1. 将字符串转成字符数组 char[] arr = line.toCharArray(); //2. 新建一个LinkedList集合 LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); //3. 将数组中的第一个元素压入栈顶 list.push(arr[0]); //4. 从arr数组的第二个位置开始遍历 for (int i = 1; i &lt; arr.length; i++) &#123; //()[]&#123;&#125; //获取当前的arr[i] Character c = arr[i]; //为了避免在栈顶已经没有元素的情况下还去获取栈顶元素,非空判断 if(list.isEmpty())&#123; list.push(c); continue; &#125; //5. 先获取栈顶元素 Character top = list.getFirst(); //6. 栈顶元素和当前的arr[i]进行匹配 if(top.equals(&#x27;(&#x27;)&amp;&amp;c.equals(&#x27;)&#x27;) || top.equals(&#x27;&#123;&#x27;)&amp;&amp;c.equals(&#x27;&#125;&#x27;) || top.equals(&#x27;[&#x27;)&amp;&amp;c.equals(&#x27;]&#x27;))&#123; //弹出栈顶元素 list.pop(); &#125;else&#123; //继续将当前的arr[i]压入栈顶 list.push(c); &#125; &#125; return list.isEmpty(); &#125;&#125; Map[I]HashMap[C] 数据存储的形式是key-value,针对key是无序不可重复的. jdk8.x之前,底层的数据结构是桶数组+链表 jd8.0开始,底层的数据结构是桶数组+链表+红黑树 桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的. 图示 剖析put方法123456789101112131415161718192021222324public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//hash函数就是扰动函数//1. 尽可能减少哈希冲突static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//map数据结构图示中每个节点static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;//单向链表 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566transient Node&lt;K,V&gt;[] table;//默认值是null//hash(key)final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //第一次进来 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //第一次进来,第二次肯定不走 if ((tab = table) == null || (n = tab.length) == 0) //第一次肯定会进来 //1. 对tab进行一个初始化操作 //2. 得到初始化数组的长度,赋值给了n n = (tab = resize()).length;//n=16 //第一次肯定判断结果为null if ((p = tab[i = (n - 1) &amp; hash]) == null) //tab[i] = 新的节点 tab[i] = newNode(hash, key, value, null); else &#123; //哈希碰撞了,哈希冲突了. Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //key值冲突了. //e = 数组中的旧的Node对象 e = p; //hash虽然碰撞了,但是key是不一样 else if (p instanceof TreeNode)//判断是否为红黑树结构 //当链表的节点&gt;8个,链表结构转成红黑树结构 //当红黑树节点&lt;6个,恢复成链表结构 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//链表结构 for (int binCount = 0; ; ++binCount) &#123; //p代表的就是哈希碰撞位置的第一个Node对象 if ((e = p.next) == null) &#123;//新的节点挂载到链表的末尾 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //新的节点可能和链表结构中的某个节点的key也是一样的 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //e肯定是不为null p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key //把旧的节点的value赋值给了oldValue,put方法的返回结果 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //新值覆盖旧值 e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 扩容方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //第一进来就会执行到此处 , 16 //扩容因子是0.75 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; //初始化一个长度为16的数组 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; map集合的迭代方式123456789101112131415161718192021//第一种方式 - 将map集合中所有的key全部取出来放入到一个Set集合中.//set集合 - 无序不可重复,map集合的key也是无序不可重复.Set&lt;Integer&gt; sets = maps.keySet();//遍历set集合Iterator&lt;Integer&gt; iter = sets.iterator();while(iter.hasNext())&#123; Integer key = iter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125;//第二种方式 - 将map集合中的每对key-value封装到了一个内置的Entry对象中//然后将每个entry对象放入到Set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter2 = entries.iterator();while(iter2.hasNext())&#123; Map.Entry&lt;Integer,String&gt; e = iter2.next(); Integer key = e.getKey(); String value = e.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; Map作业123456789int[] arr = &#123;1,2,1,2,3,4,1,2,5,.....&#125;统计每个随机数出现的次数 - Map集合 String str = &quot;sfhdsfkdfdfjdfjdfdjfdsa&quot;;String[] arr = [&quot;python&quot;,&quot;java&quot;,&quot;python&quot;,&quot;java&quot;,&quot;php&quot;,&quot;python&quot;];String str = &quot;python java python java mysql java mysql php&quot;; spilt(&quot;\\\\s&quot;) 1231. 写一个程序统计每个品牌花费的总费用 - 统计类题型2. 根据总费用降序排 - 可以暂时不做. http://xzc.cn/sYtc8YkClM - 宝洁作业 http://xzc.cn/p5acBgPAHf - 基础弱的 - 1. 当天的代码2遍 ​ 2. 解决了哪些问题? 列一下自己尚未解决的问题? 排序比较器接口Comparator jdk8.0开始,在List接口中已经定义了排序的方法 void sort(Comparator&lt;? super E&gt; c) 分析:java.util.Comparator[I]函数式接口 - 允许使用lambda表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package tech.aistar.day11;import tech.aistar.day10.Book;import java.util.ArrayList;import java.util.Comparator;import java.util.List;/** * 本类用来演示: 集合排序 * * @author: success * @date: 2021/7/30 9:29 上午 */public class ListSortDemo &#123; public static void main(String[] args) &#123; Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d); Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d); Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d); Book b4 = new Book(4,&quot;1004&quot;,&quot;python&quot;,300.0d); List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); bookList.add(b1); bookList.add(b2); bookList.add(b3); bookList.add(b4);// bookList.sort(new Comparator&lt;Book&gt;() &#123;// @Override// public int compare(Book o1, Book o2) &#123;// if(o1.getPrice()&gt;o2.getPrice())// return -1;// else if(o1.getPrice()&lt;o2.getPrice())// return 1;// return 0;// &#125;// &#125;); //根据价格降序排// bookList.sort((o1,o2)-&gt;&#123;// if(o1.getPrice()&gt;o2.getPrice())// return -1;// else if(o1.getPrice()&lt;o2.getPrice())// return 1;// return 0;// &#125;); //根据编号降序排 - String类型// bookList.sort((o1, o2) -&gt; o2.getIsbn().compareTo(o1.getIsbn())); //根据价格降序排,如果价格一样的话,按照编号继续降序排 bookList.sort((o1,o2)-&gt;&#123; if(o1.getPrice()&gt;o2.getPrice()) return -1; else if(o1.getPrice()&lt;o2.getPrice()) return 1; return o2.getIsbn().compareTo(o1.getIsbn()); &#125;); for (Book book : bookList) &#123; System.out.println(book); &#125; &#125;&#125; 可比较接口 排序的对象对应的实体类实现java.lang.Comparable接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package tech.aistar.day11.compares;/** * 本类用来演示: * * @author: success * @date: 2021/7/30 10:53 上午 */public class Teacher implements Comparable&lt;Teacher&gt;&#123; private int id; private String name; private int age; public Teacher() &#123; &#125; public Teacher(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Teacher&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125; @Override public int compareTo(Teacher o) &#123; //定制排序的规则 return o.age - this.age; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package tech.aistar.day11.compares;import java.util.ArrayList;import java.util.Collections;import java.util.List;/** * 本类用来演示: * * @author: success * @date: 2021/7/30 10:54 上午 */public class TestTeacherSort &#123; public static void main(String[] args) &#123; Teacher t1 = new Teacher(1,&quot;tom&quot;,23); Teacher t2 = new Teacher(2,&quot;jack&quot;,25); Teacher t3 = new Teacher(3,&quot;james&quot;,18); Teacher t4 = new Teacher(4,&quot;rose&quot;,17); List&lt;Teacher&gt; list = new ArrayList&lt;&gt;(); list.add(t1); list.add(t2); list.add(t3); list.add(t4);// for (Teacher teacher : list) &#123;// System.out.println(teacher);// &#125; Collections.sort(list); for (Teacher teacher : list) &#123; System.out.println(teacher); &#125; &#125;&#125; Collections java.util.Collections[C] - 集合工具类 面试题 - Collection和Collections有什么区别? static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器引起的顺序对指定的列表进行排序。 1Collections.sort(bookList,((o1, o2) -&gt; (int) (o2.getPrice()-o1.getPrice()))); static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口 HashSet Set[I]接口下的实现类 - 存储的数据是无序不可重复复的. 添加数据到容器的原理: 当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置 如果这个哈希值在这之前出现过了.产生了哈希碰撞或者哈希冲突.但是这个时候,还不能确定哈希碰撞的俩个对象是同一个对象 继续调用对象的equals方法,如果返回true,说明是同一个对象.则拒绝添加. 底层数据结构 散列表 桶数组 + 链表 + 红黑树 查看HashSet源码 Set sets = new HashSet&lt;&gt;(); 1234public HashSet() &#123; //HashSet的底层是HashMap map = new HashMap&lt;&gt;();&#125; HashSet的add方法的底层 123456789private static final Object PRESENT = new Object();//此处的e是添加到容器中的对象public boolean add(E e) &#123; //实际上还是在调用map的put方法 //HashSet中添加的对象是作为了Map集合的key //Map的key具有什么特点 = HashSet中的数据有何特点. return map.put(e, PRESENT)==null;&#125; 面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。 贪吃蛇 贪吃蛇算法 - LinkedList-操作头和尾-适合解决队列和栈列的业务题目 算法的思路蛇移动,判断方向,#### - 坐标 蛇头节点的坐标getFirst() -&gt; 移动之后的新的节点 不管新的节点是否为食物.蛇linkeList集合果断先将新的节点加入到该链表的头结点中.addFirst 判断新的节点如果是食物的节点,那么链表就不删除最后一个节点.否则删除链表的最后一个节点. TreeSet[C] 简单了解一下 Set[I] - SortedSet[I] - TreeSet[C] - 底层是TreeMap[C] - 使map集合的key根据定制的规则来进行排序. Set - 无序不可重复的. TreeSet - 不可重复的,但是可以根据定制的排序规则来进行排序. Stream java.util.stream.Stream; 它和传统的集合框架在性能上的比较.","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day10","slug":"day10","date":"2021-07-24T10:02:10.000Z","updated":"2022-01-07T08:55:44.167Z","comments":true,"path":"2021/07/24/day10/","link":"","permalink":"http://example.com/2021/07/24/day10/","excerpt":"","text":"包装类型 每个基本类型都有其对应的包装类型[对象类型] byte-&gt;Byte short-&gt;Short int-&gt;Integer long-&gt;Long float-&gt;Float double-&gt;Double char-&gt;Character boolean-&gt;Boolean 学习掌握目标 包装类型的api的常用方法 包装类型和基本数据类型以及String类型三者之间的相互转换问题. Number api:java.lang包,所有关于上面包装类型[数字]的共同的抽象的父类. byte byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。 abstract double doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。 abstract float floatValue()返回指定数字的值为 float ，可能涉及四舍五入。 abstract int intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。 abstract long longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。 short shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。 提供的这些方法都是关于包装类型转换成对应的基本类型的方法 Integer构造 Integer(int i);//利用int类型的整数来构建一个Integer对象 - int类型-&gt;Integer类型 Integer(String s);//此处的字符串一定是数字形式的字符串 - String类型-&gt;Integer类型 如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 自动解封箱 jdk5.x开始支持的新的功能 封箱 - 基本数据类型可以自动转换成对应的包装类型 解箱 - 包装类型可以自动转换成对应的基本的数据类型 常用方法 static Integer valueOf(int i);//将int-&gt;Integer 1[-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false 1234567891011121314151617181920212223//如果[-128,127]之间,那么直接返回内部的缓冲数组中的数据//如果不在这个范围,返回一个新的Integer对象public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;Integer类内部有一个静态内部类private static class IntegerCache &#123; static final int low = -128; static final int high; //缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了. static final Integer cache[]; static&#123; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334// [-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false//剖析自动封箱Integer a = 127;//Integer a = Integer.valueOf(127);Integer b = 127;System.out.println(a == b);//trueadmindeMacBook-Pro:Desktop admin$ javap -c IntegerHelloCompiled from &quot;IntegerHello.java&quot;public class IntegerHello &#123; public IntegerHello(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: bipush 127 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: bipush 127 8: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 11: astore_2 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: aload_1 16: invokevirtual #4 // Method java/lang/Integer.intValue:()I 19: bipush 7 21: if_icmpne 28 24: iconst_1 25: goto 29 28: iconst_0 29: invokevirtual #5 // Method java/io/PrintStream.println:(Z)V 32: return&#125; 关于进制转换的方法 2-1. static String toBinaryString(int n);//十进制n转换成对应的二进制 2-2. static String toHexString(int n);//十进制n转换成对应的十六进制 2-3. static String toOctalString(int n);//十进制n转换成对应的八进制 static int parseInt(String s);//将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 static Integer valueOf(String s);//String-&gt;Integer 总结 包装类型和基本数据类型以及String类型三者之间的相互转换问题. int-&gt;Integer 1231. java.lang.Integer的构造Integer(int n)2. jdk5.0提供的自动封箱Integer a = 10;3. java.lang.Integer提供的static Integer valueOf(int n); Integer -&gt; int 121. int intValue();//java.lang.Number提供的抽象方法,java.lang.Integer重写了该方法2. jdk5.0提供的自动解箱 int-&gt;String 11. java.lang.String提供的方法static String valueOf(int n); String-&gt;int 11. java.lang.Integer类static int parseInt(String s); String-&gt;Integer 121. java.lang.Integer的构造Integer(String n)2. java.lang.Integer的方法static String valueOf(String n); Integer-&gt;String 121. java.lang.Integer的String toString();2. java.lang.String中提供了static String valueOf(Object obj); 作业1 笔试题:int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 作业2 Object java.lang.Object类是所有的类的基类,根类,超类 所有的类如果没有明确指定父类,都会默认继承Object类. equals boolean equals(Object obj);//对象之间的比较.默认仍然使用的是== “业内认可的一种说法” - 基本类型用==比较的值,对象类型用==比较的是地址 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 默认的比较方式不符合实际的业务需要,因此需要重写equals方法 success版本 12345678910111213141516171819202122 @Overridepublic boolean equals(Object obj)&#123; //1. 非空性 if(obj == null) return false; //2. 自反性 if(this == obj)//p1.equals(p1) return true; //3. 一致类型,判断具体的哪个属性是一致的,才认为返回true // p1.equals(user); if(obj instanceof Product)&#123; Product p = (Product) obj; //return this.id == p.id; //id和name都一致的时候,才认为是同一个对象 //return (this.id == p.id) &amp;&amp; (this.name.equals(p.name)); //需求 - 认为产品的id以及这个产品对应的产品信息的id一致的时候认为返回true return this.id == p.id &amp;&amp; this.getProductInfo().equals(p.productInfo); &#125; return false;&#125; hashCode方法 int hashCode();//返回对象的哈希值.一般是和equals方法是成对出现的.目的是为了提高性能. 容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法 而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间] 关于数字31 - 质数 - 1. 尽可能产生更多的哈希值 2. 让哈希碰撞/冲突尽可能少. 1234567@Overridepublic int hashCode() &#123; int result = id != null ? id.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (productInfo != null ? productInfo.hashCode() : 0); return result;&#125; 超前知识点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package tech.aistar.day10.hashcodes;import java.util.HashSet;import java.util.Set;/** * 本类用来演示: * * @author: success * @date: 2021/7/28 2:01 下午 */public class TestCourse &#123; public static void main(String[] args) &#123; Course c1 = new Course(1,&quot;java&quot;); Course c2 = new Course(2,&quot;mysql&quot;); Course c3 = new Course(3,&quot;mysql&quot;); Course c4 = new Course(4,&quot;mysql&quot;); Course c5 = new Course(5,&quot;mysql&quot;); Course c6 = new Course(1,&quot;oracle&quot;);// System.out.println(c1 == c2);//false// System.out.println(c1.equals(c2));//true //集合 - &quot;容器&quot;,比数组更加强大的. //集合 - 里面存储的数据是无序不可重复的 //不能存储同一个对象 Set&lt;Course&gt; sets = new HashSet&lt;&gt;(); //1. 当把某个对象放入到该容器之前,先调用了该对象的hashCode方法,得到一个哈希值 //2. 根据这个哈希值就可以被分配一个内存地址 //3. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用.那么就会直接将该对象放入到 // 这个哈希值对应的在容器中的那个位置 //4. 如果这个哈希值在这之前出现过.但是此时还不能说明这个对象和之前的那个对象是同一个对象? // 因为哈希值是通过哈希算法计算得到的,可能产生&quot;哈希冲突&quot; - &quot;哈希碰撞&quot; //5. 当哈希值一样的时候,那么才会去调用equals方法,如果equals方法仍然返回true,那么才 // 最终确定这个对象曾经出现过,那么就拒绝添加. sets.add(c1); sets.add(c2); sets.add(c3); sets.add(c4); sets.add(c5); sets.add(c6); for (Course c : sets) &#123; System.out.println(c); &#125; &#125;&#125; 总结 如果俩个对象的hashcode值一样,那么equals比较,不一定返回true 如果俩个对象equals返回true,那么这俩个对象的哈希值必须要一样 - 数据的完整性. 笔试题 == 和 equals的区别 == 基本类型使用,比较的就是基本类型的数值 equals 对象类型使用.如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. clone方法 protected Object clone();//默认的克隆方法是浅克隆 浅克隆 浅拷贝,浅层复制,浅复制 - 默认的. protected - public 123456@Overridepublic Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125;Object中的clone方法 - native修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.protected native Object clone() throws CloneNotSupportedException; 只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常. 123456Product copy = (Product) p1.clone();Product copy2 = new Product(1,&quot;mac&quot;,1000.0d);为什么需要使用clone,而不直接new一个.clone方法它直接操作的堆里面的内存 - 效率是高于重新new的. 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.day10.obj;/** * 本类用来演示: * * @author: success * @date: 2021/7/28 2:32 下午 */public class TestCloneDemo &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac&quot;,1000.0d); ProductInfo info = new ProductInfo(1,&quot;good&quot;); p1.setProductInfo(info); //System.out.println(p1 instanceof Cloneable);//true try &#123; //浅拷贝 Product copy = (Product) p1.clone(); //1. 修饰基本数据类型以及字符串 - 原来的对象 - 是否对copy对象产生影响 - 不会 p1.setId(10); p1.setName(&quot;tom&quot;); //2. 修改对象类型 - 会对copy的对象产生影响的 p1.getProductInfo().setId(100); p1.getProductInfo().setInfo(&quot;bad&quot;); System.out.println(copy); System.out.println(copy.getProductInfo()); //System.out.println(copy == p1);//false &#125; catch (CloneNotSupportedException e) &#123;//不能被克隆的异常 e.printStackTrace(); &#125; &#125;&#125; 深克隆 深层复制,深拷贝,深复制 - 需要自己重写clone里面的具体的代码的 123456789101112131415161718192021222324 /** * 深拷贝 - 修改原来对象中的任何类型的数据都不会对副本对象产生影响 * @return * @throws CloneNotSupportedException */@Overridepublic Object clone() throws CloneNotSupportedException &#123; //Product copy = (Product)p1.clone(); //手动新建一个Product对象 Product product = new Product(); product.setId(id); product.setName(name); product.setPrice(price); ProductInfo infos = getProductInfo(); if(infos!=null)&#123; ProductInfo pi = new ProductInfo(); pi.setId(infos.getId()); pi.setInfo(infos.getInfo()); product.setProductInfo(pi); &#125; return product;&#125; 集合框架 就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用. 结构123456789101112131415api:java.util Collection[I] - List[I] - 有序可重复 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射的对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I] 特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C] 特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低. 分析源码123456789101112131415161718192021222324252627282930 /** * 默认的初始的容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//就是真正的存储数据的数组transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;//构造public ArrayList() &#123; //1. 初始化elementData,长度为0 //2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //this.elementData = &#123;&#125;&#125; 剖析add方法 ArrayList扩容的原理 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 扩容方法 123456789private void ensureCapacityInternal(int minCapacity) &#123;//第一次进来1 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;//true //第一次minCapacity = 10 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 继续ensureExplicitCapacity(minCapacity); 12345678private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //第一次进来10-0&gt;0 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; grow(minCapacity) 123456789101112131415private void grow(int minCapacity) &#123; // 第一次 //oldCapacity = 0 //newCapacity = 0 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//1.5倍 if (newCapacity - minCapacity &lt; 0)//第一次会进来 newCapacity = minCapacity;//newCapacity = 10 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历 直接输出 增强for循环 - 只读 1234567891011121314151617181920212223242526272829只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常 实际的底层,调用迭代器对象中的next方法 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public E next() &#123; checkForComodification(); //.... &#125; final void checkForComodification() &#123; //modCount是当初调用add方法,添加1个元素,modCount自增1个 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 发现只要调用了remove方法 - modCount++ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day09","slug":"day09","date":"2021-07-23T10:02:10.000Z","updated":"2022-01-07T06:46:52.133Z","comments":true,"path":"2021/07/23/day09/","link":"","permalink":"http://example.com/2021/07/23/day09/","excerpt":"","text":"java.lang.String Java中提供的处理字符串的类. 不可变的字符串 12String s = &quot;abc&quot;;s = &quot;eef&quot;;//ok,&quot;abc&quot;就变成了垃圾对象. 字符串本质上就是一个字符数组 12345678//final修饰的类不可被继承public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //维护的是不可变的字符数组 //String s = &quot;abc&quot;;//将&quot;abc&quot;打散,保存成value[]数组中. private final char value[]; &#125; 字符串构建的方式 通过new关键字来构建 12345//创建了几个对象?//1个或者2个//①通过new关键字在堆里面创建一个字符串对象&quot;abc&quot;//②同时在&quot;串池&quot;里面扔一个对象&quot;abc&quot;[前提是串池中之前不存在&quot;abc&quot;]String s1 = new String(&quot;abc&quot;); 直接通过”串池”/“字符串常量池”的方式来构建 12345678//创建了几个对象? //它会在&quot;串池&quot;中创建一个&quot;abc&quot;字符串对象,然后将地址给了s1String s1 = &quot;abc&quot;;//&quot;串池&quot;中的特点:优先先到串池中查找是否已经存在&quot;abc&quot;对象,如果有直接返回地址给s2//否则才会继续创建新的字符串对象String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true 关于字符串的拼接 字符串的拼接使用+,但是使用+的拼接效率非常低. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package tech.aistar.day09;import java.util.Date;/** * 本类用来演示: 字符串拼接效率低 * * @author: success * @date: 2021/7/27 2:15 下午 */public class StringPlusDemo &#123; public static void main(String[] args) &#123; test02();//append test01();//+ &#125; public static void test01()&#123; long t1 = System.currentTimeMillis();//获取当前系统时间的毫秒数 String str = &quot;&quot;; for (int i = 0; i &lt; 100000; i++) &#123; str+=i;//str = str + i; &#125; long t2 = System.currentTimeMillis(); System.out.println(&quot;str拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; public static void test02()&#123; //java.lang.StringBuilder StringBuilder builder = new StringBuilder(); long t1 = System.currentTimeMillis();//获取当前系统时间的毫秒数 for (int i = 0; i &lt; 100000; i++) &#123; builder.append(i);//拼接方式 &#125; long t2 = System.currentTimeMillis(); System.out.println(&quot;append拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125;&#125; 拼接效率的原因 +底层每次都会产生一个StringBuilder对象 +底层仍然是调用StringBuilder中的append方法 1234567891011121314151617181920212223242526字符串使用+拼接的过程中,会产生新的对象 - 拼接效率低String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); admindeMacBook-Pro:Desktop admin$ javap -c HelloStrCompiled from &quot;HelloStr.java&quot;public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 放在了&quot;串池中&quot; 2: astore_1 3: new #3 // class java/lang/String 6: dup // &quot;abc&quot; -&gt; 堆里面 7: ldc #2 // String abc &quot;串池中已经出现了&quot; 9: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: astore_2 13: return&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041String s1 = &quot;abc&quot;;String s2 = new String(&quot;def&quot;);s1 = s1 + s2;//会产生一个新的对象admindeMacBook-Pro:Desktop admin$ javap -c HelloStrCompiled from &quot;HelloStr.java&quot;public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 2: astore_1 3: new #3 // class java/lang/String 6: dup 7: ldc #4 // String def 9: invokespecial #5 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: astore_2 13: new #6 // class java/lang/StringBuilder //字符串每次拼接+,都会产生一个新的StringBuilder对象 16: dup 17: invokespecial #7 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V //StringBuilder builder = new StringBuilder(); 20: aload_1 21: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; //字符串的+,底层仍然是去调用StringBuilder类中提供的append方法 24: aload_2 25: invokevirtual #8 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: return&#125; 字符串的比较1234567891011121314151617181920212223242526272829303132333435363738394041424344package tech.aistar.day09;/** * 本类用来演示: 字符串的各种比较 * * @author: success * @date: 2021/7/27 2:35 下午 */public class StringCompare &#123; public static void main(String[] args) &#123; //s1默认指向的是堆里面的字符串对象 String s1 = new String(&quot;abc&quot;); String s2 = &quot;abc&quot;; System.out.println(s1 == s2);//false //intern()强制让s1指向串池的对象 System.out.println(s1.intern() == s2);//true String s3 = &quot;b&quot;; String s4 = &quot;a&quot; + s3;//产生一个StringBuilder对象 String s5 = &quot;a&quot; + &quot;b&quot;;//因为此处的&quot;a&quot;和&quot;b&quot;就是字符串常量 //jvm对待字符串常量的拼接 - &quot;a&quot;和&quot;b&quot;的拼接 //当成&quot;ab&quot;的整体,直接扔到常量池中. System.out.println(s4 == s5);//false //字符串使用final修饰 final String s6 = &quot;b&quot;; //&quot;a&quot;+s6 =&gt; &quot;ab&quot;扔到常量池,没有产生新的对象. String s7 = &quot;a&quot; + s6; System.out.println(s5 == s7);//true String x1 = new String(&quot;abc&quot;); String x2 = new String(&quot;abc&quot;); System.out.println(x1 == x2);//false System.out.println(x1); //希望字符串的值是一样的,就希望返回true System.out.println(x1.equals(x2));//true &#125;&#125; 字符串常用方法 构造方法 String(); String(String val); String(StringBuilder builder);//StringBuilder对象转换成String对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package tech.aistar.day09;/** * 本类用来演示: 字符串常用方法 * * @author: success * @date: 2021/7/27 3:02 下午 */public class StringMethod &#123; public static void main(String[] args) &#123; String s = new String(&quot;abc&quot;); // java.lang.StringIndexOutOfBoundsException System.out.println(s.charAt(1));//b System.out.println(s.length());//3 String result = s.concat(&quot;de&quot;);//原来的字符串的末尾添加新的字符串 System.out.println(result);//abcde //判断字符串中是否包含某个序列 System.out.println(s.contains(&quot;bc&quot;));//true //判断前缀或者后缀 System.out.println(&quot;xxx.gif&quot;.endsWith(&quot;.gif&quot;));//true System.out.println(&quot;javaScript&quot;.startsWith(&quot;java&quot;));//true System.out.println(&quot;abc&quot;.equals(s));//true //忽略大小写的比较 System.out.println(&quot;ABc&quot;.equalsIgnoreCase(&quot;abc&quot;));//true //转换大写和小写 System.out.println(&quot;abc&quot;.toUpperCase());//ABC System.out.println(&quot;ABC&quot;.toLowerCase());//abc //返回指定字符第一次出现的字符串内的索引。 System.out.println(&quot;abcabc&quot;.indexOf(&quot;b&quot;));//1 System.out.println(&quot;abcabc&quot;.lastIndexOf(&quot;b&quot;));//4 //判断字符串是否为空 System.out.println(&quot;&quot;.isEmpty());//长度为0的字符串 - 返回true //替换 System.out.println(&quot;I Love Girl&quot;.replace(&quot;Girl&quot;,&quot;Java&quot;)); //字符串的切割 String ip = &quot;192:168:3:90&quot;; String[] arr = ip.split(&quot;\\\\:&quot;); for (String s1 : arr) &#123; System.out.println(s1); &#125; //将字符串转换成char类型数组 char[] arr2 = &quot;白日依山尽&quot;.toCharArray(); for (char c : arr2) &#123; System.out.println(c); &#125; String x1 = &quot;abcde&quot;; String x2 = x1.substring(1,3);//[1,3) System.out.println(x2); System.out.println(x1.substring(1));//从1一直截取到最后bcde //trim() - 去除字符串左右两边的空格 System.out.println(&quot; ab c &quot;.trim().length());//4 System.out.println(&quot; &quot;.trim().length());//0 //int-&gt;String String o = String.valueOf(10); System.out.println(o+10); &#125;&#125; java.lang.StringBuilder 它是一个可变的字符串 - final修饰,性能最高的.默认的容量16.线程不安全的 StringBuilder(); StringBuilder(String val);//String类型转换成StringBuilder类型 扩容机制 研究append方法 12345678910111213141516171819202122232425262728293031323334353637StringBuilder x = new StringBuilder(&quot;abc&quot;);x.append(&quot;def&quot;);StringBuilder类的父类AbstractStringBuilder public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length();//len = 3 //count+len //count - 原来数组中已经存在的字符的长度 //len - 需要存入的新的字符串长度 ensureCapacityInternal(count + len);//3 str.getChars(0, len, value, count); count += len; return this;&#125;扩容方法 private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) expandCapacity(minimumCapacity);&#125;//真正的扩容方法void expandCapacity(int minimumCapacity) &#123; int newCapacity = value.length * 2 + 2;//扩容,得到新的长度 if (newCapacity - minimumCapacity &lt; 0)//扩容得不够,不够长 newCapacity = minimumCapacity;//直接补充到最长的. if (newCapacity &lt; 0) &#123;//长度会溢出. if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; &#125; value = Arrays.copyOf(value, newCapacity);&#125; 常用方法123456789101112131415161718192021222324252627282930313233343536package tech.aistar.day09;/** * 本类用来演示: 常用方法 - 可变的字符串 * * @author: success * @date: 2021/7/27 4:20 下午 */public class StringBuilderMethod &#123; public static void main(String[] args) &#123; StringBuilder x = new StringBuilder(&quot;abcd&quot;);//String-&gt;StringBuilder System.out.println(x); StringBuilder result = x.delete(1,3);//[1,3) System.out.println(&quot;result:&quot;+result);//ad System.out.println(&quot;x:&quot;+x);//ad System.out.println(x.deleteCharAt(0));//d 根据下标进行删除操作 x.insert(0,&quot;管管&quot;); System.out.println(x);//管管d //反转字符串 System.out.println(x.reverse());//d管管// int n = 6723;// System.out.println(String.valueOf(n).length());//// StringBuilder y = new StringBuilder(String.valueOf(n));// System.out.println(y.reverse()); //StringBuilder-&gt;String System.out.println(x.toString()); &#125;&#125; 总结 String类型和StringBuilder类型之间的相互转换问题 StringBuilder-&gt;String类型 java.lang.StringBuilder中提供的String toString(); java.lang.String类中提供的构造方法String(StringBuilder builder); java.lang.String类中提供的static String valueOf(Object obj);//面向父类编程 String-&gt;StringBuilder java.lang.StringBuilder中提供的构造StringBuilder(String val); java.lang.StringBuffer 它的使用方式和StringBuilder是一模一样的.唯一区别是它是多线程安全的.可变的字符串 因为它里面的方法都使用synchronized关键字进行了修饰,重量级的对象. 性能低于StringBuilder 笔试题 String,StringBuilder,StringBuffer三者的区别? - 查,补充完整 - 作业 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String 作业 两道笔试题 1234567//从oldStr中删除指定的target字符串//比如&quot;abcdebcef&quot;,&quot;bc&quot; -&gt; 返回&quot;adeef&quot;//禁止使用replace方法//递归算法public static String delByStr(String oldStr,String target)&#123; &#125; 12345//找出俩个字符串中的最大长度的公串//abcbcedfdfdepopoqqq//fdfdbcbceoifdfdeqqa//bcbce fdfde","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day08","slug":"day08","date":"2021-07-22T10:02:10.000Z","updated":"2022-01-07T06:46:31.225Z","comments":true,"path":"2021/07/22/day08/","link":"","permalink":"http://example.com/2021/07/22/day08/","excerpt":"","text":"static关键字 static修饰的成员是在JVM加载类的时候就会被立即分配空间以及初始化 - 只有1次,内存的实例只有1份 非静态的成员的是在每次创建对象的时候才会被分配空间以及初始化 作用 static修饰符类 - 静态内部类[过] 修饰的属性 - 静态属性 方法 - 静态方法 代码块 - 静态代码块 JVM加载类进内存的活动顺序 JVM加载类进内存 给所有的静态属性分配空间以及初始化 给所有的静态方法分配空间以及初始化 调用静态代码块 如果创建了对象 4-1. 给这个对象的所有的非静态属性分配空间以及初始化 4-2. 给这个对象的所有的非静态方法分配空间 4-3. 调用普通代码块 4-4. 调用构造块 static关键字应用 设计模式 - 单例模式 如何保证某个类的对象在内存中永远只有1份.后期,某些类的创建和销毁的时间成本比较高.这些类有必要设计成单例的. 比如jdbc中的连接池对象[重量级的对象] 饿汉模式 多线程安全12345678910111213141516171819202122232425262728293031package tech.aistar.design.singleton.version01;/** * 本类用来演示: 将Singleton01设置成饿汉模式 - 单例的 * * @author: success * @date: 2021/7/27 9:28 上午 */public class Singleton01 &#123; //2. 初始化一个变量,该变量就是该类的唯一实例[对象] private static Singleton01 instance = new Singleton01(); //1. 私有化构造 private Singleton01()&#123; //比较费时费力的代码,可能需要更多的时间 System.out.println(&quot;Singleton01...&quot;); &#125; //3. 提供一个公开的静态的方法来返回这个类的唯一实例 public static Singleton01 getInstance()&#123; return instance; &#125;&#125;class TestSingleton01&#123; public static void main(String[] args) &#123; //获取类的实例 Singleton01 s1 = Singleton01.getInstance(); Singleton01 s2 = Singleton01.getInstance(); System.out.println(s1 == s2);//true &#125;&#125; 懒汉模式 多线程不安全123456789101112131415161718192021222324252627package tech.aistar.design.singleton.version02;/** * 本类用来演示: 懒汉 * * @author: success * @date: 2021/7/27 9:35 上午 */public class Singleton02 &#123; private static Singleton02 instance; private Singleton02()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton02 getInstance()&#123; return instance == null?instance = new Singleton02():instance; &#125;&#125;class TestSingleton02&#123; public static void main(String[] args) &#123;// Singleton02 s1 = Singleton02.getInstance();// Singleton02 s2 = Singleton02.getInstance();// System.out.println(s1 == s2); &#125;&#125; 双重检查锁 - 笔试脱手写的版本 懒汉模式下 - 仍然是多线程安全的 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - 笔试脱手写的版本 * * @author: success * @date: 2021/7/27 10:07 上午 */public class Singleton03 &#123; private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125; volatile 可见性 - 忽略 禁止JVM的指令重排 12345678910int i=10;//原子性操作 Student s = new Student();//不是一个原子性操作①给s对象分配内存空间②调用构造块,执行构造函数 - 初始化动作③将引用s指向内存中的那个对象. 但是JVM内部会对这些指令进行一个优化操作.本来你的顺序应该是①-②-③,经过JVM指令重排之后,顺序有可能变成①-③-② 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - 笔试脱手写的版本 * * @author: success * @date: 2021/7/27 10:07 上午 */public class Singleton03 &#123; private volatile static Singleton03 instance; //private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //② - 跑得很慢的线程刚刚到达此处,其他线程判断instance是不为null的 //但是instance可能指向的是一个&quot;半成品&quot; - A线程还没有完成构造方法. //其他线程可能会使用到这个&quot;半成品&quot;对象,肯定会有问题. if(instance == null)&#123; synchronized (Singleton03.class)&#123; if(instance == null)&#123; //① - A线程可能执行到2步骤的时候,instance已经不为null //不是一个原子性操作,可能经过JVM指令重排 //1. 给instance对象分配空间 //2. 将对象的内存地址赋值给了instance //3. 调用构造方法 instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day07","slug":"day07","date":"2021-07-21T10:02:10.000Z","updated":"2022-01-07T06:46:10.979Z","comments":true,"path":"2021/07/21/day07/","link":"","permalink":"http://example.com/2021/07/21/day07/","excerpt":"","text":"抽象类 抽象类天生就是用来被子类继承的.抽象类天生就是不能够被外部进行实例化的 抽象类使用abstract关键字来进行修饰 抽象类中允许存在构造方法,普通属性,普通方法以及抽象方法. 普通类是没有资格去定义抽象方法 抽象方法也是使用abstract来修饰的,抽象方法是指没有方法体的方法. 抽象的方法天生也是用来被子类重写的. 抽象类是一种抽象的数据类型. 抽象类的继承的特点 如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中的所有的抽象方法. 如果某个子类继承了抽象类,不想重写抽象父类中的所有的抽象方法,那么需要将这个子类也定义成抽象类. 不能一起混用的修饰符 final和abstract一起使用 private和abstract能不能一起修饰方法. static和abstract不能一起用来修饰方法 static是不存在多态的. 模板方法设计模式 模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。即：处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。处理步骤在父类中定义好，具体实现延迟到子类中定义 。 抽象的类应用 - 模板方法设计模式. 模板类中只负责定义 需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现. 做的事情的流程[步骤] 123456789101112131415161718192021222324package tech.aistar.design.template;/** * 本类用来演示: * * @author: success * @date: 2021/7/23 9:36 上午 */public abstract class TemplateDemo &#123; //规定了需要完成的事情 public abstract void start();//演员登台 public abstract void play();//演员表演 public abstract void end();//落幕 //提供一个不可变的方法,用来控制事情执行的顺序 public final void execute()&#123; this.start(); this.play(); this.end(); &#125;&#125; 缺点模板方法的优点和缺点： 优点： 模板方法提供了一个很好的代码复用平台。 实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，符合 “开闭原则”。 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 接口 属于抽象的数据类型,也是不能够被实例化的 接口中不允许定义普通属性的,不允许出现构造的. jdk8.x允许在接口中使用default关键字来定义普通方法. 接口也是用来定义抽象的方法的.接口中的方法都是抽象的方法. 接口的属性都是公开的静态的常量属性. 定义接口的关键字是interface,编译之后也是.class字节码文件 接口也是可以静态方法的. 命名规则 使用I开头或者able结尾 多态的另外应用 面向接口编程 对象的编译时类型写成接口,对象的运行时类型写成是实现类 方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类. 方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类. 接口的规则 接口和类 - 类是可以去实现这个接口的. 接口天生是用来是实现类来实现的 - implements 普通的类去实现某个接口的话,那么必须要实现这个接口中所有的抽象方法 如果抽象的类去实现某个接口的话,那么可以选择实现或者不实现. 一个接口可以拥有多个实现类. 一个类可以同时实现多个接口,接口之间用逗号隔开.需要实现这些接口中所有的抽象方法. 接口和接口 一个接口可以继承多个接口,接口是支持多重继承的. 应用 提供了一种”契约机制”,屏蔽了底层的具体的实现,为了程序的拓展 作用 - 制定开发的这个软件中的功能 - “业务方法” 接口的分类 业务接口 - 该接口中只定义抽象方法 常量接口 - 该接口中只定义了常量属性,管理系统中所有的常量属性的.jdk5.x使用了枚举类型来替代了常量接口 标记接口 - 什么都没有,做标记的. 123456public interface IA&#123;&#125;public class Aimpl implements IA&#123;...&#125;Aimpl a = new Aimpl();System.out.println(a instanceof IA);//true 函数式接口 - jdk8.x - 配合jdk8.x - lambda表达式 里面只有一个抽象方法的接口 - @FunctionalInterface 设计模式概述设计模式概念设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 七大原则为什么要提倡“Design Pattern”呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。 单一职责原则简介:单一职责原则（Single Responsiblity Principle SRP） 接口或类只提供一种业务实现。单一职责原则宗旨是每个接口、类的功能，只能用来做专门的事，强调系统内业务职责唯一，避免职责扩散，做到业务统一管理. 开闭原则简介:总原则:开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代 码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 里氏替换原则简介:里氏替换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实 现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 依赖倒转原则简介:依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则简介:接口隔离原则（Interface Segregation Principle） 这个原则的意思是：每个接口中不存在实现类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 迪米特法则简介:迪米特法则（最少知道原则）（Demeter Principle) 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部 变量出现在类中。 合成复用原则简介:合成复用原则（Composite Reuse Principle) 原则是尽量首先使用合成/聚合的方式，而不是使用继承。 简单工厂模式简单工厂模式是属于创建型模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 作用:把对象的创建和对象的使用分离 User user = new User();//对象的创建和对象使用没有分离 普通简单工厂 - 必须要脱手写出来的.1234567891011121314151617181920212223242526272829303132333435//1. 根据传入的参数来返回某个具体的产品[对象]package tech.aistar.design.factory.simple01;/** * 本类用来演示: 简单工厂 * * @author: success * @date: 2021/7/23 3:19 下午 */public class ProductFactory &#123; public static final int QQ = 1; public static final int WX = 2; //根据传入的参数来返回某个具体的产品 //多态的应用 - 面向接口编程 //3. 方法的返回类型写成接口,方法的执行结果可以是这个接口的任意一个实现类. public static Sender getInstance(int type)&#123; Sender sender = null; switch (type)&#123; case 1: //对象的创建 - 复杂的过程... sender = new QQSender(); break; case 2: sender = new WXSender(); break; default: System.out.println(&quot;参数不合法&quot;); break; &#125; return sender; &#125;&#125; 多方法简单工厂1234567891011121314151617181920package tech.aistar.design.factory.simple02;/** * 本类用来演示: 多方法工厂 * * @author: success * @date: 2021/7/23 3:32 下午 */public class ProductFactory &#123; //有几个产品,就定义几个方法 //每个方法负责生成一个产品 public Sender createQQ()&#123; return new QQSender(); &#125; public Sender createWx()&#123; return new WXSender(); &#125;&#125; 静态方法简单工厂1234567891011121314151617181920package tech.aistar.design.factory.simple02;/** * 本类用来演示: 多方法工厂 * * @author: success * @date: 2021/7/23 3:32 下午 */public class ProductFactory &#123; //有几个产品,就定义几个方法 //每个方法负责生成一个产品 public static Sender createQQ()&#123; return new QQSender(); &#125; public static Sender createWx()&#123; return new WXSender(); &#125;&#125; 简单工厂优缺点优点： 很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。 缺点： 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。 工厂方法模式简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能， 直接增加新的工厂类就可以了，不需要修改之前的代码。 工厂方法模式优缺点优点： 工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1） 同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，使得工厂类符合开闭原则。 缺点： 相比简单工厂，实现略复杂。 对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。 抽象工厂模式抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。 抽象工厂模式优缺点优点： 抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 ​ 缺点： 增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。 作业 循环 OO题 123456789101112131415161718192021222324Book[id,name,price...]1.定义图书操作业务接口 IBookBiz有如下方法://添加图书 void add(Book b);//根据图书name 来删除指定图书 void deleteByName(String name);//打印出所有的图书信息 void outputAllBooks();2. 定义 数组图书管理业务实现类(ArrayBookBiz) 实现 IBookBiz接口，实现所有方法,提示，给出如下属性属性:private static final int CAPACITY = 5;private int count; //代表有效图书数量private Book[] books = new Book[CAPACITY];方法： 就是实现接口中的所有方法最后，写测试类，测试这三个方法. 接口练习题 12345678910111213141516171819202122232425接口更重要的作用：作为模块与模块之间一个协议，软件生产一直希望能够像硬件生产一样：主板可由一个厂家生产，显卡可由另一个厂家生产，用户只需要将显卡插到主板上的显卡插槽上，便可以协同工作了。（插槽——主板、显卡的标准接口已经确定，插槽就是接口）。显卡厂商去实现接口中所暴露出来的方法。主板只需要利用显卡的插槽去获取（调用）显卡的功能。1、 定义一个显卡接口VideoCard，此接口中有抽象方法： 1） videoRunning()：显示显卡运行信息 ; 2） videoClosing()：显示显卡停止工作时的信息;2、 定义一个芯片接口Cpu,此接口中有抽象方法： 1） cpuRunning()：显示显卡运行信息 ; 2） cpuClosing()：显示显卡停止工作时的信息;3、 定义类IntelCpu：实现Cpu接口的全部功能，其中包括： 1） 无参构造方法：显示：” Make an Intel&#x27;s CPU”. 2） 实现Cpu接口的所有方法4、 定义类DmengVideoCard：实现VideoCard接口的全部功能，其中包括： 1） 无参构造方法：显示：”Make a Dmeng&#x27;s VideoCard”. 2） 实现VideoCard接口的所有方法.5、 定义类Mainboard 1） 创建有参构造体，传入显卡和芯片 2） run():显示主板运行信息 3） close():显示主板停止信息6、 定义一个Computer类，包含主函数main(),组装一台电脑，测试接口的应用，其中main()方法包括： 1） 买一块Dmeng公司的显卡 2） 买一块Intel公司的芯片 3） 买一块主板:插上显卡、芯片 4） 组装好后，开机运行显示显卡、芯片、主板等开机信息。 5） 关机信息显示 6） 创建openPC方法，打开电脑。 7） 创建closePC方法，关闭电脑。 预习题 - static关键字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218 1. public class Cygnus&#123; static int value = 9; private void printValue()&#123; int value = 69; System.out.println(this.value); &#125; public static void main(String[] args) throws Exception&#123; new Cygnus().printValue(); &#125; &#125; 这个程序会有下面哪种结果？ A. 编译错误 B. 打印9 C. 打印69 D. 运行时抛出异常--------------------------------------------------------------------------------------- 2. 写出以下程序的输出结果 class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125; &#125; public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; super(); System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125; &#125;--------------------------------------------------------------------------------------- 3. 写出以下程序的输出结果 public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125; &#125; --------------------------------------------------------------------------------------- 4. public class test&#123; static&#123; int x=5; &#125; static int x,y; public static void main(String args[])&#123; x--; myMethod( ); System.out.println(x+y+ ++x); &#125; public static void myMethod( )&#123; y=x++ + ++x; &#125; &#125; A. 编译错误 B. 输出：1 C. 输出：2 D. 输出：3 E. 输出：7 F. 输出：8 --------------------------------------------------------------------------------------- 5. 阅读下列程序，选择哪一个是正确的输出结果 class HelloA&#123; public HelloA() &#123; System.out.println(&quot;I’m A class &quot;); &#125; static&#123; System.out.println(&quot;static A&quot;); &#125; &#125; public class HelloB extends HelloA&#123; public HelloB()&#123; System.out.println(&quot;I’m B class&quot;); &#125; static&#123; System.out.println(&quot;static B&quot;); &#125; public static void main (String[] args)&#123; new HelloB(); &#125; &#125; A. static A I’m A class static B I’m B class B. I’m A class I’m B class static A static B C. static A static B I’m A class I’m B class D. I’m A class static A I’m B class static B --------------------------------------------------------------------------------------- 6. 以下代码的输出结果是？ public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println(&quot;构造块&quot;); &#125; static&#123; System.out.println(&quot;静态块&quot;); &#125; public static void main(String[] args)&#123; B t = new B(); &#125; &#125; A. 静态块 构造块 构造块 构造块 B. 构造块 静态块 构造块 构造块 C. 构造块 构造块 静态块 构造块 D. 构造块 构造块 构造块 静态块 --------------------------------------------------------------------------------------- 7. 下面代码在main方法代码后可以正常使用的是（ ） public class Test&#123; private int a=10; int b=20; static int c=1; public static void main(String arg[])&#123; Test t = new Test(); &#125; &#125; A. t.a B. this.c C. Test.b D. Test.c --------------------------------------------------------------------------------------- 8. 下列程序执行后结果为( ) class A &#123; public int func1(int a, int b) &#123; return a - b; &#125; &#125; class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125; &#125; public class ChildClass &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); System.out.println(&quot;Result=&quot; + a.func1(100, 50)); System.out.println(&quot;Result=&quot; + b.func1(100, 50)); &#125; &#125; A. Result=150Result=150 B. Result=100Result=100 C. Result=100Result=150 D. Result=150Result=100 --------------------------------------------------------------------------------------- 9. 以下代码执行后输出结果为（ ） public class Test&#123; public static Test t1 = new Test(); &#123; System.out.println(&quot;blockA&quot;); &#125; static&#123; System.out.println(&quot;blockB&quot;); &#125; public static void main(String[] args)&#123; Test t2 = new Test(); &#125; &#125; A. blockAblockBblockA B. blockAblockAblockB C. blockBblockBblockA D. blockBblockAblockB","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day06","slug":"day06","date":"2021-07-20T10:02:10.000Z","updated":"2022-01-07T06:45:51.279Z","comments":true,"path":"2021/07/20/day06/","link":"","permalink":"http://example.com/2021/07/20/day06/","excerpt":"","text":"OO练习业务类和实体类合二为一 居然将业务方法放在了实体类中 - 违背了设计原则 - “单一职责原则”.不要给一个类增加太多的负担 实体类 - 主要是描述对象,数据在内存中的载体 - 注重的应该是数据的存储 业务类 - 存放的是业务方法 - 在于操作这些数据 员工类[编号id,姓名name,工资salary] 业务方法[crud增删改查]放在实体类中 - 不合理的. 1234567891011121314151617181920212223242526272829303132333435public class Emp&#123; private int id; private String name; private double salary; //一个上司拥有多个下属 //一个下属对应一个上司 //自关联 private Emp[] emps; //构造,getter/setter,toString //给上司添加一个下属 public void addEmp(Emp e)&#123; //数组的扩容Arrays.copyOf(数组对象,新的长度); &#125; //输出下属的个数 public void printEmpCount()&#123; &#125; //输出某个上司所有的下属信息 public void printEmp()&#123; &#125;&#125;//TestEmp.javaEmp boss = new Emp(1,&quot;boss&quot;,100.0,new Emp[0]);Emp e1 = new Emp(1,&quot;boss&quot;,100.0,null); 业务类和实体类分开 业务方法应该专门抽取出来放到一个业务类中. 1234567public class Account&#123; private int id; private double balance;//余额 //...&#125; 123456789public class AccountBiz&#123; //转钱 public void test01(Account acc1,Account acc2,double money)&#123; &#125; //存钱&#125; 继承Inheritance 将多个具有共同特点的对象抽象出一个”父类”. 父类中存储的是各个子类共同的特点[属性]或者功能[方法] 继承的好处 - 提高了代码的复用性.使用多态的前提,为了代码的可拓展性. 继承的缺点 - 增加了类与类之间的关系.不太符合软件的设计原则”高内聚,低耦合” ​ 低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 没有关系 ​ 高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强. ​ 实际开发中,可以采用设计原则**”合成复用原则”** - 来替代继承的使用. 使用extends关键字来表示某个类继承某个父类 比如: 1234567891011121314public class A&#123; &#125;public class B extends A&#123; &#125;B 是 A的子类,A是B的父类,基类,超类.1. A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父类是谁,那么这个类默认继承Object2. 子类是可以访问到父类中所有的非私有的成员3. java的类只支持单继承.一个类只能继承一个父类.避免出现网状结构,保证类的层次性. java中的接口是支持多重继承.一个接口可以继承多个接口.4. 继承具有传播性.C extends B B extends A C间接继承于A,C也是可以访问到A中的所有的非私有的成员5. 不要滥用继承,前提B is A super关键字 必须放在构造方法的首行 调用父类的构造 在子类的构造中,如果没有出现任何的super语句.那么系统默认会给定super(); - 调用父类的空参构造 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员] 多态 - polymorphism 对象有多种形态.发生前提是具有继承关系 相同的消息可能会送给多个不同的类别之对象， 而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作。 instanceof 进行类型的判断,只有为true的时候,才能够进行类型的转换[强制,向下] 如果没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常 三种场景应用 面向父类编程 对象的编译时类型写成父类,对象的运行时类型写成子类 编译时类型 对象名 = new 运行时类型(); 对象的编译时类型决定了对象的访问能力 - “对象名只能访问到编译时类型中定义的成员” 对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法” 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象 - “简单工厂设计模式” final关键字 不可更改,不可变 final修饰的变量/属性 - 不能够重新赋值 final修饰的类 - 不能够被继承 final修饰的方法不能够被重写. 修饰符 访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[可以不同,同包] 同包 本类 public 公共的,公开的 √ √ √ √ protected 受保护的 × √ √ √ 默认的 × × √ √ private 私有的 × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 方法的重写 方法的重载和方法的重写有什么区别? 特点: 发生的前提是要有继承关系 重写有个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致 - 重构 子类重写的方法的访问修饰符可以小于或者等于父类 方法名必须要一样. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法 参数列表必须要高度保持一致 作业1234567891011121314151617181920212223242526272829303132333435361.设计一个形状类Shape,方法:求周长和求面积 形状类的子类:Rect(矩形),Circle(圆形) Rect类的子类:Square(正方形) 不同的子类会有不同的计算周长和面积的方法 创建三个不同的形状对象 分别打印出每个对象的周长和面积 [girth() area() -&gt; 放在父类] [每个子类需要重写这些方法!] - 不要想太多应用场景,语法!2.某公司的雇员分为以下若干类：Employee：这是所有员工总的父类，属性：员工的姓名,员工的生日Date。方法：getSalary(int month) 根据参数月份来确定工资，如果该月员工过生日，则公司会额外奖励100元。SalariedEmployee：Employee的子类，拿固定工资的员工。属性：月薪HourlyEmployee：Employee的子类，按小时拿工资的员工，属性：每小时的工资、每月工作的小时数每月工作超出160小时的部分按照1.5倍工资发放。SalesEmployee：Employee的子类，销售人员，工资由月销售额和提成率决定。属性：月销售额、提成率BasedPlusSalesEmployee：SalesEmployee的子类，有固定底薪的销售人员，工资由底薪加上销售提成部分。属性：底薪。写一个函数，打印出某月每个员工的工资数额。注意：要求把每个类都做成完全封装，不允许非私有化属性。","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day05","slug":"day05","date":"2021-07-19T10:02:10.000Z","updated":"2022-01-07T06:47:24.170Z","comments":true,"path":"2021/07/19/day05/","link":"","permalink":"http://example.com/2021/07/19/day05/","excerpt":"","text":"Date api:java.util.Date[C] - 使用这个类之前,必须要导包import 这是java中提供的关于日期的处理,内置的对象类型.它本身是一个过时的类 里面提供了很多已经过时的方法. 目标:掌握这个类中提供的方法 api手册构造方法 作用:创建这个类的对象的方式 观察提供的方法是静态的方法还是非静态的方法. - api手册方法摘要 Date类中提供的方法几乎都是非静态的方法 - 考虑如何构建这个对象? 如何构建对象 - api手册的构造方法[面向对象] 简单理解构造方法 - “方法”,构造方法通过new关键字调用 Date();//Date d = new Date();//获取当前系统时间 Date(int year, int month, int date);//已经过时的 123Date d2 = new Date(2021-1900,6,21);year - 1900 =&gt; 实际的yearmonth的范围是[0,11] Date(long date);//根据一个毫秒数来构建一个指定的日期类型 - 重新设置一个新的Date Java中日期类型Date对象是不支持运算的. 1234计算三天之后的此时此刻long afterThreeTime = new Date().getTime()+3L*24*60*60*1000;Date afterThreeDate = new Date(afterThreeTime);System.out.println(afterThreeDate); 常用方法 非静态方法 - 日期对象进行调用. long getTime();//返回当前日期的毫秒数的表现形式 - 获取当前系统时间的毫秒数.距离1970年1月1日 1970年是计算机的元年 get/set方法 - 过时的 void setYear(int year);// year-1900 void setMonth(int month);//month的范围[0,11] void setDate(int date);//设置今天是几号 void setHours(int hours);//设置小时 void setMinutes(int minutes);//设置分钟 void setSeconds(int seconds);//设置秒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package tech.aistar.day05; import java.util.Date; /** * 本类用来演示: java.util.Date 日期处理类 * * @author: success * @date: 2021/7/21 8:43 上午 */public class DateDemo &#123; public static void main(String[] args) &#123; //1. 创建一个日期对象 //alter + enter 快速导包 Date d = new Date();//空参构造方法 //为什么此处输出的不是内存地址??? - OO - toString(); //Wed Jul 21 08:45:03 CST 2021 System.out.println(d); //2. 重载的构造方法 - 过时的构造 Date d2 = new Date(2021-1900,6,21); System.out.println(d2); //3. 利用毫秒数来构建一个Date对象 Date d3 = new Date(1626829161216L); System.out.println(d3); System.out.println(&quot;====常用方法===&quot;); //4.. 获取当前日期的毫秒数 //1秒 = 1000毫秒 long nowTime = d.getTime(); System.out.println(nowTime);//1626828910303 //练习-计算三天之后的此时此刻 long afterThreeTime = new Date().getTime()+3L*24*60*60*1000; Date afterThreeDate = new Date(afterThreeTime); System.out.println(afterThreeDate); System.out.println(&quot;=====set设置/get获取======&quot;); Date now = new Date(); now.setYear(2021-1900);//设置年份 now.setMonth(6);//设置月份[0,11] now.setDate(25); System.out.println(&quot;now:&quot;+now); int year = now.getYear()+1900;//获取年份 System.out.println(&quot;year:&quot;+year); System.out.println(&quot;month:&quot;+now.getMonth());//获取月份 System.out.println(&quot;date:&quot;+now.getDate());//获取几号 System.out.println(&quot;day:&quot;+now.getDay()); // 周几,周1-周6[1-6],周日是0 System.out.println(&quot;hours:&quot;+now.getHours()); //void setTime(long date); //构造 Date(long time); Date dd = new Date(); dd.setTime(1726830007794L); System.out.println(dd); &#125;&#125; Calendar 日历类 - 超纲的内容 api - java.util.Calendar 1234public abstract class Calendarabstract[修饰符]修饰的类是一个抽象类 - 不能够被new构建Calendar对象 - Calendar cal = new Calendar();//error api手册常用方法 static Calendar getInstance(); 12//获取当前系统的日历对象Calendar cal = Calendar.getInstance();//底层使用到了简单工厂的设计模式[不需要了解暂时] 关于设置日历字段 12345678void set(int year, int month, int date)设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。 void set(int year, int month, int date, int hourOfDay, int minute)设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。 void set(int year, int month, int date, int hourOfDay, int minute, int second)设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。 12Date -&gt; Calendar void setTime(Date date); 单独针对单个字段一一进行赋值 12345void set(int field,int value);只要看到field//公开的静态的常量属性public static final int YEAR = 1; 关于获取日历字段 123Date getTime();//获取日历信息中关于日期部分的信息 - Calendar转成Date类型 int get(int field);//关于获取日历指定字段的值 总结 毫秒数 -&gt; Date 12a. java.util.Date中提供了构造方法Date(long time);b. 上述类void setTime(long time); Date -&gt; 毫秒数 1该类中long getTime(); Calendar -&gt; Date 1Calendar类中提供了Date getTime(); Date -&gt; Calendar 1Calendar类中void setTime(Date date); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package tech.aistar.day05;import java.util.Calendar;import java.util.Date;/** * 本类用来演示: 日历类java.util.Calendar * * @author: success * @date: 2021/7/21 9:30 上午 */public class CalendarDemo &#123; public static void main(String[] args) &#123; //超纲 - abstract是修饰符 - 修饰类 - 抽象的类 //特点 - 不能够被new[不能够被实例化,具体化] //Calendar cal = new Calendar();//error Calendar cal = Calendar.getInstance(); //System.out.println(cal); //统一设置值 cal.set(2020,6,21); //Calendar -&gt; Date Date now = cal.getTime(); System.out.println(now); //Date -&gt; Calendar Date d = new Date(17818237347L); cal.setTime(d); System.out.println(cal.get(1)); System.out.println(&quot;====单个字段一一赋值====&quot;); //void set(int field,int value); Calendar cd = Calendar.getInstance(); //通过字面量直接进行设置 - 可读性比较差 //获取Calendar中提供的一些公开的静态的常量属性 //System.out.println(); //常量的好处 - 提供程序的可读性 cd.set(Calendar.YEAR,2021); cd.set(Calendar.MONTH,6); cd.set(Calendar.DAY_OF_MONTH,24); System.out.println(cd.getTime());//Calendar-&gt;Date int year = cd.get(Calendar.YEAR); int month = cd.get(Calendar.MONTH)+1; int day = cd.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;year:&quot;+year); System.out.println(&quot;month:&quot;+month); System.out.println(&quot;day:&quot;+day); //获取周几 int week = cd.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;week:&quot;+week);//周日~周六,[1~7] &#125;&#125; 获取键盘键盘输入 java.util.Scanner键盘类 如何构建这个Scanner对象 1Scanner sc = new Scanner(System.in); 方法 3-1. int nextInt();//只能获取整数 3-2. double nextDouble();//获取小数 3-3. String nextLine();//获取字符串 注意点:nextLine不要和nextInt或者nextDouble混用. 面向对象 java语言属于面向对象的语言 面向对象本身不是一门具体的技术,符合人类思维的思想. 宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析, 接着面向对象的设计,最终进行面向对象的编程. 对象是数据在内存中的”载体” 重新认识类和对象 类是抽象的概念,对象是具体的概念 类是构建对象的蓝图/模板,对象是类的具体的实例化[表现] 类是用来描述对象的. 比如: ​ 类:水果 交通工具 学生 对象:榴莲 飞机 小三 比如: id username age 100 admin 18 101 tom 17 面向对象的思想 核心:”一切皆对象” ①分析出系统中业务的关键对象 - “找对象” - 未来页面上显示的数据 ②找出对象的**”属性”** - “对象拥有什么” ③分析出对象的”方法” - “对象可以干什么,对象的功能” ④找出对象与对象之间的关系. 12345671:1 - 一个丈夫对应一个妻子,一个妻子对应一个丈夫. 1:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - 70%N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择. 自关联 - 自己关联自己. ⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法. “相亲业务” - 媒婆帮你找一个”对象” 你要查看”对象”的属性 询问”对象”的功能 分析你和”对象”是否来道🌩 考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现! 面向过程的思想 C是典型的面向过程的思想 ①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现. 实体类 实体类就是用来描述对象的. 实体类中包含属性,构造方法,getter/setter方法,toString方法. 如何定义属性 语法: 修饰符 数据类型 属性名 [=初始值]; 修饰符 public 公开的 private 私有的 数据类型 八种基本数据类型 内置对象类型以及自定义对象类型. 属性名 参考变量的命名 - “小驼峰” 三大特征 - 封装性 封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制 属性私有化 提供getter/setter方法 setter方法 - set属性名[首字母变大写] - 推荐的命名规则 setter方法这种设置值的好处 2-1. setter方法中是可以进行参数有效性判断的. 2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性” 2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的. 12345678910111213141516171819202122232425public class Orders&#123; private int id; private double price; private int count; private double total; //getter/setter - 提供好了 public double getTotal()&#123; double result = this.price * this.count; return result; &#125; &#125; Orders o = new Orders();o.setPrice(100.0);o.setCount(10); //o.setTotal(o.getPrice()*o.getCount());System.out.println(o.getTotal()); 2-4. 并不是所有的属性都需要对外进行公开的. this关键字 作用1 - 当前对象,区分方法中参数和实体类中的定义的属性 - 当两者同名的时候. 调用当前实体类中已经存在的另外一个构造方法. 2-1. this()调动空参 2-2. this(参数1,参数2) - 带参构造 2-3. this调用构造的语句一定要在构造体的首行 this和super语句的区别 toString方法 当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的 当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; java.lang.Object - 它是所有的类的根类,基类,超类,父类. 如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类 “User类是Object类的儿子” - 规定 - “子类可以调用父类中所有的公开的成员“ Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求 所以需要在实体类中重新重写这个toString方法. 当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写 之后的toString方法. 构造方法-constructor 作用:创建对象的时候调用构造方法,通过new关键字 可以在创建对象的同时进行赋值操作,赋值的方式只有1次,setter赋值,可以多次赋值 特点 当实体类中如果没有手动提供任何一个构造方法的时候,那么系统会自动分配一个 空参构造.如果实体类中一旦手动提供了带参构造之后,那么系统将不会再分配一个空参构造了. 定义的时候,不需要返回类型的 123public 类名([参数列表])&#123; //构造体&#125; 构造允许重载的 实体类中推荐只用提供空参,全参","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day04","slug":"day04","date":"2021-07-18T10:02:10.000Z","updated":"2022-01-07T06:45:11.840Z","comments":true,"path":"2021/07/18/day04/","link":"","permalink":"http://example.com/2021/07/18/day04/","excerpt":"","text":"递归算法 方法体中调用方法自己本身 递归算法的方法体中一定要出现递归的出口,否则会抛出java.lang.StackOverflowError - 堆栈溢出错误 使用场景:适合解决大量的,重复性的业务题 缺点:性能比较低,将每次计算的结果都会保存在内存中. 案例 求某个数的阶乘 ※ 12345678910111213141516/** * n! * @param n * @return */public static int jie(int n)&#123; //如果没有出口 - java.lang.StackOverflowError 堆栈溢出错误 //1. 第一个位置都是1 if(n==1) return 1; //2. 方法体中调用自己 return n*jie(n-1); // 6*jie(5) // 6*5*4*3*2*1&#125; 斐波那契数列 ※ 12345678910//斐波那契数列//1 1 2 3 5 8 13 21 34 55 ...public static int fei(int n)&#123; if(n == 1 || n==2) return 1; return fei(n-1) + fei(n-2); //n=4 //fei(3)+fei(2) //fei(2) + fei(1) + fei(2)=3&#125; 求最大公约数 123456//求最大公约数public static int commonDivisor(int m,int n)&#123; if(m % n ==0) return n; return commonDivisor(n,m%n);&#125; 求杨辉三角某行某列的值 1234567891011121314151617 /** * 1 * 1 1 * 1 2 1 * 1 3 3 1 * 1 4 6 4 1 * 1 5 10 10 5 1 * * @param x 纵坐标 行 * @param y 横坐标 列 * @return */public static int yang(int x,int y)&#123; if(y==0 || x==y) return 1; return yang(x-1,y-1) + yang(x-1,y);&#125; 打印直角三角形杨辉三角 12345678910111213 /** * 打印直角三角形. * @param x 打印的杨辉三角的行数 */public static void printYang(int x)&#123; for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt;=i ; j++) &#123; System.out.print(yang(i,j)+&quot;\\t&quot;); &#125; System.out.println(); &#125;&#125; 二维数组 数据类型 变量 = 初始化; 数据类型 - 八种基本数据类型以及对象类型 数组本身就是属于对象类型 1int[] arr = new int[3];//arr的数据类型int[],整数型数组,int型数组 元素类型[] 变量名 = new 元素类型[数组长度]; ~~~javaint[][] 变量名 = new int[rows][cols]元素类型决定了数组中可以存放的数据的类型二维数组中的每个元素就是一维数组 1234566. 定义一个3行2列的int型二维数组 ~~~java int[][] arr = new int[3][2]; int arr[][] = new int[3][2]; 赋值方式 通过下标一一赋值 12int[][] arr = new int[3][2];arr[0][0]=100; 定义二维数组的同时进行赋值 12int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int[][] arr2 = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; 先定义一个数组,然后是一行一行赋值 123int[][] arr = new int[3][3];arr[0] = &#123;1,2,3&#125;;//errorarr[0] = new int[]&#123;1,2,3&#125;;//ok 定义一个不规则的二维数组 12345列可以省略不写int[][] arr4 = new int[3][];arr4[0] = new int[]&#123;1&#125;;arr4[1] = new int[]&#123;1,2&#125;;arr4[2] = new int[]&#123;1,3,1&#125;; 遍历方式 通过下标一一输出 通过单层for循环 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(Arrays.toString(arr[i]));&#125; 双层for循环 1234567for (int i = 0; i &lt; arr.length; i++) &#123; //int[] temp = arr[i]; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.print(arr[i][j]+&quot;\\t&quot;); &#125; System.out.println();&#125; java.util.Arrays工具类中 1System.out.println(Arrays.deepToString(arr)); 增强for循环 12345678910for(元素类型 变量:数组对象名)&#123; &#125; for (int[] ints : arr) &#123; // System.out.println(ints); for (int r : ints) &#123; System.out.print(r+&quot;\\t&quot;); &#125; System.out.println(); &#125; 练习题123456789101112131415161718192021222324252627282930313233343536373839404142434445String[][] arr = new String[4][6];arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;;arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;;arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;;arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;,&quot;&#125;;package tech.aistar.day04;/** * 本类用来演示: 古诗词 横变竖 * * @author: success * @date: 2021/7/20 3:06 下午 */public class PoemsDemo &#123; public static void main(String[] args) &#123; String[][] arr = new String[4][6]; arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;; arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;; arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;; arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;,&quot;&#125;; change(arr); &#125; public static void change(String[][] arr)&#123; String[][] temp = new String[6][4]; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; temp[j][i] = arr[i][j]; &#125; &#125; for (int i = 0; i &lt; temp.length; i++) &#123; for (int j = 0; j &lt; temp[i].length; j++) &#123; System.out.print(temp[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 作业 http://xzc.cn/EhC5y656uG A B C 二维数组输出直角的杨辉三角 将1~5之间的随机整数,存储到一个长度为15的一维数组中.写一段程序. 统计每个随机数在这个数组中出现的次数.并且根据出现的次数进行降序排列. 123456arr -&gt; &#123;1,2,1,2,3,4,1,2,1,1,1...&#125;数组去重 - 个数temp -&gt; &#123;1,2,3,4&#125; two[i] = new int[]&#123;temp[i],count&#125;;int[][] two = new int[?][2]; 排序","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day03","slug":"day03","date":"2021-07-17T10:02:10.000Z","updated":"2022-01-07T07:27:19.636Z","comments":true,"path":"2021/07/17/day03/","link":"","permalink":"http://example.com/2021/07/17/day03/","excerpt":"","text":"方法的重载(@overload) 前提: 重载的方法是存在于同一个类中 [前提] 重载的方法的方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 1234567891011121314public class LoadMethodDemo &#123; public static void main(String[] args) &#123; add(20); &#125; public static int add()&#123; System.out.println(&quot;add -&gt; 100&quot;); return 100; &#125; public static void add(int i)&#123; System.out.println(i); &#125;&#125; 优点就是简化api - 方便调用的. 学会使用api 通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package tech.aistar.day03;/** * 本类用来演示: java.lang.Math * * @author: success * @date: 2021/7/19 8:59 上午 */public class MathDemo &#123; public static void main(String[] args) &#123; //绝对值 int n = Math.abs(-10); System.out.println(n); //求随机数 - 伪随机的 //static double random();//[0.0,1.0)之间的随机小数 System.out.println(Math.random()); //[1,100]之间随机的整数 int result = (int) (Math.random()*100+1);//[1,100] System.out.println(result); //[3,5]之间的随机整数 int m = (int) (Math.random()*3+3); System.out.println(m); //求俩个数中的最大值/最小值 System.out.println(Math.max(10,20));//20 //笔试填空题 - //返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 //floor方法. System.out.println(Math.floor(3.5));//3.0 System.out.println(Math.floor(4.0));//4.0 System.out.println(Math.floor(-3.5));//-4.0 //返回参数中最接近的 long ，其中 long四舍五入为正无穷大。 //Math.floor(a + 1/2) System.out.println(Math.round(-3.5)); //开根 System.out.println(Math.sqrt(9));//3.0 //次方 System.out.println((int)Math.pow(2,3));//8 &#125;&#125; 语句三元操作符 三目运算符 条件表达式 ? result1 : result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套的 - 但是不推荐,可读性差 m ? (表达式?result1:result2):result2 if…else.. if语句单独使用场景 123if(条件)&#123;//成立 //code...&#125; {}可以省略的场景 1234if(条件) //code... 如果if&#123;&#125;中的代码只有1行,那么&#123;&#125;可以省略,但是一定要缩进 if…else…使用 1234567891011if(条件)&#123; //条件成立&#125;else&#123; //条件不成立&#125;//如果语句仍然只有一行,&#123;&#125;还是可以省略的if(条件) //codeelse //code.. 多条件分支if…else if…else..if … else… 注意条件是互斥的 123456789if(条件)&#123; //条件成立&#125;else if(条件)&#123; //条件不成立&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; if..else语句可以无限嵌套使用 1234567891011121314151617181920212223if(条件)&#123; //条件成立 if(条件)&#123; &#125;else&#123; &#125;&#125;else if(条件)&#123; //条件不成立 if(条件)&#123; //条件成立 &#125;else if(条件)&#123; //条件不成立 &#125;else if(条件)&#123; //code &#125;else&#123; //code.. &#125;&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; 习题 买奶茶,每第二杯半价,单价是10元.求总价. 110 5 10 5 10 求某年某月最大天数 switch..case 没有if..else if..else灵活 语法: 1234567891011121314151617switch(变量)/ /byte short int char String enum[枚举类型] //包装类型Byte Short Integer Character case 值1: //code [break]; case 值2: //code [break]; case 值3: //code [break]; [default: //code.. [break];]&#125; 当switch括号中的变量能够匹配到某个case后面的值的时候,那么就会进入到对应的case中去执行里面的程序 进入到某个case块中执行的过程中,只有遇到break语句才会跳出switch块.如果没有遇到break语句,那么程序会 自动进入到下一个case块中去执行. default语句可以省略,也是可以随便放的,推荐放在末尾.如果switch括号中的变量没有匹配到任何的case后面的值 的时候,那么就会进入到default 循环语句while 属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环. 使用场景:当不知道循环多少次,但是知道循环退出的条件的时候 - 优先选择while循环. 语法: while(条件){ ​ // 循环体… } 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03;/** * 本类用来演示: while循环 * * @author: success * @date: 2021/7/19 10:53 上午 */public class WhileDemo &#123; public static void main(String[] args) &#123; //while可以代替for的使用 //&#x27;a&#x27;-&#x27;z&#x27; char c = &#x27;a&#x27;; while(c &lt;= &#x27;z&#x27;)&#123; System.out.println(c); c++; &#125; System.out.println(&quot;=====&quot;); //&#x27;A&#x27; - &#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123;//退出的条件 System.out.println((char)n); n++; &#125; //1-10 int m = 1; //死循环... while(true)&#123; //死循环的内部一定要有打破循环的语句 - break System.out.println(m); if(m==10) // 循环退出的条件 break; m++; &#125; &#125;&#125; 练习 求俩个数的最大公约数 12345思路:20 12 -&gt; 4 20 % 12 = 8 12 % 8 = 4 8 % 4 = 0 十进制转换二进制 1 for循环 属于后置循环 单层for 1234567891011for(①表达式1;②表达式2;③表达式3)&#123; //④循环体&#125;①表达式1 - 循环过程中的变量的初始化操作.比如int i = 0; - 仅仅只会执行1次.②表达式2 - 循环退出的条件.比如 i&lt;=10 - 至少执行1次③表达式3 - 循环过程中,变量因子的变化.i++ - 有可能是不执行,可能执行 执行顺序①-②[成立]-④-③-②[成立]-④-③..... 怪异的写法 1234for(;;)&#123; //死循环 - break打破循环的语句&#125;三个表达式都是可以任意的省略不写,或者写到其他地方 for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 嵌套for循环,嵌套的层数不建议超过三层.嵌套越多,性能越低. 2-1. 内外层无关 - 里面的for选中的使用可以单独执行.没有使用到外面for的循环的变量因子的. 2-2. 内外层相关 - 里面的for使用到了外面for循环的变量因子的 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. 每打印4个换一行 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03; /** * 本类用来演示: * 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. * * 每打印4个换一行 * * @author: success * @date: 2021/7/19 2:26 下午 */public class ForExerciseDemo &#123; public static void main(String[] args) &#123; //定义一个计数器 int count = 0; for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4; y++) &#123; for (int z = 1; z &lt;=4; z++) &#123;// System.out.print(x+&quot;&quot;+y+z); if(x!=y &amp; x!=z &amp; y!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++;// if(count % 4==0)&#123;// System.out.println();// &#125; if(count == 4)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; &#125; &#125;&#125; do..while.. 属于前置循环 - 无论循环条件是否成立,优先先进入到循环体中执行一次. 然后再进行判断条件,决定下一次是否再次进入. do{ //循环体… }while(条件); break语句 break可以跳出swtich块 break可以打破它所在的那一层循环 continue语句 出现在循环体中 跳过本轮循环,继续执行下一轮循环. 数组 数组的诞生 - 为了解决单个变量只能存储单个值的缺点. 数组本身也是属于数据结构[数组,栈,堆,树[红黑树],链表,图…] 数组是属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区 数组在内存中一定是一块连续的空间. 数组的大小[长度,数组中存放的数据的个数]一旦确定了,不能改变. 定义数组必不可少的俩个条件 - 元素类型/数组的长度要确定 数组容器 语法1234567891. 元素类型[] 变量名 = new 元素类型[size];//size数组的大小2. 元素类型 变量名[] = new 元素类型[size];//元素类型就是数据类型[8种基本数据类型,以及对象类型]作用 - 元素类型决定了这个数组中可以存放的数据的类型//arr的数据类型是什么?int[] -&gt; 整数型数组// &quot;定义一个长度为3的int型数组&quot;int[] arr = new int[3]; 赋值方式 如果定义了数组,但是没有进行赋值操作,那么系统会默认分配一个默认值 默认值根据元素类型来决定了. byte,short,int,long -&gt; 0 float,double -&gt; 0.0 boolean -&gt; false char -&gt; 空格 对象类型 -&gt; null 先定义数组,然后通过下标一一赋值 123456int[] arr = new int[3];//数组的下标从[0,数组长度-1]范围//如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常arr[0] = 10;arr[1] = 10;arr[2] = 10; 定义数组的同时进行赋值 1int[] arr = &#123;3,4,5&#125;; 定义数组的同时进行赋值 1int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1);&#125; 数组的遍历 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数组的长度 通过普通for循环进行遍历 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法 属于只读的for 1234567int[] arr2 = &#123;3,4,5&#125;;for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for(int e:arr2)&#123;//此处的e不是代表下标,就是代表真正的元素 System.out.println(e);&#125; 通过java.util.Arrays数组工具类中提供的static String toString(数组对象)来遍历数组 拓展 - 数组的内存123456789101112131415//通过new关键字在Jvm的堆中开辟新的空间01,用来存储这个对象&#123;10,20,30&#125;//然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1[存储在栈]//&quot;结论&quot; - arr1的本质不是对象,只是一个引用变量而已//&quot;结论&quot; - 引用和对象之间的关系// 引用变量中存储的就是对象在堆空间中的内存地址// &quot;气球理论&quot; - 一个引用变量在同一个时刻,只能指向一个对象// - &quot;一个对象可以在同一个时刻被多个引用指向&quot;int[] arr1 = new int[]&#123;10,20,30&#125;;//通过new关键字在Jvm的堆中开辟新的空间02,用来存储这个对象&#123;10,20,30&#125;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2;//arr1和arr2都是指向第二次创建出来的数组对象 //原来第一次创建出来的对象就成为内存中的垃圾对象 - GC[垃圾回收线程进行回收,释放内存] //&quot;垃圾对象&quot; - 没有任何引用指向的对象 拓展 - 方法的参数传递方式 基本类型采用值传递 对象类型[引用类型]采用地址传递 总结:**Java中只有值传递,没有地址传递.**比较特殊的是String类型[虽然是一个对象类型,但是具备基本类型传递的特点] 数组工具类 java.util.Arrays static String toString(int[] arr);//输出数组 static int[] copyOf(int[] original, int newLength)复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 static void fill(boolean[] flag,boolean value);//给数组赋统一的值.","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day02","slug":"day02","date":"2021-07-16T10:02:10.000Z","updated":"2022-01-07T06:24:46.012Z","comments":true,"path":"2021/07/16/day02/","link":"","permalink":"http://example.com/2021/07/16/day02/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package tech.aistar.day02;import java.util.Date;/** * 本类用来演示: 变量的定义和使用 * * @author: success * @date: 2021/7/16 8:35 上午 */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; char类型 java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day02;/** * 本类用来演示: char类型 * * @author: success * @date: 2021/7/16 9:14 上午 */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 1final 数据类型 变量 [= 初始值]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day02;/** * 本类用来演示: 局部变量和全局变量 * * @author: success * @date: 2021/7/16 10:04 上午 */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符11. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符1&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. ​ 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 ​ 连接条件:为true - 所有的条件表达式都是返回true & 8 1234567892. | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. **计算:只要存在一个1,结果就是1** 连接条件:为true - 只要存在一个条件表达式为true. ~~~java 10 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 110 ^ 8 = 2 1 0 1 0| 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 10 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 1笔试题: 交换俩个变量的值,不允许出现第三方变量 package tech.aistar.day02; /** * 本类用来演示: 笔试题: 交换俩个变量的值,不允许出现第三方变量 * * @author: success * @date: 2021/7/16 11:09 上午 */ public class ChangeVarValue &#123; public static void main(String[] args) &#123; //1. 使用第三方变量 int a = 10; int b = 20; int temp = a; a = b; b = temp; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); //一个数字连续异或同一个数字俩次结果是它本身. int m = 100; int n = 200; m = m ^ n;//m = 100 ^ 200 n = m ^ n;//n = 100 ^ 200 ^ 200 = 100 m = m ^ n;//m = 100 ^ 200 ^ 100 = 200 System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); //自创写法(success独家的) - 不推荐写 - 防止菜鸟看不懂 int x = 100; int y = 200; //y = 100 ^ 200 ^ 200 = 100 y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); &#125; &#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 1补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少?计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 111101013. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果-10 = ~9结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 1&lt;&lt; 向左移动2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-10 &gt;&gt; 2 = -311111111 11111111 11111111 11110110 &gt;&gt; 211111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是100000000 00000000 00000000 00000010 取反 ~2=-3&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 练习-15&gt;&gt;2 -15&gt;&gt;&gt;2 -15 = ~14 11111111…… 0001 &gt;&gt;&gt; 2 00111111 11111111 11111111 11111101 00111111 11111111 11111111 1111100 = 1073741820 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 1return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 1不需要使用return + 返回值; 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 1public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数) } //int m = test01(20,12);//m-&gt;4 public static int test02(int m,int n){ int 公约数 = test01(m,n); return mn/公约数; } int n = test02(20,12);//n-&gt;60=2012/4=60 1 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 可变长列表 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式 取决于这个方法是静态的还是非静态的 - static 12package tech.aistar.day02.method;/** * 本类用来演示: 方法的定义 * * @author: success * @date: 2021/7/16 2:20 下午 */public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&gt;package tech.aistar.day02.method;&gt;/**&gt;* 本类用来演示:&gt;*&gt;* @author: success&gt;* @date: 2021/7/16 2:43 下午&gt;*/&gt;public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&gt;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"day01","slug":"day01","date":"2021-07-15T09:54:17.000Z","updated":"2022-01-07T06:24:14.224Z","comments":true,"path":"2021/07/15/day01/","link":"","permalink":"http://example.com/2021/07/15/day01/","excerpt":"","text":"Java能做什么 传统的项目 - 简单的,公司内部使用的,不会存在高并发的问题. 教务管理系统,OA自动化办公系统,CRM客户关系管理系统,ERP企业资源计划系统 B2C - 典型的电子商务模式,涉及到高并发的业务 企业2客户 - 企业卖自己的服务或者产品 C2B2C - 新型的模式 - 淘宝 平台 - 对双方进行监管 卖家 买家 大数据 - 一定是对业务非常熟悉[数据分析,数据非常敏感] Java的历史 原先是属于SUN公司[Stanford University Network 斯坦福网络大学] Sun Microsystem - 太阳微电子公司 后来在2010年10月份被Oracle公司[出名的产品-oracle数据库 - NO.1] 74亿美金收购 - www.oracle.com 前身Oak语言[橡树],印度尼西亚的爪哇岛[咖啡豆 - javabean] 诞生于1995年5月23日,96年正式推出jdk1.0版本. 商用的jdk版本 - jdk8.x , jdk11.x ,jdk16.x java之父 - james gosling 詹姆斯 高斯林 Java支持的三个平台 原先的名称j2se , j2ee, j2me JavaSE - Java Standard Editional - Java标准版 适合做桌面应用程序[维护比较麻烦,服务器端如果更新,客户端需要更新],包含了java里面的基础的语法,核心 JavaEE - 2018年 - JakartaEE - 雅佳达EE - Java Enterprise Editional - Java企业版 是一套技术的规范的体系.不是一门具体的技术.里面包含了13种核心技术 比如jdbc,servlet等遵守javaee的规范.现在javaee里面的核心技术已经使用不多了 现在普遍都在使用spring全家桶中的技术. 适合做web应用程序[web网站] JavaME - Java Micro Editional - Java微型版,适合做手持设备 - “不用” 检测一下jdk的环境变量是否配置成功 打开终端,输入cmd - 输入java -version 1234admindeMacBook-Pro:Desktop admin$ java -versionjava version &quot;1.8.0_66&quot;Java(TM) SE Runtime Environment (build 1.8.0_66-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) 环境变量的配置 Java.zip - 解压缩 - 比如放在D盘 所有的软件不要放在中文目录下,不要放在带有特殊符号的目录下[programe files(x86)] 尽量不要放在C盘[权限的问题,拒绝你的访问的] 桌面 - 右击计算机 - 属性 - 高级系统设置 - 环境变量(N) - 定位到系统变量 新建 变量名:JAVA_HOME 变量值:jdk1.8.0_66的绝对路径 确定 找到内置的变量名Path - 编辑 - 新建 %JAVA_HOME%\\bin 关闭刚所有打开的设置窗口,重新打开终端[黑窗口] win+r - cmd -&gt;输入 java -version Java语言特点 简单 可移植性 面向对象 - 核心 与平台无关性[跨平台性,跨操作系统平台] 安全性 - 本身是属于强类型的语言.在编译期间就要确定数据的类型. JDK和JRE和JVM 三者之间的区别 - 简单题 - 笔试 JDK - Java Development Kit - Java开发工具包,针对于开发者的.包含了很多开发工具 比如java.exe , javac.exe, javadoc.exe , jar.exe等 JDK中是包含JRE的 JRE - Java Runtime Enviroment - Java运行时环境,包含了很多核心的内库. 针对于使用java语言开发出来软件的用户.如果一个用户仅仅想运行一个java程序的话 那么计算机中只需要安装jre即可. JRE包含JVM JVM - Java Virtual Machine - Java虚拟机 - 后期重点详细介绍jvm[笔试的大头 - 内存模型] jvm本身就是用C语言编写的 - jvm的源码通读一遍. java程序并不是直接在计算机中进行跑的.而是在虚拟机上执行的.虚拟机是安装在操作系统上的. 注意的是java语言是跨平台的[使用java语言编写的程序可以运行在不同的os上],但是jvm不是跨平台的 不同的操作系统需要安装不同的jvm HelloWorld程序 java的基础单元是类class 类的命名 - 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头 推荐使用”大驼峰”命名规则,单词首字母必须要大写.其余单词小写 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字[java语言赋予了这些单词具备一定的语法含义] byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue,class, public,private,protected等 不能是java中的保留关键字 - goto,const 不推荐使用中文,防止出现乱码问题. 不推荐使用中文的拼音 推荐见名知意 不能是以下三个字面量 - true,false,null 代码 在D盘根目下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 记事本打开HelloWorld.java文件 12345678910111213141516171819//编程语言中,只要出现了符号,一定必须都是英文输入法下的//整体的结构//java是以类作为基础的单位的 - 定义类//关键是class//类的名称要和文件的名称高度保持一致//&#123;&#125; - block - 块 - 代码块public class HelloWorld&#123;//1. 类 //规范 - 缩进四个空格 //定义一个main方法 - 程序的&quot;大门&quot; //运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main //方法中去执行 //今天先记住语法 public static void main(String[] args)&#123;//2. 方法 //方法体,现阶段代码一定是放在方法体内部的. //jdk中提供了内置的对象[拥有一些功能],提供好了,开发者就可以直接使用 //java.lang.System类 - 向控制台输出一句话 System.out.println(&quot;HelloWorld&quot;);//3. 具体的程序 &#125;&#125; java源代码是不能够直接执行的.因为计算机是不识别java语言程序的. 需要对.java为后缀的源文件进行一个编译操作.如果一旦语法发生了问题,都会导致编译失败. 假设HelloWorld.java文件是放在D盘根目录下,需要打开终端,然后通过dos命令进入到D盘 12C:/User/admin&gt;d:D:/&gt;javac HelloWorld.java 效果,javac.exe工具其实就是在调用jdk中的编译器,作用:就是.java源文件编译成.class字节码文件 思考如何运行一个java程序呢? 利用java.exe 1D:/&gt;java HelloWorld 过程 编写.java源代码 javac.exe - 编译 java.exe - 执行 Java程序的执行的原理 12345678.java源文件 -&gt; 经过jdk中的编译器,成为.class字节码文件 -&gt; 经过jvm中的解释器[进行逐行翻译(解释)]-&gt; 机器能够识别的符号java属于解释型的语言,&quot;JVM把它YY成以.class字节码为指令的CPU&quot;编译型语言 - C语言,将这个语言编写的程序直接编译成计算机能够执行的程序.比如C语言写的代码可以直接编译成可执行文件 xx.exeC语言执行的性能高于java语言(每次执行都会经过jvm解释器进行解释) 集成开发环境 eclipse[日食] - 免费的,IBM公司的产品[收购SUN公司的] idea - 最好的,收费的 d:/aistar/j03s_student Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 ​ com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. java中三种注释 单行注释 // ctrl+/ 添加/取消注释 多行注释 12345/* * * 多行注释的内容 - 注释的内容是不会经过jdk的编译器的 * */ 文档注释 可以生成文档树 123456/*** 放在类上面* 放在方法上**/ main方法细节12345678910public[公开的,公共的] static[静态的] - 都是属于后期学习OO中的修饰符修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args - 我们传给虚拟机的参数 输出语句 System.out.println(); // 换行 1System.out.print(&quot;\\n&quot;); \\n和\\r 1package tech.aistar.day01;/** * 本类用来演示: \\n \\r * * @author: success * @date: 2021/7/15 3:18 下午 */public class NrDemo &#123; public static void main(String[] args) &#123; //相当于是System.out.println(&quot;hello&quot;); System.out.print(&quot;hello\\n&quot;);//输出之后不换行 System.out.println(&quot;world&quot;); // \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 // \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 // \\n\\r 诞生的场景就是早期的打字机 //外面的终端执行的结果是 - veyy √ //伪终端显示的结果是 - ve System.out.println(&quot;Loyy\\rve&quot;); &#125;&#125; 特殊字符 \\ 是代表转义字符 \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 \\b - 退格 \\t - 制表符,相当于tab键,默认是空4格 双引号 1\\&quot; 单引号 1\\&#x27; 单个\\ 1\\\\ 123456789101112131415161718192021222324252627282930package tech.aistar.day01;/** * 本类用来演示: 特殊字符 * * @author: success * @date: 2021/7/15 3:35 下午 */public class SignDemo &#123; public static void main(String[] args) &#123; //\\b - 退格 System.out.println(&quot;xxx\\byy&quot;);//xxyy //\\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); //输出 james:&quot;success is good boy&quot; //双引号 System.out.println(&quot;james:\\&quot;success is good boy\\&quot;&quot;); // \\ 转义含义 //单个\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); //输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量 编程的核心就是从定义变量开始 java语言是一个强类型的语言[在编译期间必须要确定好数据的类型],javascript弱类型的语言 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作. 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库) - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型 java中的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 数据类型决定了存储数据的这块空间的大小,并且这个大小一旦确定了,将不能够改变了. 对象类型(无数种) 2-1. 内置对象类型 - System,String - Jdk中提供的类 2-2. 自定义对象类型 - 自己定义的那些类HelloWorld,SignDemo 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 变量的定义 变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 语法 1数据类型 变量名 [= 变量值]; 剖析变量的背后1package tech.aistar.day01;/** * 本类用来演示: 变量入门 * * @author: success * @date: 2021/7/15 3:43 下午 */public class VarDemo &#123; public static void main(String[] args) &#123; //数据类型 变量名 [= 变量值]; byte b = 10; //代码的背后 - 埋了个&quot;种子&quot;,&quot;发芽&quot; //1. 数据肯定是存储在JVM内存中的 //2. 定义在方法内部的变量 - 局部变量[JVM的栈区] //3. 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //讲解的本质 //流程 //1. JVM加载VarDemo.class到内存 //2. JVM找到main方法想要去执行里面的程序 //3. 此处需要申请一块区域来保存数据10 // 3-1. 区域的大小由前面的数据类型来决定的 - int类型 - 区域4个字节32bit的大小 // 3-2. 栈里面的区域的大小一旦被确定了,就不能改变 - 肯定有的时候会有内存的浪费 // 3-3. 虽然空间浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; //4. 只要是内存中的空间,这个空间必然会有一个地址,所以变量的存在是为了给这个区域取了个名字 // 变量是为了方便用户来通过它访问到这个空间中存储的具体的那个值的 //把整数10赋值给一个int类型的变量a int a = 10; System.out.println(a); // == 比较的就是&quot;坑 - 区域&quot;里面存储的数据 System.out.println(b == a);//true &#125;&#125; 数据类型的转换 常识规定 a. java中看到一个整数,默认就是int类型 b. java中看到一个小数,默认就是double类型 c. 大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型. byte-&gt;short-&gt;int-&gt;long char-&gt;int int-&gt;double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 隐式转换 1234567int-&gt;long整数后面添加l/L double-&gt;float小数后面加上f/F 推荐在double后面加上d/D - 提高语义","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"}]},{"title":"hexo-blog搭建","slug":"hexoA","date":"2021-07-13T07:20:57.000Z","updated":"2022-01-07T06:26:06.073Z","comments":true,"path":"2021/07/13/hexoA/","link":"","permalink":"http://example.com/2021/07/13/hexoA/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功 如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 123[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 12D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 12345overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1234567891011121314151617181920212223242526272829303132333435常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1234title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1234# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 12345678910valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1234deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1234hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"know","slug":"know","permalink":"http://example.com/categories/know/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Java","slug":"java","date":"2021-07-12T08:51:44.000Z","updated":"2021-07-15T11:19:22.059Z","comments":true,"path":"2021/07/12/java/","link":"","permalink":"http://example.com/2021/07/12/java/","excerpt":"","text":"无聊的知识 java 1 1 2 3 1psvm 字体粗体: 粗 斜体：斜 粗斜体：粗斜 高亮体：高亮 1 表格 111 1 11 222 2 22 333 3 33 图片 结束 7.12","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-12T06:46:58.326Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/07/12/hello-world/","link":"","permalink":"http://example.com/2021/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"},{"name":"know","slug":"know","permalink":"http://example.com/categories/know/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"},{"name":"coreJava","slug":"coreJava","permalink":"http://example.com/tags/coreJava/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}