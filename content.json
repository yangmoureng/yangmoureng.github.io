{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.134Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.135Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.137Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.136Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-23T00:25:03.732Z","updated":"2021-07-12T08:00:19.137Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-23T00:25:03.742Z","updated":"2021-07-12T08:00:19.138Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-23T00:25:03.742Z","updated":"2021-07-12T08:00:19.139Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexoA","slug":"springclound","date":"2021-10-19T07:20:57.000Z","updated":"2021-10-20T05:28:04.560Z","comments":true,"path":"2021/10/19/springclound/","link":"","permalink":"http://example.com/2021/10/19/springclound/","excerpt":"","text":"springcloud的组件哪些? Eureka,Ribbon,Feign Eureka - 治理服务 -SOA架构 Eureka-server - 服务中心 - 可以做集群 - 降低各个服务之间耦合.服务于服务之间不需要关心具体怎么通信. Eureka-client - 服务客户端,每次启动客户端的时候,需要将客户端的信息[名称,网络信息]注册到eureka-server 每30s会向eureka-server发送一次心跳 - 目的是为了告诉eureka-server它还活着,想要续约.如果超过90s,eureka-server接受不到该客户的心跳,那么再比例[失败的比例如果低于85%],那么就会剔除. Ribbon 提供负载均衡策略,rest方式[RestTemplate + ribbon] Feign 基于Ribbon,Feign最主要的作用是用来提供服务于服务之间的通信的问题.默认提供了负载均衡 nginx负载均衡(服务器端)和Feign/Ribbon负载均衡(客户端)区别 - 负载均衡的策略 SpringCloud2020版本开始,剔除了netflix项目[不进行更新了,仍然会继续维护bug]的组件,保留了Eureka组件. 概念 分布式 - 将一个庞大的系统按照模块进行拆分,拆分成若干个子模块[微服务] , 进行分布式的部署[各个服务部署在不同的服务器] 着重点 - 有无进行分布式部署 - 部署的方式 微服务 - 架构风格,微服务不一定是分布式的.但是分布式微服务架构的. “每个微服务都是单独的独立的工程项目,可以进行单独的部署 = 不同的人做不同的事情” 集群 - “很多人做同一件事情” - 分布式上的每个节点[微服务]都是可以进行集群的. 解决”三高” - 高并发,高性能,高可用 单体架构 - 整个项目都在一个工程里面,一起进行部署的.弊端 - 如果项目中的某个模块修改了,需要整体重新打包,重新部署. 如果某个模块”坏掉了” - 导致整个项目都”崩” 微服务 什么是我服务? 微服务是一种架构风格，也是一种服务； 微服务的颗粒比较小，一个大型复杂软件应用由多个微服务组成，比如Netflix目前由500多个的微服务组成； 它采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。 微服务架构图 微服务好处 技术异构性：在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。 弹性：如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。 扩展：可以只对那些需要扩展的服务进行扩展。简化部署：各个服务的部署是独立的，这样就可以更快地对特定部分的代码进行部署。 与组织结构相匹配：可以很好地将架构与组织结构相匹配，避免出现过大的代码库，从而获得理想团队大小及生产力。 可组合性：不同服务模块的接口可以再进行重用，成为其他产品中的一个组件； 对可替代性的优化：可以在需要时轻易地重写服务，或者删除不再使用的服务 微服务缺点 运维开销更多的服务也就意味着更多的运维，产品团队需要保证所有的相关服务都有完善的监控等基础设施，传统的架构开发者只需要保证一个应用正常运行，而现在却需要保证几十甚至上百道工序高效运转，这是一个艰巨的任务。 DevOps要求使用微服务架构后，开发团队需要保证一个Tomcat集群可用，保证一个数据库可用，这就意味着团队需要高品质的DevOps和自动化技术。而现在，这样的全栈式人才很少。 隐式接口服务和服务之间通过接口来“联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做调整。 重复劳动在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这个时候可能不同的服务团队都会单独开发这一功能，重复的业务逻辑，这违背了良好的软件工程中的很多原则。 分布式系统的复杂性微服务通过REST API或消息来将不同的服务联系起来，这在之前可能只是一个简单的远程过程调用。分布式系统也就意味着开发者需要考虑网络延迟、容错、消息序列化、不可靠的网络、异步、版本控制、负载等，而面对如此多的微服务都需要分布式时，整个产品需要有一整套完整的机制来保证各个服务可以正常运转。 事务、异步、测试面临挑战跨进程之间的事务、大量的异步处理、多个微服务之间的整体测试都需要有一整套的解决方案，而现在看起来，这些技术并没有特别成熟。 SpringCloud介绍 springcloud是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。 通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。 SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix 下面简单介绍下经常用的5个: 服务发现——Netflix Eureka 客服端负载均衡——Netflix Ribbon(重点掌握Netflix Feign) 断路器——Netflix Hystrix 服务网关——Netflix Zuul 分布式配置——Spring Cloud Config Eureka 作用：实现服务治理（服务注册与发现） 简介：Spring Cloud Eureka是Spring Cloud Netflix[停止更新]项目下的服务治理模块。 由两个组件组成：Eureka服务端和Eureka客户端。 Eureka服务端用作服务注册中心。支持集群部署。 Eureka客户端是一个java客户端，用来处理服务注册与发现。 在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。 Ribbon 作用：Ribbon，主要提供客户侧的软件负载均衡算法。 简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。 注意看上图，关键点就是将外界的rest调用，根据负载均衡策略转换为微服务调用。Ribbon有比较多的负载均衡策略，以后专门讲解。 Hystrix 作用：断路器，保护系统，控制故障范围。 简介：为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 Zuul 作用：api网关，路由，负载均衡等多种作用 简介：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。 在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。 config 作用：配置管理 简介：SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。 这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。 相关组件架构图 从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。 其中Eureka负责服务的注册与发现，很好将各服务连接起来 Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。 Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示 Spring Cloud Config 提供了统一的配置中心服务 当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息 所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用 最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析 为什么要使用springcloudSpring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利。 微服务架构是一种趋势，Spring Cloud提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。 Eureka服务与注册为什么需要服务中心过去，每个应用都是一个CPU，一个主机上的单一系统。然而今天，随着大数据和云计算时代的到来，任何独立的程序都可以运行在多个计算机上。并且随着业务的发展，访问用户量的增加，开发人员或小组的增加，系统会被拆分成多个功能模块。拆分后每个功能模块可以作为一个独立的子系统提供其职责范围内的功能。而多个子系统中，由于职责不同并且会存在相互调用，同时可能每个子系统还需要多个实例部署在多台服务器或者镜像中，导致了子系统间的相互调用形成了一个错综复杂的网状结构 对于微服务之间错综复杂的调用关系，通过eureka来管理，可以让每个服务之间不用关心如何调用的问题，专注于自己的业务功能实现。 Eureka的管理 服务需要有一个统一的名称（或服务ID）并且是唯一标识，以便于接口调用时各个接口的区分。并且需要将其注册到Eureka Server中，其他服务调用该接口时，也是根据这个唯一标识来获取。 服务下有多个实例，每个实例也有一个自己的唯一实例ID。因为它们各自有自己的基础信息如：不同的IP。所以它们的信息也需要注册到Eureka Server中，其他服务调用它们的服务接口时，可以查看到多个该服务的实例信息，根据负载策略提供某个实例的调用信息后，调用者根据信息直接调用该实例。 Eureka如何管理服务调用 在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。然后进行2调用当前服务器节点中的其他服务信息，保存到Eureka Client中。当服务间相互调用其它服务时，在Eureka Client中获取服务信息（如服务地址，端口等）后，进行第3步，根据信息直接调用服务。（注：服务的调用通过http(s)调用） 当某个服务仅需要调用其他服务，自身不提供服务调用时。在Eureka Client启动后会拉取Eureka Server的其他服务信息，需要调用时，在Eureka Client的本地缓存中获取信息，调用服务。 Eureka Client通过向Eureka Serve发送心跳（默认每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 以此来确保当前服务还“活着”，可以被调用。 来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次），以此来确保调用到的服务是“活的”。并且当某个服务被更新或者新加进来，也可以调用到新的服务。 Eureka Server和Eureka Client Eureka Server 提供服务注册：各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如服务信息和网络信息），Eureka Server会存储该服务的信息。 提供服务信息提供：服务消费者在调用服务时，本地Eureka Client没有的情况下，会到Eureka Server拉取信息。 提供服务管理：通过Eureka Client的Cancel、心跳监控、renew等方式来维护该服务提供的信息以确保该服务可用以及服务的更新。 信息同步：每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过P2P复制的方式完成服务注册表的同步 Eureka Client Eureka Client是一个Java客户端，用于简化与Eureka Server的交互。并且管理当前微服务，同时为当前的微服务提供服务提供者信息。 Eureka Client会拉取、更新和缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。 Eureka Client在微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）。 服务续约、下线、剔除 服务续约 Application Service内的Eureka Client后台启动一个定时任务，跟Eureka Server保持一个心跳续约任务，每隔一段时间(默认30S)向Eureka Server发送一次renew请求，进行续约，告诉Eureka Server我还活着，防止被Eureka Server的Evict任务剔除。 服务下线 Application Service应用停止后，向Eureka Server发送一个cancel请求，告诉注册中心我已经退出了，Eureka Server接收到之后会将其移出注册列表，后面再有获取注册服务列表的时候就获取不到了，防止消费端消费不可用的服务。 服务剔除 Eureka Server启动后在后台启动一个Evict任务，对一定时间内没有续约的服务进行剔除。 服务通讯方式 服务间使用标准的REST方式通讯，所以Eureka服务注册中心并不仅适用于Java平台，其他平台也可以纳入到服务治理平台里面。 自我保护 本地调试Eureka的程序时，会出现： 该警告是触发了Eureka Server的自我保护机制。 Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果低于，就会将当前实例注册信息保护起来，让实例不会过期，尽可能保护这些注册信息。 但是如果在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。这个时候客户端的容错机制就很重要了。（重新请求，断路器） 保护机制，可能会导致服务实例不能够被正确剔除。 在本地开发时，可使用：eureka.server.enable-self-preservation=false关闭保护机制，使不可用实例能够正常下线。 Eureka和Zookeeper区别Eureka：可以在发生因网络问题导致的各节点失去联系也不会暂停服务，但是最新的数据可能不统一。 Zookeeper：如果发生网络问题导致的Master和其他节点失去联系，就会使得其他的节点推选出新的Master，但是推选的时间内无法提供服务，但是可以保证任何时候的数据都是统一的。 基于idea多模块搭建eureka注册中心 首先创建父工程parent-demo,父工程pom.xml配置如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;modules&gt; &lt;module&gt;eureka-demo&lt;/module&gt; &lt;module&gt;user-demo&lt;/module&gt; &lt;module&gt;order-demo&lt;/module&gt; &lt;module&gt;zuul-demo&lt;/module&gt; &lt;module&gt;config-server-demo&lt;/module&gt; &lt;module&gt;config-client-demo&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;tech.aistar&lt;/groupId&gt; &lt;artifactId&gt;parent-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;parent-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建注册中心模块moudle eureka-demo模块,pom.xml文件如下: 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;tech.aistar&lt;/groupId&gt; &lt;artifactId&gt;parent-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;tech.aistar&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; eureka-demo的application.yml文件配置如下: 1234567891011121314151617181920spring: application: name: eureka-demo server: port: 8888eureka: instance: # 注册到eurekaip地址 hostname: localhost client: # 因为自己是注册中心,不需要自己注册自己 register-with-eureka: false # 因为自己是注册中心,不需要检索服务 fetch-registry: false service-url: # 服务注册中心的配置内容，指定服务注册中心的位置 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ preferIpAddress: true 添加启动类: 123456789@SpringBootApplication//开启注册中心@EnableEurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 访问网页,查看EurekaServer 生产者和消费者注册及调用实战生产者 - user-demo 创建用户user-demo用户服务,pom.xml文件如下: 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; user-demo的application.yml文件配置如下: 123456789101112131415161718spring: application: name: user-demoserver: port: 8885eureka: instance: # 注册到eurekaip地址 hostname: localhost client: register-with-eureka: true fetch-registry: true service-url: # 服务注册中心的配置内容，指定服务注册中心的位置 defaultZone: http://localhost:8888/eureka/ preferIpAddress: true user-demo的启动类 12345678910@SpringBootApplication//开启eureka的客户端注解@EnableEurekaClient@EnableDiscoveryClientpublic class UserDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserDemoApplication.class, args); &#125;&#125; 消费者 - order-demo 创建moudle - order-demo订单服务,pom.xml文件如下: 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; order-demo的application.yml 123456789101112131415161718spring: application: name: order-demoserver: port: 8882eureka: instance: # 注册到eurekaip地址 hostname: localhost client: register-with-eureka: true fetch-registry: true service-url: # 服务注册中心的配置内容，指定服务注册中心的位置 defaultZone: http://localhost:8888/eureka/ preferIpAddress: true order-demo的启动类 123456789@SpringBootApplication@EnableEurekaClientpublic class OrderDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderDemoApplication.class, args); &#125;&#125; 最后,一次启动服务注册中心eureka-demo,user-demo和order-demo Feign介绍Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果 简而言之： Feign 采用的是基于接口的注解 RestTemplate和feign区别使用RestTemplate时，URL参数是以编程方式构造的，数据被发送到其他服务。 Feign是Spring Cloud Netflix库，用于在基于REST的服务调用上提供更高级别的抽象。Spring Cloud Feign在声明性原则上工作。使用Feign时，我们在客户端编写声明式REST服务接口，并使用这些接口来编写客户端程序。开发人员不用担心这个接口的实现。 实战需求:在order-demo服务中调用user-demo服务的程序. 在user-demo服务中添加controller - UserController.java 123456789101112@RestControllerpublic class UserController &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id)&#123; if(id == 1)&#123; return &quot;min&quot;; &#125;else&#123; return &quot;驰星&quot;; &#125; &#125;&#125; 修改order-demo服务pom.xml文件,添加如下配置: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 修改order-demo服务,添加FeignService.java 123456@FeignClient(value = &quot;user-demo&quot;)public interface FeignService &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id);&#125; 修改order-demo服务,添加controller - OrderController.java 12345678910111213@RestControllerpublic class OrderController &#123; @Autowired private FeignService feignService; @GetMapping(&quot;/order&quot;) public String getOrder(Integer id,String name)&#123; //调用user-demo的信息 String result = feignService.get(id); return &quot;商品名称:&quot;+name+&quot;,生成订单:&quot;+result; &#125; 修改order-demo的启动类 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class OrderDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderDemoApplication.class, args); &#125;&#125; 测试 分别启动eureka-demo,user-demo,order-demo Feign负载均衡效果测试 启动eureka-demo 启动user-demo 再次启动第二个实例user-demo,在启动之前,修改user-demo的application.yml 和UserController.java 123# 修改端口号server: port: 8886 UserController.java 为了体现俩个服务实例的区别,把”驰星”修改成”驰星1” 123456789101112@RestControllerpublic class UserController &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id)&#123; if(id == 1)&#123; return &quot;min&quot;; &#125;else&#123; return &quot;驰星1&quot;; &#125; &#125;&#125; 启动order-demo 测试1 - http://localhost:8882/order?id=2&amp;name=tom 测试2 - http://localhost:8882/order?id=2&amp;name=tom 采用”轮询”的方式进行调用! 测试3 - 断掉其中一个user-demo的服务实例,再次输入上面的地址进行测试 Eureka会将服务端的服务信息缓存到本地测试将eureka-demo服务停止,测试order-demo是否能够调用user-demo 结论:是可以正常调用的! hystrix熔断器为什么要使用熔断器? 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 为了解决这个问题，业界提出了断路器模型。 熔断器简介Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图： 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。 hystrix特性 请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力. 服务降级：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。 依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放，后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。 请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。 请求缓存是在同一请求多次访问中保证只调用一次这个服务提供者的接口，在这同一次请求第一次的结果会被缓存，保证同一请求中同样的多次访问返回结果相同。 请求合并：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。 hystrix流程结构解析 流程说明: 12345678910111213141516171819201:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.2:执行execute()/queue做同步或异步调用.3:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤.4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤.5:调用HystrixCommand的run方法.运行依赖逻辑5a:依赖逻辑调用超时,进入步骤8.6:判断逻辑是否调用成功6a:返回成功调用结果6b:调用出错，进入步骤8.7:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.8:getFallback()降级逻辑. 以下四种情况将触发getFallback调用： (1):run()方法抛出非HystrixBadRequestException异常。 (2):run()方法调用超时 (3):熔断器开启拦截调用 (4):线程池/队列/信号量是否跑满8a:没有实现getFallback的Command将直接抛出异常8b:fallback降级逻辑调用成功直接返回8c:降级逻辑调用失败抛出异常9:返回执行成功结果 服务降级实战 修改order-demo的pom.xml,增加 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; order-demo,启动类开启 1@EnableHystrix //启用熔断器 order-demo的application.yml开启hystrix功能 1234# yml开启hystrix功能feign: circuitbreaker: enabled: true order-demo服务中添加fallback类 123456789101112/** * @author success * @version 1.0 * @description:本类用来演示:调用user服务的时候,如果出现错误,则调用此处的代码 */@Componentpublic class MyFallback implements FeignService&#123; @Override public String get(Integer id) &#123; return &quot;error get(Integer id)&quot;; &#125;&#125; 修改order-demo的FeignService.java 在@FeignClient注解中添加fallback=MyFallback.class 123456@FeignClient(value = &quot;user-demo&quot;,fallback = MyFallback.class)public interface FeignService &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String get(@PathVariable(&quot;id&quot;) Integer id);&#125; 测试 - 将user-demo服务停止,然后输入 http://localhost:8882/order?id=2&amp;name=tom 出现MyFallback类中的实现语句: 1商品名称:tom,生成订单:error get(Integer id) 依赖隔离 添加OrderCommand.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.service.pool;import com.netflix.hystrix.*;/** * @author success * @version 1.0 * @description:本类用来演示:依赖隔离 * @date 2019/8/26 0026 */public class OrderCommand extends HystrixCommand&lt;String&gt;&#123; private String value; public OrderCommand(String value) &#123; super(Setter.withGroupKey( //服务分组 HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;)) //线程分组 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;)) //线程池配置 .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter() .withCoreSize(10) .withKeepAliveTimeMinutes(5) .withMaxQueueSize(10) .withQueueSizeRejectionThreshold(10000)) .andCommandPropertiesDefaults( HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))); this.value = value; &#125; @Override protected String run() throws Exception &#123; String threadName = Thread.currentThread().getName(); return threadName + &quot; || &quot; + value; &#125;&#125; 添加UserCommand.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.service.pool;import com.netflix.hystrix.*;/** * @author success * @version 1.0 * @description:本类用来演示: * @date 2019/8/26 0026 */public class UserCommand extends HystrixCommand&lt;String&gt;&#123; private String value; public UserCommand(String value) &#123; super(Setter.withGroupKey( //服务分组 HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;)) //线程分组 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;)) //线程池配置 .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter() .withCoreSize(10) .withKeepAliveTimeMinutes(5) .withMaxQueueSize(10) .withQueueSizeRejectionThreshold(10000)) .andCommandPropertiesDefaults( HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))); this.value = value; &#125; @Override protected String run() throws Exception &#123; String threadName = Thread.currentThread().getName(); return threadName + &quot; || &quot; + value; &#125;&#125; 添加OrderService.java 12345678910111213141516171819202122232425262728@Servicepublic class OrderService &#123; @Autowired private FeignService feignService; // 测试依赖隔离 public String testPool() &#123; UserCommand userCommand = new UserCommand(&quot;库里&quot;); OrderCommand orderCommand1 = new OrderCommand(&quot;篮球&quot;); OrderCommand orderCommand2 = new OrderCommand(&quot;足球&quot;); // 同步调用 String val1 = userCommand.execute(); String val2 = orderCommand1.execute(); String val3 = orderCommand2.execute(); // 异步调用// Future&lt;String&gt; f1 = userCommand.queue();// Future&lt;String&gt; f2 = userCommand.queue();// Future&lt;String&gt; f3 = userCommand.queue(); return &quot;val1=&quot; + val1 + &quot;val2=&quot; + val2 + &quot;val3=&quot; + val3; // return &quot;f1=&quot; + f1.get() + &quot;f2=&quot; + f2.get() + &quot;f3=&quot; + f3.get(); &#125;&#125; order-demo控制层添加 1234@GetMapping(&quot;/testpool&quot;)public String testPool()&#123; return orderService.testPool();&#125; 测试:http://localhost:8882/testpool 1val1=hystrix-UserPool-1 || 库里val2=hystrix-OrderPool-1 || 篮球val3=hystrix-OrderPool-2 || 足球 请求合并 如图，多个客户端发送请求调用(消费者)项目中的findOne方法，这时候在这个项目中的线程池中会发申请与请求数量相同的线程数，对EurekaServiceProvider(服务提供者)的getUserById方法发起调用，每个线程都要调用一次，在高并发的场景下，这样势必会对服务提供者项目产生巨大的压力。 请求合并就是将单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法 请求合并的原理NetFlix在Hystrix为我们提供了应对高并发的解决方案—-请求合并，如下图 通过请求合并器设置延迟时间，将时间内的，多个请求单个的对象的方法中的参数（id）取出来，拼成符合服务提供者的多个对象返回接口（getUsersByIds方法）的参数，指定调用这个接口（getUsersByIds方法），返回的对象List再通过一个方法（mapResponseToRequests方法），按照请求的次序将结果对象对应的装到Request对应的Response中返回结果。 请求合并适用场景在服务提供者提供了返回单个对象和多个对象的查询接口，并且单个对象的查询并发数很高，服务提供者负载较高的时候，我们就可以使用请求合并来降低服务提供者的负载 请求合并带来的问题 我们为这个请求人为的设置了延迟时间，这样在并发不高的接口上使用请求缓存，会降低响应速度 实现请求合并比较复杂 使用注解配置 OrderService.java中添加 12345678910111213141516171819202122/** * 演示请求合并 * @param id * @return */ @HystrixCollapser(batchMethod = &quot;findAll&quot;,collapserProperties = &#123; @HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;,value = &quot;300&quot;) &#125;) public Future&lt;String&gt; findOne(Integer id)&#123; System.out.println(&quot;被合并的请求!&quot;); return null; &#125; @HystrixCommand public List&lt;String&gt; findAll(List&lt;Integer&gt; ids)&#123; System.out.println(&quot;合并的请求&quot;); List&lt;String&gt; results = new ArrayList&lt;&gt;(); for(Integer id:ids)&#123; results.add(feignService.get(id)); &#125; return results; &#125; OrderController.java中添加 123456789101112131415161718/** * 请求合并 * @return */@GetMapping(&quot;/getMerge&quot;)public String getMerge() throws ExecutionException, InterruptedException &#123; HystrixRequestContext context = HystrixRequestContext.initializeContext(); //必须是异步 Future&lt;String&gt; r1 = orderService.findOne(1); Future&lt;String&gt; r2 = orderService.findOne(2); // Thread.sleep(1000); Future&lt;String&gt; r3 = orderService.findOne(1); //context.close(); return &quot;u1:&quot;+r1.get()+&quot;,u2:&quot;+r2.get()+&quot;r3:&quot;+r3.get();&#125; 测试 1http://localhost:8882/getMerge 观察控制台 - order-demo控制台只会出现一次”合并的请求” 1合并的请求 请求缓存 OrderService.java 12345678910111213/** * 请求缓存,如果俩次请求的cacheKey是一样的,则此处的代码仅仅会执行一次 * 此处是采用注解的配置方式 * @param id * @param cacheKey * @return */ @CacheResult @HystrixCommand(commandKey = &quot;cache-user&quot;) public String getUser(Integer id,@CacheKey Long cacheKey)&#123; System.out.println(&quot;请求缓存,如果cacheKey是一样的,则不会再执行!&quot;); return feignService.get(id); &#125; 控制层 12345678910111213141516/** * 请求缓存 * @return */ @GetMapping(&quot;/getCache&quot;) public String getCache()&#123; HystrixRequestContext context = HystrixRequestContext.initializeContext(); Long key = 9999L; String u1 = orderService.getUser(1,key); String u2 = orderService.getUser(2,9998L); context.close(); return &quot;u1:&quot;+u1+&quot;,u2:&quot;+u2; &#125; 路由网关zuul为什么需要服务网关 在分布式系统系统中，有商品、订单、用户、广告、支付等等一大批的服务，前端怎么调用呢？和每个服务一个个打交道？这显然是不可能的，这就需要有一个角色充当所有请求的入口，这个角色就是服务网关（API gateway） 客户端直接与微服务通讯的问题 客户端会多次请求不同的微服务，增加了客户端的复杂性。 存在跨域请求，在一定场景下处理相对复杂。 认证复杂，每个服务都需要独立认证。 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通讯，那么重构将会很难实施。 网关的优点 易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。 易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。 减少了客户端与各个微服务之间的交互次数。 什么是网关？服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 使用zuul 新建zuul-demo模块 pom.xml文件 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; application.xml 1spring: application: name: zuul-demoserver: port: 9000eureka: instance: hostname: localhost client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8888/eureka/ preferIpAddress: truezuul: routes: # 配置统一前缀访问 api-order: path: /api-order/** serviceId: order-demo api-user: path: /api-user/** serviceId: user-demo 启动类 1@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient// 开启zuul功能@EnableZuulProxypublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 测试路由访问 1# 测试1:http://localhost:9000/api-order/testpool# 测试2:http://localhost:9000/api-user/user/1# 测试3:http://localhost:9000/user-demo/user/1# 测试4:http://localhost:9000/order-demo/testpool 都是允许访问的 配置统一前缀访问 1zuul: routes: # 配置统一前缀访问 api-order: path: /api-order/** serviceId: order-demo api-user: path: /api-user/** serviceId: user-demo #前缀访问 prefix: /parent 测试路由访问: 1# http://localhost:9000/parent/api-order/testpool# http://localhost:9000/parent/order-demo/testpool 忽略服务名serviceId访问 1zuul: routes: # 配置统一前缀访问 api-order: path: /api-order/** serviceId: order-demo api-user: path: /api-user/** serviceId: user-demo # 前缀访问 prefix: /parent # 忽略服务名serviceId访问 ignored-services: &quot;*&quot; 测试路由访问 1#测试 http://localhost:9000/parent/api-order/testpool -&gt;ok#测试http//localhost:9000/parent/order-demo/testpool -&gt;error 配url绑定映射 1zuul: routes: testurl: # url: http://www.iduoan.com url: http://localhost:8885/ path: /testurl/** 测试路由访问: 1# 测试 http://localhost:9000/testurl/user/1 配置URL映射负载 1ribbon: eureka: enabled: false#Ribbon请求的微服务serviceIdsuccess-user: ribbon: listOfServers: http://www.huya.com,http://www.douyu.comzuul: routes: testurl: serviceId: success-user path: /testurl/** zuul过滤器Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能，zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器，简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。 添加过滤器类1package tech.aistar.filter;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.exception.ZuulException;import com.sun.scenario.effect.FilterContext;import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;import org.springframework.stereotype.Component;/** * @author success * @version 1.0 * @description:本类用来演示: * Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能， * zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器， * 简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。 */@Componentpublic class MyFilter01 extends ZuulFilter&#123; /** * 类型包含 pre post route error * pre 代表在路由代理之前执行 * route 代表代理的时候执行 * error 代表出现错的时候执行 * post 代表在route 或者是 error 执行完成后执行 */ @Override public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; @Override public int filterOrder() &#123; // 优先级，数字越大，优先级越低 return 1; &#125; @Override public boolean shouldFilter() &#123; // 是否执行该过滤器，true代表需要过滤 return true; &#125; @Override public Object run() throws ZuulException &#123; System.out.println(&quot;1111111111111111111&quot;); return null; &#125;&#125; 高可用分布式配置中心在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 没有使用统一配置中心时，所存在的问题 配置文件分散在各个项目里，不方便维护 配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的 更新配置后，项目需要重启 有哪些开源配置中心spring-cloud/spring-cloud-confighttps://github.com/spring-cloud/spring-cloud-configspring出品，可以和spring cloud无缝配合diamondhttps://github.com/takeseem/diamonddisconfhttps://github.com/knightliao/disconfctrip apollohttps://github.com/ctripcorp/apollo/Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。 快速入门config-server 创建config-server-demo工程 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 启动类 1@SpringBootApplication@EnableConfigServerpublic class ConfigServerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerDemoApplication.class, args); &#125;&#125; 配置文件 1server: port: 9100spring: application: name: config-server-demo cloud: config: server: git: uri: https://gitee.com/guancg/config-server-demo.git 创建码云仓库 https://gitee.com/guancg/config-server-demo.git 创建测试的配置文件 文件名-环境名.后缀 config支持我们使用的请求的参数规则为： / { 应用名 } / { 环境名 } [ / { 分支名 } ]http://localhost:9100/config-server-demo/dev / { 应用名 } - { 环境名 }.yml/ { 应用名 } - { 环境名 }.propertieshttp://localhost:9100/config-server-demo-dev.properties / { 分支名 } / { 应用名 } - { 环境名 }.yml/ { 分支名 } / { 应用名 } - { 环境名 }.propertieshttp://localhost:9100/master/config-server-demo-dev.properties 快速入门config-client 创建config-client-demo模块 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 启动类 1@SpringBootApplicationpublic class ConfigClientDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientDemoApplication.class, args); &#125;&#125; 测试controller 1@RestController//刷新消息组件@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; @GetMapping(&quot;/value&quot;) public String getName()&#123; return name; &#125;&#125; bootstrap.yml 1server: port: 9201spring: application: name: config-client-demo # 指定了配置文件的应用名 cloud: config: uri: http://localhost:9100/ #Config server\\的uri profile: dev #指定的环境 label: master #指定的分支 http://localhost:9201/value Config+Bus : 实现动态刷新 config-client-demo模块添加依赖 1&lt;!--消息总件组件--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加注解 1//刷新消息组件@RefreshScopepublic class ConfigClientController &#123;&#125; 启动rabbitmq消息队列 修改配置文件 1server: port: 9201spring: application: name: config-client-demo # 指定了配置文件的应用名 cloud: config: uri: http://localhost:9100/ #Config server\\的uri profile: dev #指定的环境 label: master #指定的分支 rabbitmq: host: 192.168.2.49 port: 5672 username: guest password: guestmanagement: # 暴露总线消息地址` endpoints: web: exposure: include: &quot;bus-refresh&quot; cors: allowed-origins: &quot;*&quot; allowed-methods: &quot;*&quot; #测试 - http://localhost:9201/actuator/bus-refresh 本次测试地址：POST请求 1http://localhost:9201/actuator/bus-refresh RabbitMQ简介消息队列中间件消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。其使用场景为：异步处理，应用解耦，流量削锋和消息通讯四个场景。 什么是RabbitMQRabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括： 可靠性(Reliability)：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 灵活的路由(Flexible Routing)：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 消息集群(Clustering)：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 高可用(Highly Available Queues)：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 多种协议(Multi-protocol)：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 多语言客户端(Many Clients)：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 管理界面(Management UI)：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 跟踪机制(Tracing)：如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 插件机制(Plugin System)：RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件 架构图 主要概念RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。 Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytes， Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。 Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。 VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用. 安装自己搞定 RabbitMQ三种模式直接模式 我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。 一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。 这种模式下不需要将Exchange进行任何绑定(binding)操作消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。 创建队列 首先在浏览器登录RabbitMQ：http://192.168.2XX.129:15672 ，按照下图创建一个队列就可以了: 代码 添加依赖 1&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; yml 1server: port: 8010spring: application: name: rabbitmq-demo rabbitmq: host: 192.168.2.49 启动类 1@SpringBootApplicationpublic class RabbitmqDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RabbitmqDemoApplication.class, args); &#125;&#125; 接下来我们写生产者代码（生产者采用Junit和SpringBoot整合） 1@RunWith(SpringRunner.class)@SpringBootTestpublic class RabbitmqDemoApplicationTests &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 直接模式 */ @Test public void contextLoads() &#123; //在直接模式的队列中放入数据 rabbitTemplate.convertAndSend(&quot;j05_direc&quot;,&quot;我是直接模式!&quot;); &#125;&#125; 此时你运行生产者函数时，在消息队列的界面会显示一条消息（Ready） 消费者代码 1/** * 运行方式:直接启动springboot的启动类,在控制台观察msg * @author success * @version 1.0 * @description:本类用来演示:消费直接模式消息队列中的数据 * @date 2019/9/2 0002 */@Component@RabbitListener(queues = &quot;j05_direc&quot;)public class DirectionController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;直接模式j05_direc-&gt;msg:&quot;+msg); &#125;&#125; 当你运行消费者代码时，在run栏会打印出： 当然，你想设置多个消费者时，我们可以将springboot单例运行选项去掉 然后改掉配置文件的端口号，重新把程序跑一次，这样，就有两个消费者了，再改端口号，再运行就是三个消费者了。多运行几次生产者的测试函数，三个消费者会轮流输出（因为这里是默认负载均衡的，所有会轮流输出）。 分裂模式当我们需要将消息一次发给多个队列时，需要使用这种模式。如下图： 任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。 可以理解为路由表的模式 这种模式不需要RouteKey 这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。 如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃. 交换器绑定队列 创建三个队列 j05_direc和cctv1和cctv2 创建j05_alls交换器 将j05_alls交换器和三个队列进行绑定 这样向j05_alls交换器里发消息，交换器就会向绑定的三个消息队列里面发消息（）。 测试 生产者 1/** * 分裂模式 */@Testpublic void testFadeIn()&#123; //在分裂模式中的exchanges中放入数据 rabbitTemplate.convertAndSend(&quot;j05_alls&quot;,&quot;&quot;,&quot;我是分裂模式!&quot;);&#125; 三个消费者 消费者1 1@Component@RabbitListener(queues = &quot;j05_direc&quot;)public class DirectionController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;直接模式j05_direc-&gt;msg:&quot;+msg); &#125;&#125; 消费者2 1@Component@RabbitListener(queues = &quot;cctv1&quot;)public class FadeOutController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;分裂模式-cctv1-&gt;msg:&quot;+msg); &#125;&#125; 消费者3 1@Component@RabbitListener(queues = &quot;cctv2&quot;)public class TopicController &#123; @RabbitHandler public void getMsg(String msg)&#123; System.out.println(&quot;主题模式模式cctv2-&gt;msg:&quot;+msg); &#125;&#125; 运行后可得下面结果 主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上 如上图所示此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.newsusa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。 注：交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上 这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。这种模式需要RouteKey，也许要提前绑定Exchange与Queue。在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息 创建队列与绑定和分裂模式一样，只是在Exchanges设置里面添加Routing Key 代码编写 分裂模式一样，只需要在3个Customer类里面修改下convertAndSend的参数就可以了 1/** * 主题模式 */@Testpublic void testTopic()&#123; //分别测试 rabbitTemplate.convertAndSend(&quot;j05_topic&quot;,&quot;good.log&quot;,&quot;我是主题模式!&quot;);&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"}]},{"title":"day02","slug":"day02","date":"2021-07-16T10:02:10.000Z","updated":"2021-07-16T10:09:16.448Z","comments":true,"path":"2021/07/16/day02/","link":"","permalink":"http://example.com/2021/07/16/day02/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package tech.aistar.day02;import java.util.Date;/** * 本类用来演示: 变量的定义和使用 * * @author: success * @date: 2021/7/16 8:35 上午 */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; char类型 java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day02;/** * 本类用来演示: char类型 * * @author: success * @date: 2021/7/16 9:14 上午 */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult();/** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 1final 数据类型 变量 [= 初始值]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day02;/** * 本类用来演示: 局部变量和全局变量 * * @author: success * @date: 2021/7/16 10:04 上午 */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符11. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符1&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. ​ 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 ​ 连接条件:为true - 所有的条件表达式都是返回true & 8 1234567892. | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. **计算:只要存在一个1,结果就是1** 连接条件:为true - 只要存在一个条件表达式为true. ~~~java 10 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 110 ^ 8 = 2 1 0 1 0| 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 10 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 1笔试题: 交换俩个变量的值,不允许出现第三方变量 package tech.aistar.day02; /** * 本类用来演示: 笔试题: 交换俩个变量的值,不允许出现第三方变量 * * @author: success * @date: 2021/7/16 11:09 上午 */ public class ChangeVarValue &#123; public static void main(String[] args) &#123; //1. 使用第三方变量 int a = 10; int b = 20; int temp = a; a = b; b = temp; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); //一个数字连续异或同一个数字俩次结果是它本身. int m = 100; int n = 200; m = m ^ n;//m = 100 ^ 200 n = m ^ n;//n = 100 ^ 200 ^ 200 = 100 m = m ^ n;//m = 100 ^ 200 ^ 100 = 200 System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); //自创写法(success独家的) - 不推荐写 - 防止菜鸟看不懂 int x = 100; int y = 200; //y = 100 ^ 200 ^ 200 = 100 y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); &#125; &#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 1补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少?计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 111101013. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果-10 = ~9结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 1&lt;&lt; 向左移动2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-10 &gt;&gt; 2 = -311111111 11111111 11111111 11110110 &gt;&gt; 211111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是100000000 00000000 00000000 00000010 取反 ~2=-3&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 练习-15&gt;&gt;2 -15&gt;&gt;&gt;2 -15 = ~14 11111111…… 0001 &gt;&gt;&gt; 2 00111111 11111111 11111111 11111101 00111111 11111111 11111111 1111100 = 1073741820 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 1return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 1不需要使用return + 返回值; 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 1public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数) } //int m = test01(20,12);//m-&gt;4 public static int test02(int m,int n){ int 公约数 = test01(m,n); return mn/公约数; } int n = test02(20,12);//n-&gt;60=2012/4=60 1 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 可变长列表 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式 取决于这个方法是静态的还是非静态的 - static 12package tech.aistar.day02.method;/** * 本类用来演示: 方法的定义 * * @author: success * @date: 2021/7/16 2:20 下午 */public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&gt;package tech.aistar.day02.method;&gt;/**&gt;* 本类用来演示:&gt;*&gt;* @author: success&gt;* @date: 2021/7/16 2:43 下午&gt;*/&gt;public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&gt;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"day01","slug":"day01","date":"2021-07-15T09:54:17.000Z","updated":"2021-07-16T10:07:17.910Z","comments":true,"path":"2021/07/15/day01/","link":"","permalink":"http://example.com/2021/07/15/day01/","excerpt":"","text":"Java能做什么 传统的项目 - 简单的,公司内部使用的,不会存在高并发的问题. 教务管理系统,OA自动化办公系统,CRM客户关系管理系统,ERP企业资源计划系统 B2C - 典型的电子商务模式,涉及到高并发的业务 企业2客户 - 企业卖自己的服务或者产品 C2B2C - 新型的模式 - 淘宝 平台 - 对双方进行监管 卖家 买家 大数据 - 一定是对业务非常熟悉[数据分析,数据非常敏感] Java的历史 原先是属于SUN公司[Stanford University Network 斯坦福网络大学] Sun Microsystem - 太阳微电子公司 后来在2010年10月份被Oracle公司[出名的产品-oracle数据库 - NO.1] 74亿美金收购 - www.oracle.com 前身Oak语言[橡树],印度尼西亚的爪哇岛[咖啡豆 - javabean] 诞生于1995年5月23日,96年正式推出jdk1.0版本. 商用的jdk版本 - jdk8.x , jdk11.x ,jdk16.x java之父 - james gosling 詹姆斯 高斯林 Java支持的三个平台 原先的名称j2se , j2ee, j2me JavaSE - Java Standard Editional - Java标准版 适合做桌面应用程序[维护比较麻烦,服务器端如果更新,客户端需要更新],包含了java里面的基础的语法,核心 JavaEE - 2018年 - JakartaEE - 雅佳达EE - Java Enterprise Editional - Java企业版 是一套技术的规范的体系.不是一门具体的技术.里面包含了13种核心技术 比如jdbc,servlet等遵守javaee的规范.现在javaee里面的核心技术已经使用不多了 现在普遍都在使用spring全家桶中的技术. 适合做web应用程序[web网站] JavaME - Java Micro Editional - Java微型版,适合做手持设备 - “不用” 检测一下jdk的环境变量是否配置成功 打开终端,输入cmd - 输入java -version 1234admindeMacBook-Pro:Desktop admin$ java -versionjava version &quot;1.8.0_66&quot;Java(TM) SE Runtime Environment (build 1.8.0_66-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) 环境变量的配置 Java.zip - 解压缩 - 比如放在D盘 所有的软件不要放在中文目录下,不要放在带有特殊符号的目录下[programe files(x86)] 尽量不要放在C盘[权限的问题,拒绝你的访问的] 桌面 - 右击计算机 - 属性 - 高级系统设置 - 环境变量(N) - 定位到系统变量 新建 变量名:JAVA_HOME 变量值:jdk1.8.0_66的绝对路径 确定 找到内置的变量名Path - 编辑 - 新建 %JAVA_HOME%\\bin 关闭刚所有打开的设置窗口,重新打开终端[黑窗口] win+r - cmd -&gt;输入 java -version Java语言特点 简单 可移植性 面向对象 - 核心 与平台无关性[跨平台性,跨操作系统平台] 安全性 - 本身是属于强类型的语言.在编译期间就要确定数据的类型. JDK和JRE和JVM 三者之间的区别 - 简单题 - 笔试 JDK - Java Development Kit - Java开发工具包,针对于开发者的.包含了很多开发工具 比如java.exe , javac.exe, javadoc.exe , jar.exe等 JDK中是包含JRE的 JRE - Java Runtime Enviroment - Java运行时环境,包含了很多核心的内库. 针对于使用java语言开发出来软件的用户.如果一个用户仅仅想运行一个java程序的话 那么计算机中只需要安装jre即可. JRE包含JVM JVM - Java Virtual Machine - Java虚拟机 - 后期重点详细介绍jvm[笔试的大头 - 内存模型] jvm本身就是用C语言编写的 - jvm的源码通读一遍. java程序并不是直接在计算机中进行跑的.而是在虚拟机上执行的.虚拟机是安装在操作系统上的. 注意的是java语言是跨平台的[使用java语言编写的程序可以运行在不同的os上],但是jvm不是跨平台的 不同的操作系统需要安装不同的jvm HelloWorld程序 java的基础单元是类class 类的命名 - 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头 推荐使用”大驼峰”命名规则,单词首字母必须要大写.其余单词小写 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字[java语言赋予了这些单词具备一定的语法含义] byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue,class, public,private,protected等 不能是java中的保留关键字 - goto,const 不推荐使用中文,防止出现乱码问题. 不推荐使用中文的拼音 推荐见名知意 不能是以下三个字面量 - true,false,null 代码 在D盘根目下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 记事本打开HelloWorld.java文件 12345678910111213141516171819//编程语言中,只要出现了符号,一定必须都是英文输入法下的//整体的结构//java是以类作为基础的单位的 - 定义类//关键是class//类的名称要和文件的名称高度保持一致//&#123;&#125; - block - 块 - 代码块public class HelloWorld&#123;//1. 类 //规范 - 缩进四个空格 //定义一个main方法 - 程序的&quot;大门&quot; //运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main //方法中去执行 //今天先记住语法 public static void main(String[] args)&#123;//2. 方法 //方法体,现阶段代码一定是放在方法体内部的. //jdk中提供了内置的对象[拥有一些功能],提供好了,开发者就可以直接使用 //java.lang.System类 - 向控制台输出一句话 System.out.println(&quot;HelloWorld&quot;);//3. 具体的程序 &#125;&#125; java源代码是不能够直接执行的.因为计算机是不识别java语言程序的. 需要对.java为后缀的源文件进行一个编译操作.如果一旦语法发生了问题,都会导致编译失败. 假设HelloWorld.java文件是放在D盘根目录下,需要打开终端,然后通过dos命令进入到D盘 12C:/User/admin&gt;d:D:/&gt;javac HelloWorld.java 效果,javac.exe工具其实就是在调用jdk中的编译器,作用:就是.java源文件编译成.class字节码文件 思考如何运行一个java程序呢? 利用java.exe 1D:/&gt;java HelloWorld 过程 编写.java源代码 javac.exe - 编译 java.exe - 执行 Java程序的执行的原理 12345678.java源文件 -&gt; 经过jdk中的编译器,成为.class字节码文件 -&gt; 经过jvm中的解释器[进行逐行翻译(解释)]-&gt; 机器能够识别的符号java属于解释型的语言,&quot;JVM把它YY成以.class字节码为指令的CPU&quot;编译型语言 - C语言,将这个语言编写的程序直接编译成计算机能够执行的程序.比如C语言写的代码可以直接编译成可执行文件 xx.exeC语言执行的性能高于java语言(每次执行都会经过jvm解释器进行解释) 集成开发环境 eclipse[日食] - 免费的,IBM公司的产品[收购SUN公司的] idea - 最好的,收费的 d:/aistar/j03s_student Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 ​ com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. java中三种注释 单行注释 // ctrl+/ 添加/取消注释 多行注释 12345/* * * 多行注释的内容 - 注释的内容是不会经过jdk的编译器的 * */ 文档注释 可以生成文档树 123456/*** 放在类上面* 放在方法上**/ main方法细节12345678910public[公开的,公共的] static[静态的] - 都是属于后期学习OO中的修饰符修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args - 我们传给虚拟机的参数 输出语句 System.out.println(); // 换行 1System.out.print(&quot;\\n&quot;); \\n和\\r 1package tech.aistar.day01;/** * 本类用来演示: \\n \\r * * @author: success * @date: 2021/7/15 3:18 下午 */public class NrDemo &#123; public static void main(String[] args) &#123; //相当于是System.out.println(&quot;hello&quot;); System.out.print(&quot;hello\\n&quot;);//输出之后不换行 System.out.println(&quot;world&quot;); // \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 // \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 // \\n\\r 诞生的场景就是早期的打字机 //外面的终端执行的结果是 - veyy √ //伪终端显示的结果是 - ve System.out.println(&quot;Loyy\\rve&quot;); &#125;&#125; 特殊字符 \\ 是代表转义字符 \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 \\b - 退格 \\t - 制表符,相当于tab键,默认是空4格 双引号 1\\&quot; 单引号 1\\&#x27; 单个\\ 1\\\\ 123456789101112131415161718192021222324252627282930package tech.aistar.day01;/** * 本类用来演示: 特殊字符 * * @author: success * @date: 2021/7/15 3:35 下午 */public class SignDemo &#123; public static void main(String[] args) &#123; //\\b - 退格 System.out.println(&quot;xxx\\byy&quot;);//xxyy //\\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); //输出 james:&quot;success is good boy&quot; //双引号 System.out.println(&quot;james:\\&quot;success is good boy\\&quot;&quot;); // \\ 转义含义 //单个\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); //输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量 编程的核心就是从定义变量开始 java语言是一个强类型的语言[在编译期间必须要确定好数据的类型],javascript弱类型的语言 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作. 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库) - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型 java中的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 数据类型决定了存储数据的这块空间的大小,并且这个大小一旦确定了,将不能够改变了. 对象类型(无数种) 2-1. 内置对象类型 - System,String - Jdk中提供的类 2-2. 自定义对象类型 - 自己定义的那些类HelloWorld,SignDemo 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 变量的定义 变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 语法 1数据类型 变量名 [= 变量值]; 剖析变量的背后1package tech.aistar.day01;/** * 本类用来演示: 变量入门 * * @author: success * @date: 2021/7/15 3:43 下午 */public class VarDemo &#123; public static void main(String[] args) &#123; //数据类型 变量名 [= 变量值]; byte b = 10; //代码的背后 - 埋了个&quot;种子&quot;,&quot;发芽&quot; //1. 数据肯定是存储在JVM内存中的 //2. 定义在方法内部的变量 - 局部变量[JVM的栈区] //3. 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //讲解的本质 //流程 //1. JVM加载VarDemo.class到内存 //2. JVM找到main方法想要去执行里面的程序 //3. 此处需要申请一块区域来保存数据10 // 3-1. 区域的大小由前面的数据类型来决定的 - int类型 - 区域4个字节32bit的大小 // 3-2. 栈里面的区域的大小一旦被确定了,就不能改变 - 肯定有的时候会有内存的浪费 // 3-3. 虽然空间浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; //4. 只要是内存中的空间,这个空间必然会有一个地址,所以变量的存在是为了给这个区域取了个名字 // 变量是为了方便用户来通过它访问到这个空间中存储的具体的那个值的 //把整数10赋值给一个int类型的变量a int a = 10; System.out.println(a); // == 比较的就是&quot;坑 - 区域&quot;里面存储的数据 System.out.println(b == a);//true &#125;&#125; 数据类型的转换 常识规定 a. java中看到一个整数,默认就是int类型 b. java中看到一个小数,默认就是double类型 c. 大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型. byte-&gt;short-&gt;int-&gt;long char-&gt;int int-&gt;double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 隐式转换 1234567int-&gt;long整数后面添加l/Ldouble-&gt;float小数后面加上f/F推荐在double后面加上d/D - 提高语义","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"hexoA","slug":"hexoA","date":"2021-07-13T07:20:57.000Z","updated":"2021-07-15T11:18:40.446Z","comments":true,"path":"2021/07/13/hexoA/","link":"","permalink":"http://example.com/2021/07/13/hexoA/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功 如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 123[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 12D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 12345overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1234567891011121314151617181920212223242526272829303132333435常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1234title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1234# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 12345678910valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1234deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1234hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"Java","slug":"java","date":"2021-07-12T08:51:44.000Z","updated":"2021-07-15T11:19:22.059Z","comments":true,"path":"2021/07/12/java/","link":"","permalink":"http://example.com/2021/07/12/java/","excerpt":"","text":"无聊的知识 java 1 1 2 3 1psvm 字体粗体: 粗 斜体：斜 粗斜体：粗斜 高亮体：高亮 1 表格 111 1 11 222 2 22 333 3 33 图片 结束 7.12","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-12T06:46:58.326Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/07/12/hello-world/","link":"","permalink":"http://example.com/2021/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"},{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}