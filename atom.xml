<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YangBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-07T06:26:36.665Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringClound</title>
    <link href="http://example.com/2021/10/19/springclound/"/>
    <id>http://example.com/2021/10/19/springclound/</id>
    <published>2021-10-19T07:20:57.000Z</published>
    <updated>2022-01-07T06:26:36.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ol><li><p>springcloud的组件哪些?</p><p>Eureka,Ribbon,Feign</p></li><li><p>Eureka - 治理服务 -SOA架构</p><p>Eureka-server - 服务中心 - 可以做集群 - 降低各个服务之间耦合.服务于服务之间不需要关心具体怎么通信.</p><p>Eureka-client - 服务客户端,每次启动客户端的时候,需要将客户端的信息[名称,网络信息]注册到eureka-server</p><p>每30s会向eureka-server发送一次心跳 - 目的是为了告诉eureka-server它还活着,想要续约.如果超过90s,eureka-server接受不到该客户的心跳,那么再比例[失败的比例如果低于85%],那么就会剔除.</p></li><li><p>Ribbon</p><p>提供负载均衡策略,rest方式[RestTemplate + ribbon]</p></li><li><p>Feign</p><p>基于Ribbon,Feign最主要的作用是用来提供服务于服务之间的通信的问题.默认提供了负载均衡</p></li><li><p>nginx负载均衡(服务器端)和Feign/Ribbon负载均衡(客户端)区别  -   负载均衡的策略</p></li><li><p>SpringCloud2020版本开始,剔除了netflix项目[不进行更新了,仍然会继续维护bug]的组件,保留了Eureka组件.</p></li></ol></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><ol><li><p>分布式 - 将一个庞大的系统按照模块进行拆分,拆分成若干个子模块[微服务] , 进行分布式的部署[各个服务部署在不同的服务器]</p><p>着重点 - 有无进行分布式部署 - <strong>部署的方式</strong></p></li><li><p>微服务 - 架构风格,微服务不一定是分布式的.但是分布式微服务架构的.</p><p>“每个微服务都是单独的独立的工程项目,可以进行单独的部署 = 不同的人做不同的事情”</p></li><li><p>集群 - “很多人做同一件事情” - 分布式上的每个节点[微服务]都是可以进行集群的.</p><p>解决”三高” - 高并发,高性能,高可用</p></li><li><p>单体架构 - 整个项目都在一个工程里面,一起进行部署的.弊端 - 如果项目中的某个模块修改了,需要整体重新打包,重新部署.</p><p>如果某个模块”坏掉了” - 导致整个项目都”崩”</p></li></ol></blockquote><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ol><li><p>什么是我服务?</p><ul><li>微服务是一种架构风格，也是一种服务；</li><li>微服务的颗粒比较小，一个大型复杂软件应用由多个微服务组成，比如Netflix目前由500多个的微服务组成；</li><li>它采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。</li></ul></li><li><p>微服务架构图</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\small.png"> </p></li><li><p>微服务好处</p><ul><li>技术异构性：在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。</li><li>弹性：如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。</li><li>扩展：可以只对那些需要扩展的服务进行扩展。<br>简化部署：各个服务的部署是独立的，这样就可以更快地对特定部分的代码进行部署。</li><li>与组织结构相匹配：可以很好地将架构与组织结构相匹配，避免出现过大的代码库，从而获得理想团队大小及生产力。</li><li>可组合性：不同服务模块的接口可以再进行重用，成为其他产品中的一个组件；</li><li>对可替代性的优化：可以在需要时轻易地重写服务，或者删除不再使用的服务</li></ul></li><li><p>微服务缺点</p><ul><li><p><em><strong>运维开销</strong></em><br>更多的服务也就意味着更多的运维，产品团队需要保证所有的相关服务都有完善的监控等基础设施，传统的架构开发者只需要保证一个应用正常运行，而现在却需要保证几十甚至上百道工序高效运转，这是一个艰巨的任务。</p></li><li><p><em><strong>DevOps要求</strong></em><br>使用微服务架构后，开发团队需要保证一个Tomcat集群可用，保证一个数据库可用，这就意味着团队需要高品质的DevOps和自动化技术。而现在，这样的全栈式人才很少。</p></li><li><p><em><strong>隐式接口</strong></em><br>服务和服务之间通过接口来“联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做调整。</p></li><li><p><em><strong>重复劳动</strong></em><br>在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这个时候可能不同的服务团队都会单独开发这一功能，重复的业务逻辑，这违背了良好的软件工程中的很多原则。</p></li><li><p><em><strong>分布式系统的复杂性</strong></em><br>微服务通过REST API或消息来将不同的服务联系起来，这在之前可能只是一个简单的远程过程调用。分布式系统也就意味着开发者需要考虑网络延迟、容错、消息序列化、不可靠的网络、异步、版本控制、负载等，而面对如此多的微服务都需要分布式时，整个产品需要有一整套完整的机制来保证各个服务可以正常运转。</p></li><li><p><em><strong>事务、异步、测试面临挑战</strong></em><br>跨进程之间的事务、大量的异步处理、多个微服务之间的整体测试都需要有一整套的解决方案，而现在看起来，这些技术并没有特别成熟。</p></li></ul></li></ol><h1 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h1><ul><li><p>springcloud是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。</p></li><li><p>通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p></li><li><p>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix</p></li></ul><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\springcloud.jpg"> </p><p>下面简单介绍下经常用的5个:</p><p>服务发现——Netflix Eureka</p><p>客服端负载均衡——Netflix Ribbon(<strong>重点掌握Netflix Feign</strong>)</p><p>断路器——Netflix Hystrix</p><p>服务网关——Netflix Zuul</p><p>分布式配置——Spring Cloud Config</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\eureka.jpg"> </p><p>作用：实现服务治理（服务注册与发现）</p><p>简介：Spring Cloud Eureka是Spring Cloud Netflix[停止更新]项目下的服务治理模块。</p><p>由两个组件组成：Eureka服务端和Eureka客户端。</p><p>Eureka服务端用作服务注册中心。支持集群部署。</p><p>Eureka客户端是一个java客户端，用来处理服务注册与发现。</p><p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\ribbon.jpg"> </p><p>作用：Ribbon，主要提供客户侧的软件负载均衡算法。</p><p>简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</p><p>注意看上图，关键点就是将外界的rest调用，根据负载均衡策略转换为微服务调用。Ribbon有比较多的负载均衡策略，以后专门讲解。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix.jpg"> </p><p>作用：断路器，保护系统，控制故障范围。</p><p>简介：为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\zuul.jpg">  </p><p>作用：api网关，路由，负载均衡等多种作用</p><p>简介：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p><p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。</p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\config.jpg"> </p><p>作用：配置管理</p><p>简介：SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。</p><p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p><h2 id="相关组件架构图"><a href="#相关组件架构图" class="headerlink" title="相关组件架构图"></a>相关组件架构图</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\all.png">  </p><p>从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。</p><ul><li>其中Eureka负责服务的注册与发现，很好将各服务连接起来</li><li>Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li><li>Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示</li><li>Spring Cloud Config 提供了统一的配置中心服务</li><li>当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息</li><li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用</li><li>最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析</li></ul><h2 id="为什么要使用springcloud"><a href="#为什么要使用springcloud" class="headerlink" title="为什么要使用springcloud"></a>为什么要使用springcloud</h2><p>Spring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利。</p><p>微服务架构是一种趋势，Spring Cloud提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><h1 id="Eureka服务与注册"><a href="#Eureka服务与注册" class="headerlink" title="Eureka服务与注册"></a>Eureka服务与注册</h1><h2 id="为什么需要服务中心"><a href="#为什么需要服务中心" class="headerlink" title="为什么需要服务中心"></a>为什么需要服务中心</h2><p>过去，每个应用都是一个CPU，一个主机上的单一系统。然而今天，随着大数据和云计算时代的到来，任何独立的程序都可以运行在多个计算机上。并且随着业务的发展，访问用户量的增加，开发人员或小组的增加，系统会被拆分成多个功能模块。拆分后每个功能模块可以作为一个独立的子系统提供其职责范围内的功能。而多个子系统中，由于职责不同并且会存在相互调用，同时可能每个子系统还需要多个实例部署在多台服务器或者镜像中，导致了子系统间的相互调用形成了一个错综复杂的网状结构</p><p><strong>对于微服务之间错综复杂的调用关系，通过eureka来管理，可以让每个服务之间不用关心如何调用的问题，专注于自己的业务功能实现。</strong></p><h2 id="Eureka的管理"><a href="#Eureka的管理" class="headerlink" title="Eureka的管理"></a>Eureka的管理</h2><ul><li>服务需要有一个统一的名称（或服务ID）并且是唯一标识，以便于接口调用时各个接口的区分。并且需要将其注册到Eureka Server中，其他服务调用该接口时，也是根据这个唯一标识来获取。</li><li>服务下有多个实例，每个实例也有一个自己的唯一实例ID。因为它们各自有自己的基础信息如：不同的IP。所以它们的信息也需要注册到Eureka Server中，其他服务调用它们的服务接口时，可以查看到多个该服务的实例信息，根据负载策略提供某个实例的调用信息后，调用者根据信息直接调用该实例。</li></ul><h2 id="Eureka如何管理服务调用"><a href="#Eureka如何管理服务调用" class="headerlink" title="Eureka如何管理服务调用"></a>Eureka如何管理服务调用</h2><ul><li>在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。然后进行2调用当前服务器节点中的其他服务信息，保存到Eureka Client中。当服务间相互调用其它服务时，在Eureka Client中获取服务信息（如服务地址，端口等）后，进行第3步，根据信息直接调用服务。（注：服务的调用通过http(s)调用）</li><li>当某个服务仅需要调用其他服务，自身不提供服务调用时。在Eureka Client启动后会拉取Eureka Server的其他服务信息，需要调用时，在Eureka Client的本地缓存中获取信息，调用服务。</li><li>Eureka Client通过向Eureka Serve发送心跳（默认每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 以此来确保当前服务还“活着”，可以被调用。</li><li>来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次），以此来确保调用到的服务是“活的”。并且当某个服务被更新或者新加进来，也可以调用到新的服务。</li></ul><h2 id="Eureka-Server和Eureka-Client"><a href="#Eureka-Server和Eureka-Client" class="headerlink" title="Eureka Server和Eureka Client"></a>Eureka Server和Eureka Client</h2><ul><li><p>Eureka Server</p><ul><li><p>提供服务注册：各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如服务信息和网络信息），Eureka Server会存储该服务的信息。</p></li><li><p>提供服务信息提供：服务消费者在调用服务时，本地Eureka Client没有的情况下，会到Eureka Server拉取信息。</p></li><li><p>提供服务管理：通过Eureka Client的Cancel、心跳监控、renew等方式来维护该服务提供的信息以确保该服务可用以及服务的更新。</p></li><li><p>信息同步：每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过P2P复制的方式完成服务注册表的同步</p></li></ul></li><li><p>Eureka Client</p><ul><li><p>Eureka Client是一个Java客户端，用于简化与Eureka Server的交互。并且管理当前微服务，同时为当前的微服务提供服务提供者信息。</p></li><li><p><strong>Eureka Client会拉取、更新和缓存Eureka Server中的信息</strong>。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。</p></li><li><p>Eureka Client在微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）。</p></li></ul></li></ul><h2 id="服务续约、下线、剔除"><a href="#服务续约、下线、剔除" class="headerlink" title="服务续约、下线、剔除"></a>服务续约、下线、剔除</h2><ul><li><p>服务续约</p><p>Application Service内的Eureka Client后台启动一个定时任务，跟Eureka Server保持一个心跳续约任务，每隔一段时间(默认30S)向Eureka Server发送一次renew请求，进行续约，告诉Eureka Server我还活着，防止被Eureka Server的Evict任务剔除。</p></li><li><p>服务下线</p><p>Application Service应用停止后，向Eureka Server发送一个cancel请求，告诉注册中心我已经退出了，Eureka Server接收到之后会将其移出注册列表，后面再有获取注册服务列表的时候就获取不到了，防止消费端消费不可用的服务。</p></li><li><p>服务剔除</p><p>Eureka Server启动后在后台启动一个Evict任务，对一定时间内没有续约的服务进行剔除。</p></li></ul><ul><li><p>服务通讯方式</p><p>服务间使用标准的REST方式通讯，所以Eureka服务注册中心并不仅适用于Java平台，其他平台也可以纳入到服务治理平台里面。</p></li></ul><ul><li><p>自我保护</p><p>本地调试Eureka的程序时，会出现：　</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\safe.png"> </p><p>该警告是触发了Eureka Server的自我保护机制。</p><p>Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果低于，就会将当前实例注册信息保护起来，让实例不会过期，尽可能保护这些注册信息。</p><p>但是如果在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。这个时候客户端的容错机制就很重要了。（重新请求，断路器）</p><p>保护机制，可能会导致服务实例不能够被正确剔除。</p><p>在本地开发时，可使用：eureka.server.enable-self-preservation=false关闭保护机制，使不可用实例能够正常下线。</p></li></ul><h2 id="Eureka和Zookeeper区别"><a href="#Eureka和Zookeeper区别" class="headerlink" title="Eureka和Zookeeper区别"></a>Eureka和Zookeeper区别</h2><p>Eureka：可以在发生因网络问题导致的各节点失去联系也不会暂停服务，但是最新的数据可能不统一。</p><p>Zookeeper：如果发生网络问题导致的Master和其他节点失去联系，就会使得其他的节点推选出新的Master，但是推选的时间内无法提供服务，但是可以保证任何时候的数据都是统一的。</p><h1 id="基于idea多模块搭建eureka注册中心"><a href="#基于idea多模块搭建eureka注册中心" class="headerlink" title="基于idea多模块搭建eureka注册中心"></a>基于idea多模块搭建eureka注册中心</h1><ul><li><p>首先创建父工程parent-demo,父工程pom.xml配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>user-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>order-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>zuul-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>config-server-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>config-client-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tech.aistar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>parent-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建注册中心模块moudle</p><p>eureka-demo模块,pom.xml文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tech.aistar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tech.aistar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eureka-demo的application.yml文件配置如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-demo</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 注册到eurekaip地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 因为自己是注册中心,不需要自己注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 因为自己是注册中心,不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">        <span class="comment"># 服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">        <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>添加启动类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启注册中心</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(EurekaDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问网页,查看EurekaServer</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\server.png"> </p></li></ul><h1 id="生产者和消费者注册及调用实战"><a href="#生产者和消费者注册及调用实战" class="headerlink" title="生产者和消费者注册及调用实战"></a>生产者和消费者注册及调用实战</h1><h2 id="生产者-user-demo"><a href="#生产者-user-demo" class="headerlink" title="生产者 - user-demo"></a>生产者 - user-demo</h2><ul><li><p>创建用户user-demo用户服务,pom.xml文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>user-demo的application.yml文件配置如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8885</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 注册到eurekaip地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">        <span class="comment"># 服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka/</span></span><br><span class="line">        <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>user-demo的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启eureka的客户端注解</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(UserDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="消费者-order-demo"><a href="#消费者-order-demo" class="headerlink" title="消费者 - order-demo"></a>消费者 - order-demo</h2><ul><li><p>创建moudle - order-demo订单服务,pom.xml文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo的application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8882</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 注册到eurekaip地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">        <span class="comment"># 服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka/</span></span><br><span class="line">        <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(OrderDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后,一次启动服务注册中心eureka-demo,user-demo和order-demo</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\user-order.png"> </p><h1 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h1><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon，并和Eureka结合，默认实现了<strong>负载均衡</strong>的效果</p><p>简而言之：</p><p>Feign 采用的是基于接口的注解</p><h2 id="RestTemplate和feign区别"><a href="#RestTemplate和feign区别" class="headerlink" title="RestTemplate和feign区别"></a>RestTemplate和feign区别</h2><p>使用RestTemplate时，URL参数是以编程方式构造的，数据被发送到其他服务。</p><p>Feign是Spring Cloud Netflix库，用于在基于REST的服务调用上提供更高级别的抽象。Spring Cloud Feign在声明性原则上工作。使用Feign时，我们在客户端编写声明式REST服务接口，并使用这些接口来编写客户端程序。开发人员不用担心这个接口的实现。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>需求:在order-demo服务中调用user-demo服务的程序.</p><ul><li><p>在user-demo服务中添加controller - UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;min&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;驰星&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo服务pom.xml文件,添加如下配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改order-demo服务,添加FeignService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo服务,添加controller - OrderController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeignService feignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrder</span><span class="params">(Integer id,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用user-demo的信息</span></span><br><span class="line">        String result = feignService.get(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品名称:&quot;</span>+name+<span class="string">&quot;,生成订单:&quot;</span>+result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(OrderDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>分别启动eureka-demo,user-demo,order-demo</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\order_invoke_user.png"> </p></li></ul><h2 id="Feign负载均衡效果测试"><a href="#Feign负载均衡效果测试" class="headerlink" title="Feign负载均衡效果测试"></a>Feign负载均衡效果测试</h2><ul><li><p>启动eureka-demo</p></li><li><p>启动user-demo</p></li><li><p>再次启动第二个实例user-demo,在启动之前,修改user-demo的application.yml</p><p>和UserController.java</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8886</span></span><br></pre></td></tr></table></figure><p>UserController.java</p><p>为了体现俩个服务实例的区别,把”驰星”修改成”驰星1”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;min&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;驰星1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动order-demo</p></li><li><p>测试1 - <a href="http://localhost:8882/order?id=2&amp;name=tom">http://localhost:8882/order?id=2&amp;name=tom</a></p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\feign01.png"> </p></li><li><p>测试2 - <a href="http://localhost:8882/order?id=2&amp;name=tom">http://localhost:8882/order?id=2&amp;name=tom</a></p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\feign02.png"> </p><p><strong>采用”轮询”的方式进行调用!</strong></p></li><li><p>测试3 - 断掉其中一个user-demo的服务实例,再次输入上面的地址进行测试</p></li></ul><h1 id="Eureka会将服务端的服务信息缓存到本地测试"><a href="#Eureka会将服务端的服务信息缓存到本地测试" class="headerlink" title="Eureka会将服务端的服务信息缓存到本地测试"></a>Eureka会将服务端的服务信息缓存到本地测试</h1><p>将eureka-demo服务停止,测试order-demo是否能够调用user-demo</p><p>结论:是可以正常调用的!</p><h1 id="hystrix熔断器"><a href="#hystrix熔断器" class="headerlink" title="hystrix熔断器"></a>hystrix熔断器</h1><p>为什么要使用熔断器?</p><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><p>为了解决这个问题，业界提出了断路器模型。</p><h2 id="熔断器简介"><a href="#熔断器简介" class="headerlink" title="熔断器简介"></a>熔断器简介</h2><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix01.png">  </p><p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix02.png"> </p><p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。</p><h2 id="hystrix特性"><a href="#hystrix特性" class="headerlink" title="hystrix特性"></a>hystrix特性</h2><ul><li><p>请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).</p><p>这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p></li><li><p><strong>服务降级</strong>：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。</p></li><li><p>依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放，后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。</p></li><li><p>请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。</p><blockquote><p>请求缓存是在同一请求多次访问中保证只调用一次这个服务提供者的接口，在这同一次请求第一次的结果会被缓存，保证同一请求中同样的多次访问返回结果相同。</p></blockquote></li><li><p><strong>请求合并</strong>：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。</p></li></ul><h2 id="hystrix流程结构解析"><a href="#hystrix流程结构解析" class="headerlink" title="hystrix流程结构解析"></a>hystrix流程结构解析</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix03.png">  </p><p>流程说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.</span><br><span class="line"><span class="number">2</span>:执行execute()/queue做同步或异步调用.</span><br><span class="line"><span class="number">3</span>:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤<span class="number">8</span>,进行降级策略,如果关闭进入步骤.</span><br><span class="line"><span class="number">4</span>:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤<span class="number">8</span>,否则继续后续步骤.</span><br><span class="line"><span class="number">5</span>:调用HystrixCommand的run方法.运行依赖逻辑</span><br><span class="line">5a:依赖逻辑调用超时,进入步骤<span class="number">8.</span></span><br><span class="line"><span class="number">6</span>:判断逻辑是否调用成功</span><br><span class="line">6a:返回成功调用结果</span><br><span class="line">6b:调用出错，进入步骤<span class="number">8.</span></span><br><span class="line"><span class="number">7</span>:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.</span><br><span class="line"><span class="number">8</span>:getFallback()降级逻辑.</span><br><span class="line">  以下四种情况将触发getFallback调用：</span><br><span class="line"> (<span class="number">1</span>):run()方法抛出非HystrixBadRequestException异常。</span><br><span class="line"> (<span class="number">2</span>):run()方法调用超时</span><br><span class="line"> (<span class="number">3</span>):熔断器开启拦截调用</span><br><span class="line"> (<span class="number">4</span>):线程池/队列/信号量是否跑满</span><br><span class="line">8a:没有实现getFallback的Command将直接抛出异常</span><br><span class="line">8b:fallback降级逻辑调用成功直接返回</span><br><span class="line">8c:降级逻辑调用失败抛出异常</span><br><span class="line"><span class="number">9</span>:返回执行成功结果</span><br></pre></td></tr></table></figure><h2 id="服务降级实战"><a href="#服务降级实战" class="headerlink" title="服务降级实战"></a>服务降级实战</h2><ul><li><p>修改order-demo的pom.xml,增加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo,启动类开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">//启用熔断器</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo的application.yml开启hystrix功能</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml开启hystrix功能</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo服务中添加fallback类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:本类用来演示:调用user服务的时候,如果出现错误,则调用此处的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallback</span> <span class="keyword">implements</span> <span class="title">FeignService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error get(Integer id)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo的FeignService.java</p><p><strong>在@FeignClient注解中添加fallback=MyFallback.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-demo&quot;,fallback = MyFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试 - 将user-demo服务停止,然后输入</p><p><a href="http://localhost:8882/order?id=2&amp;name=tom">http://localhost:8882/order?id=2&amp;name=tom</a></p><p>出现MyFallback类中的实现语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">商品名称:tom,生成订单:<span class="function">error <span class="title">get</span><span class="params">(Integer id)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><ul><li><p>添加OrderCommand.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.service.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:本类用来演示:依赖隔离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/26 0026</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCommand</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;OrderGroup&quot;</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;OrderPool&quot;</span>))</span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)));</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">return</span> threadName + <span class="string">&quot; || &quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加UserCommand.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.service.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:本类用来演示:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/26 0026</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCommand</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;UserGroup&quot;</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;UserPool&quot;</span>))</span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)));</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">return</span> threadName + <span class="string">&quot; || &quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加OrderService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeignService feignService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试依赖隔离</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserCommand userCommand = <span class="keyword">new</span> UserCommand(<span class="string">&quot;库里&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OrderCommand orderCommand1 = <span class="keyword">new</span> OrderCommand(<span class="string">&quot;篮球&quot;</span>);</span><br><span class="line">        OrderCommand orderCommand2 = <span class="keyword">new</span> OrderCommand(<span class="string">&quot;足球&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步调用</span></span><br><span class="line">        String val1 = userCommand.execute();</span><br><span class="line">        String val2 = orderCommand1.execute();</span><br><span class="line">        String val3 = orderCommand2.execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步调用</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f1 = userCommand.queue();</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f2 = userCommand.queue();</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f3 = userCommand.queue();</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;val1=&quot;</span> + val1 + <span class="string">&quot;val2=&quot;</span> + val2 + <span class="string">&quot;val3=&quot;</span> + val3;</span><br><span class="line">      <span class="comment">//  return &quot;f1=&quot; + f1.get() + &quot;f2=&quot; + f2.get() + &quot;f3=&quot; + f3.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>order-demo控制层添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testpool&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderService.testPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试:<a href="http://localhost:8882/testpool">http://localhost:8882/testpool</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val1=hystrix-UserPool-<span class="number">1</span> || 库里val2=hystrix-OrderPool-<span class="number">1</span> || 篮球val3=hystrix-OrderPool-<span class="number">2</span> || 足球</span><br></pre></td></tr></table></figure></li></ul><h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\merge01.png"> </p><p>如图，多个客户端发送请求调用(消费者)项目中的findOne方法，这时候在这个项目中的线程池中会发申请与请求数量相同的线程数，对EurekaServiceProvider(服务提供者)的getUserById方法发起调用，每个线程都要调用一次，在高并发的场景下，这样势必会对服务提供者项目产生巨大的压力。</p><p>请求合并就是将单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法</p><h3 id="请求合并的原理"><a href="#请求合并的原理" class="headerlink" title="请求合并的原理"></a>请求合并的原理</h3><p>NetFlix在Hystrix为我们提供了应对高并发的解决方案—-请求合并，如下图</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\merge02.png"> </p><p>通过请求合并器设置延迟时间，将时间内的，多个请求单个的对象的方法中的参数（id）取出来，拼成符合服务提供者的多个对象返回接口（getUsersByIds方法）的参数，指定调用这个接口（getUsersByIds方法），返回的对象List再通过一个方法（mapResponseToRequests方法），按照请求的次序将结果对象对应的装到Request对应的Response中返回结果。</p><h3 id="请求合并适用场景"><a href="#请求合并适用场景" class="headerlink" title="请求合并适用场景"></a>请求合并适用场景</h3><p>在服务提供者提供了返回单个对象和多个对象的查询接口，并且单个对象的查询并发数很高，服务提供者负载较高的时候，我们就可以使用请求合并来降低服务提供者的负载</p><h3 id="请求合并带来的问题"><a href="#请求合并带来的问题" class="headerlink" title="请求合并带来的问题"></a>请求合并带来的问题</h3><ol><li>我们为这个请求人为的设置了延迟时间，这样在并发不高的接口上使用请求缓存，会降低响应速度</li><li>实现请求合并比较复杂</li></ol><h3 id="使用注解配置"><a href="#使用注解配置" class="headerlink" title="使用注解配置"></a>使用注解配置</h3><ul><li><p>OrderService.java中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 演示请求合并</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@HystrixCollapser(batchMethod = &quot;findAll&quot;,collapserProperties = &#123;</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;,value = &quot;300&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">findOne</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;被合并的请求!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@HystrixCommand</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAll</span><span class="params">(List&lt;Integer&gt; ids)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;合并的请求&quot;</span>);</span><br><span class="line">       List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(Integer id:ids)&#123;</span><br><span class="line">           results.add(feignService.get(id));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> results;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>OrderController.java中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getMerge&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMerge</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是异步</span></span><br><span class="line">    Future&lt;String&gt; r1 = orderService.findOne(<span class="number">1</span>);</span><br><span class="line">    Future&lt;String&gt; r2 = orderService.findOne(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Thread.sleep(1000);</span></span><br><span class="line">    Future&lt;String&gt; r3 = orderService.findOne(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//context.close();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;u1:&quot;</span>+r1.get()+<span class="string">&quot;,u2:&quot;</span>+r2.get()+<span class="string">&quot;r3:&quot;</span>+r3.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8882/getMerge</span></span><br></pre></td></tr></table></figure><p>观察控制台 - order-demo控制台只会出现一次”合并的请求”</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并的请求</span><br></pre></td></tr></table></figure></li></ul><h2 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h2><ul><li><p>OrderService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求缓存,如果俩次请求的cacheKey是一样的,则此处的代码仅仅会执行一次</span></span><br><span class="line"><span class="comment">    * 此处是采用注解的配置方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> cacheKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CacheResult</span></span><br><span class="line">   <span class="meta">@HystrixCommand(commandKey = &quot;cache-user&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(Integer id,<span class="meta">@CacheKey</span> Long cacheKey)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;请求缓存,如果cacheKey是一样的,则不会再执行!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> feignService.get(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求缓存</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getCache&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">       HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">  </span><br><span class="line">       Long key = <span class="number">9999L</span>;</span><br><span class="line">       String u1 = orderService.getUser(<span class="number">1</span>,key);</span><br><span class="line">       String u2 = orderService.getUser(<span class="number">2</span>,<span class="number">9998L</span>);</span><br><span class="line">  </span><br><span class="line">       context.close();</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;u1:&quot;</span>+u1+<span class="string">&quot;,u2:&quot;</span>+u2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="路由网关zuul"><a href="#路由网关zuul" class="headerlink" title="路由网关zuul"></a>路由网关zuul</h1><h2 id="为什么需要服务网关"><a href="#为什么需要服务网关" class="headerlink" title="为什么需要服务网关"></a>为什么需要服务网关</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\zuul01.webp"> </p><p>在分布式系统系统中，有商品、订单、用户、广告、支付等等一大批的服务，前端怎么调用呢？和每个服务一个个打交道？这显然是不可能的，这就需要有一个角色充当所有请求的入口，这个角色就是服务网关（API gateway）</p><h2 id="客户端直接与微服务通讯的问题"><a href="#客户端直接与微服务通讯的问题" class="headerlink" title="客户端直接与微服务通讯的问题"></a>客户端直接与微服务通讯的问题</h2><ol><li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li><li>存在跨域请求，在一定场景下处理相对复杂。</li><li>认证复杂，每个服务都需要独立认证。</li><li>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通讯，那么重构将会很难实施。</li></ol><h2 id="网关的优点"><a href="#网关的优点" class="headerlink" title="网关的优点"></a>网关的优点</h2><ol><li>易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。</li><li>易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li><li>减少了客户端与各个微服务之间的交互次数。</li></ol><h2 id="什么是网关？"><a href="#什么是网关？" class="headerlink" title="什么是网关？"></a>什么是网关？</h2><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><h2 id="使用zuul"><a href="#使用zuul" class="headerlink" title="使用zuul"></a>使用zuul</h2><ul><li><p>新建zuul-demo模块</p></li><li><p>pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring:  application:    name: zuul-demoserver:  port: 9000eureka:  instance:    hostname: localhost  client:    register-with-eureka: true    fetch-registry: true    service-url:        defaultZone: http://localhost:8888/eureka/        preferIpAddress: truezuul:  routes:# 配置统一前缀访问    api-order:      path: /api-order/**      serviceId: order-demo    api-user:      path: /api-user/**      serviceId: user-demo</span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="meta">@EnableDiscoveryClient</span><span class="comment">// 开启zuul功能@EnableZuulProxypublic class ZuulDemoApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(ZuulDemoApplication.class, args);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试路由访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 测试<span class="number">1</span>:http:<span class="comment">//localhost:9000/api-order/testpool# 测试2:http://localhost:9000/api-user/user/1# 测试3:http://localhost:9000/user-demo/user/1# 测试4:http://localhost:9000/order-demo/testpool</span></span><br></pre></td></tr></table></figure><p>都是允许访问的</p></li><li><p>配置统一前缀访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:# 配置统一前缀访问    api-order:      path: /api-order/**      serviceId: order-demo    api-user:      path: /api-user/**      serviceId: user-demo#前缀访问  prefix: /parent</span><br></pre></td></tr></table></figure><p>测试路由访问:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># http:<span class="comment">//localhost:9000/parent/api-order/testpool# http://localhost:9000/parent/order-demo/testpool</span></span><br></pre></td></tr></table></figure></li><li><p>忽略服务名serviceId访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:# 配置统一前缀访问    api-order:      path: /api-order/**      serviceId: order-demo    api-user:      path: /api-user/**      serviceId: user-demo# 前缀访问  prefix: /parent# 忽略服务名serviceId访问ignored-services: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>测试路由访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#测试 http://localhost:9000/parent/api-order/testpool -&gt;ok#测试http//localhost:9000/parent/order-demo/testpool -&gt;error</span><br></pre></td></tr></table></figure></li><li><p>配url绑定映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:    testurl:      # url: http://www.iduoan.com  url: http://localhost:8885/      path: /testurl/**</span><br></pre></td></tr></table></figure><p>测试路由访问:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 测试 http://localhost:9000/testurl/user/1</span><br></pre></td></tr></table></figure></li><li><p>配置URL映射负载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ribbon:  eureka:    enabled: false#Ribbon请求的微服务serviceIdsuccess-user:  ribbon:    listOfServers: http://www.huya.com,http://www.douyu.comzuul:  routes:    testurl:      serviceId: success-user      path: /testurl/**</span><br></pre></td></tr></table></figure></li></ul><h2 id="zuul过滤器"><a href="#zuul过滤器" class="headerlink" title="zuul过滤器"></a>zuul过滤器</h2><p>Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能，zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器，简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。</p><h3 id="添加过滤器类"><a href="#添加过滤器类" class="headerlink" title="添加过滤器类"></a>添加过滤器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.filter;<span class="keyword">import</span> com.netflix.zuul.ZuulFilter;<span class="keyword">import</span> com.netflix.zuul.exception.ZuulException;<span class="keyword">import</span> com.sun.scenario.effect.FilterContext;<span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="comment">/** * <span class="doctag">@author</span> success * <span class="doctag">@version</span> 1.0 * <span class="doctag">@description</span>:本类用来演示: * Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能， * zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器， * 简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。 */</span><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter01</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span></span>&#123;    <span class="comment">/**     * 类型包含 pre post route error     * pre 代表在路由代理之前执行     * route 代表代理的时候执行     * error 代表出现错的时候执行     * post 代表在route 或者是 error 执行完成后执行     */</span>    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> FilterConstants.PRE_TYPE;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;        <span class="comment">// 优先级，数字越大，优先级越低        return 1;    &#125;    @Override    public boolean shouldFilter() &#123;        // 是否执行该过滤器，true代表需要过滤        return true;    &#125;    @Override    public Object run() throws ZuulException &#123;        System.out.println(&quot;1111111111111111111&quot;);        return null;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="高可用分布式配置中心"><a href="#高可用分布式配置中心" class="headerlink" title="高可用分布式配置中心"></a>高可用分布式配置中心</h1><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\config01.png"> </p><h2 id="没有使用统一配置中心时，所存在的问题"><a href="#没有使用统一配置中心时，所存在的问题" class="headerlink" title="没有使用统一配置中心时，所存在的问题"></a>没有使用统一配置中心时，所存在的问题</h2><ul><li>配置文件分散在各个项目里，不方便维护</li><li>配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的</li><li>更新配置后，项目需要重启</li></ul><h2 id="有哪些开源配置中心"><a href="#有哪些开源配置中心" class="headerlink" title="有哪些开源配置中心"></a>有哪些开源配置中心</h2><p>spring-cloud/spring-cloud-config<br><a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a><br>spring出品，可以和spring cloud无缝配合<br>diamond<br><a href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a><br>disconf<br><a href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a><br>ctrip apollo<br><a href="https://github.com/ctripcorp/apollo/">https://github.com/ctripcorp/apollo/</a><br>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。</p><h2 id="快速入门config-server"><a href="#快速入门config-server" class="headerlink" title="快速入门config-server"></a>快速入门config-server</h2><ul><li><p>创建config-server-demo工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableConfigServerpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerDemoApplication</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;SpringApplication.run(ConfigServerDemoApplication.class, args);&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 9100spring:  application:    name: config-server-demo  cloud:    config:      server:        git:          uri:</span> <span class="string">https://gitee.com/guancg/config-server-demo.git</span></span><br></pre></td></tr></table></figure></li><li><p>创建码云仓库 </p><p><a href="https://gitee.com/guancg/config-server-demo.git">https://gitee.com/guancg/config-server-demo.git</a></p></li><li><p>创建测试的配置文件</p><ul><li><p>文件名-环境名.后缀</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\dev.png"></p></li></ul></li><li><p>config支持我们使用的请求的参数规则为：</p><ul><li>/ { 应用名 } / { 环境名 } [ / { 分支名 } ]<br><a href="http://localhost:9100/config-server-demo/dev">http://localhost:9100/config-server-demo/dev</a></li><li>/ { 应用名 } - { 环境名 }.yml<br>/ { 应用名 } - { 环境名 }.properties<br><a href="http://localhost:9100/config-server-demo-dev.properties">http://localhost:9100/config-server-demo-dev.properties</a></li><li>/ { 分支名 } / { 应用名 } - { 环境名 }.yml<br>/ { 分支名 } / { 应用名 } - { 环境名 }.properties<br><a href="http://localhost:9100/master/config-server-demo-dev.properties">http://localhost:9100/master/config-server-demo-dev.properties</a></li></ul></li></ul><h2 id="快速入门config-client"><a href="#快速入门config-client" class="headerlink" title="快速入门config-client"></a>快速入门config-client</h2><ul><li><p>创建config-client-demo模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplicationpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientDemoApplication</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;SpringApplication.run(ConfigClientDemoApplication.class, args);&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">//刷新消息组件@RefreshScopepublic class ConfigClientController &#123;    @Value(&quot;$&#123;name&#125;&quot;)    private String name;    @GetMapping(&quot;/value&quot;)    public String getName()&#123;        return name;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>bootstrap.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 9201spring:  application:    name:</span> <span class="string">config-client-demo</span>           <span class="comment"># 指定了配置文件的应用名  cloud:    config:      uri: http://localhost:9100/      #Config server\的uri      profile: dev                       #指定的环境      label: master                      #指定的分支    </span></span><br></pre></td></tr></table></figure><p><a href="http://localhost:9201/value">http://localhost:9201/value</a></p></li></ul><h1 id="Config-Bus-实现动态刷新"><a href="#Config-Bus-实现动态刷新" class="headerlink" title="Config+Bus : 实现动态刷新"></a>Config+Bus : 实现动态刷新</h1><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\bus.png"> </p><ul><li><p>config-client-demo模块添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息总件组件--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新消息组件@RefreshScopepublic class ConfigClientController &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>启动rabbitmq消息队列</p></li><li><p>修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 9201spring:  application:    name:</span> <span class="string">config-client-demo</span>           <span class="comment"># 指定了配置文件的应用名  cloud:    config:      uri: http://localhost:9100/      #Config server\的uri      profile: dev                       #指定的环境      label: master                      #指定的分支  rabbitmq:      host: 192.168.2.49      port: 5672      username: guest      password: guestmanagement: # 暴露总线消息地址`  endpoints:    web:      exposure:        include: &quot;bus-refresh&quot;      cors:        allowed-origins: &quot;*&quot;        allowed-methods: &quot;*&quot;  #测试 - http://localhost:9201/actuator/bus-refresh</span></span><br></pre></td></tr></table></figure></li><li><p>本次测试地址：POST请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:9201/actuator/bus-refresh</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h1><h2 id="消息队列中间件"><a href="#消息队列中间件" class="headerlink" title="消息队列中间件"></a>消息队列中间件</h2><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构]</p><p>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。其使用场景为：异步处理，应用解耦，流量削锋和消息通讯四个场景。</p><h2 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ul><li>可靠性(Reliability)：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由(Flexible Routing)：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群(Clustering)：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用(Highly Available Queues)：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li>多种协议(Multi-protocol)：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>多语言客户端(Many Clients)：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li><li>管理界面(Management UI)：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方<br>面。</li><li>跟踪机制(Tracing)：如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li><li>插件机制(Plugin System)：RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件</li></ul><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\rbm.png"> </p><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><p><strong>RabbitMQ Server</strong>： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</p><p>Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接<strong>RabbitMQ</strong>服务器然后将消息投递到Exchange。</p><p><strong>Consumer</strong>：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。</p><p><strong>Exchange</strong>：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</p><p><strong>Queue</strong>：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><strong>RoutingKey</strong>：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytes，</p><p><strong>Connection</strong>： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</p><p><strong>Channels</strong>： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p><p><strong>VirtualHost</strong>：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>自己搞定</p><h2 id="RabbitMQ三种模式"><a href="#RabbitMQ三种模式" class="headerlink" title="RabbitMQ三种模式"></a>RabbitMQ三种模式</h2><h3 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h3><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\direct.png"> </p><p>我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。</p><p>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</p><p>一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p><p>这种模式下不需要将Exchange进行任何绑定(binding)操作<br>消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。<br>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p><ul><li><p>创建队列</p><p>首先在浏览器登录RabbitMQ：<a href="http://192.168.228.129:15672/">http://192.168.2XX.129:15672</a> ，按照下图创建一个队列就可以了:</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\d00.png"></p></li><li><p>代码</p><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 8010spring:  application:    name: rabbitmq-demo  rabbitmq:    host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.49</span></span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplicationpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqDemoApplication</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;SpringApplication.run(RabbitmqDemoApplication.class, args);&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们写生产者代码（生产者采用Junit和SpringBoot整合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTestpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqDemoApplicationTests</span> </span>&#123;<span class="meta">@Autowired</span><span class="keyword">private</span> RabbitTemplate rabbitTemplate;<span class="comment">/** * 直接模式 */</span><span class="meta">@Test</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;<span class="comment">//在直接模式的队列中放入数据rabbitTemplate.convertAndSend(&quot;j05_direc&quot;,&quot;我是直接模式!&quot;);&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>此时你运行生产者函数时，在消息队列的界面会显示一条消息（Ready）</p></li><li><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 运行方式:直接启动springboot的启动类,在控制台观察msg * <span class="doctag">@author</span> success * <span class="doctag">@version</span> 1.0 * <span class="doctag">@description</span>:本类用来演示:消费直接模式消息队列中的数据 * <span class="doctag">@date</span> 2019/9/2 0002 */</span><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;j05_direc&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectionController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;直接模式j05_direc-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>当你运行消费者代码时，在run栏会打印出：</p><p><img src></p></li><li><p>当然，你想设置多个消费者时，我们可以将springboot单例运行选项去掉</p><p>然后改掉配置文件的端口号，重新把程序跑一次，这样，就有两个消费者了，再改端口号，再运行就是三个消费者了。多运行几次生产者的测试函数，三个消费者会轮流输出（因为这里是默认负载均衡的，所有会轮流输出）。</p></li></ul><h2 id="分裂模式"><a href="#分裂模式" class="headerlink" title="分裂模式"></a>分裂模式</h2><p>当我们需要将消息一次发给多个队列时，需要使用这种模式。如下图：</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\exchange.png"> </p><p>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</p><ol><li>可以理解为路由表的模式</li><li>这种模式不需要RouteKey</li><li>这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。</li><li>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃.</li></ol></li></ul><h3 id="交换器绑定队列"><a href="#交换器绑定队列" class="headerlink" title="交换器绑定队列"></a>交换器绑定队列</h3><ul><li><p>创建三个队列</p><p>j05_direc和cctv1和cctv2</p><p><img src></p></li><li><p>创建j05_alls交换器</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\fadeout.png"> </p></li><li><p>将j05_alls交换器和三个队列进行绑定</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\binding.png"> </p><p>这样向j05_alls交换器里发消息，交换器就会向绑定的三个消息队列里面发消息（）。</p></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  * 分裂模式  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testFadeIn</span><span class="params">()</span></span>&#123;    <span class="comment">//在分裂模式中的exchanges中放入数据    rabbitTemplate.convertAndSend(&quot;j05_alls&quot;,&quot;&quot;,&quot;我是分裂模式!&quot;);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>三个消费者</p><ul><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;j05_direc&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectionController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;直接模式j05_direc-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;cctv1&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FadeOutController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;分裂模式-cctv1-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;cctv2&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;主题模式模式cctv2-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>运行后可得下面结果</p><p><img src></p></li></ul><h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\topic_exchange.png"> </p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\topic.png"> </p><p>如上图所示此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.newsusa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。</p><p>注：<br>交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p><p>这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。<br>这种模式需要RouteKey，也许要提前绑定Exchange与Queue。<br>在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。<br>“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。<br>同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息</p><h4 id="创建队列与绑定"><a href="#创建队列与绑定" class="headerlink" title="创建队列与绑定"></a>创建队列与绑定</h4><p>和分裂模式一样，只是在Exchanges设置里面添加Routing  Key</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\topic_binding.png"> </p><p>代码编写</p><p>分裂模式一样，只需要在3个Customer类里面修改下convertAndSend的参数就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 主题模式 */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span></span>&#123;    <span class="comment">//分别测试    rabbitTemplate.convertAndSend(&quot;j05_topic&quot;,&quot;good.log&quot;,&quot;我是主题模式!&quot;);&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>视图和limt语句</title>
    <link href="http://example.com/2021/08/18/mysql-%E8%A7%86%E5%9B%BE%E5%92%8Climit/"/>
    <id>http://example.com/2021/08/18/mysql-%E8%A7%86%E5%9B%BE%E5%92%8Climit/</id>
    <published>2021-08-18T11:02:10.000Z</published>
    <updated>2022-01-11T06:21:21.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="limit语句"><a href="#limit语句" class="headerlink" title="limit语句"></a>limit语句</h1><blockquote><p>应用场景就是 - 网页中的数据[肯定是mysql中的]肯定是要进行分页的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 获取表中前m行的数据.</span><br><span class="line">-- limit m</span><br><span class="line">mysql&gt; select * from s_emp limit 3;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- limit m,n</span><br><span class="line">-- m代表的是行下标,从0开始</span><br><span class="line">-- n代表的是显示的条数</span><br><span class="line"></span><br><span class="line">-- 从第3行开始,显示5条</span><br><span class="line">mysql&gt; select * from s_emp limit 2,5;</span><br><span class="line"></span><br><span class="line">## 分页的公式</span><br><span class="line"></span><br><span class="line">场景:</span><br><span class="line"></span><br><span class="line">1. 对于用户而言,点击多少页,比如选择1页,认为是第一页.</span><br><span class="line"></span><br><span class="line">   pageNow - 当前页.   pageSize - 每页显示条数</span><br><span class="line"></span><br><span class="line">   ~~~mysql</span><br><span class="line">   limit (pageNow-1)*pageSize,pageSize</span><br></pre></td></tr></table></figure></blockquote><h2 id="sql优化的部分"><a href="#sql优化的部分" class="headerlink" title="sql优化的部分"></a>sql优化的部分</h2><blockquote><p>limit m,n </p><p>m - 偏移量  n-显示的条数</p><p>如果偏移量比较大,limit语句的查询性能就会低下.</p><p>limit优化常见的两种场景</p><ol><li><p>假设stu表中name列没有添加索引.但是name是从业角度考虑它应该是唯一的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where name=&#x27;tom&#x27;;</span><br><span class="line"></span><br><span class="line">-- 肯定会进行全表扫描的. - 数据量 - 导致查询效率低下</span><br><span class="line">explain select * from stu where name=&#x27;tom&#x27;;</span><br><span class="line"></span><br><span class="line">-- 已经确认name列值肯定是唯一的 - 避免全表扫描</span><br><span class="line">select * from stu where name=&#x27;tom&#x27; limit 1;</span><br></pre></td></tr></table></figure></li><li><p><strong>前提条件是id主键列是自增且连续</strong>,由于limit m,n随着m[偏移量]增加,导致查询效率低下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from s_emp limit 10000,2;</span><br><span class="line">   </span><br><span class="line">优化</span><br><span class="line">select * from s_emp where id&gt;10000 limit 2;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><blockquote><p>视图 - “虚拟表”,类似于原表的”镜像”,之前是怎么操作table的,怎么操作视图view</p><p>优势:</p><ol><li><p><strong>保证数据的安全性.</strong></p><p>比如某张表中的隐秘数据比较多,不希望程序员看到你这个原表.比如emp(id,name,salary,birthday).</p><p>隐秘数据比如有salary,birthday.为了保障数据的安全性.db[数据库管理员]可以为emp创建视图出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create view emp_view as select id,name from emp;</span><br><span class="line">   </span><br><span class="line">接下来程序员的操作,直接对视图进行操作了[select,insert,update,delete] - &gt; 对原表也会产生影响.</span><br><span class="line">但是删除视图,是不会删除原表的.但是删除原表,视图肯定是不存在的.</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>封装一些比较繁琐的关联查询,在以后再次用到的时候.可以直接查询视图.</li><li>简化我们查询数据</li></ol></blockquote><h2 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h2><blockquote><ol><li>简单视图 - 视图来自于单张表的查询</li><li>复杂视图 - 视图来自于关联查询[多张表]</li></ol></blockquote><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名 as select语句;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为student表创建一个简单视图</span><br><span class="line">create view stu_view as select * from student;</span><br></pre></td></tr></table></figure><h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><h2 id="操作视图"><a href="#操作视图" class="headerlink" title="操作视图"></a>操作视图</h2><blockquote><ol><li><p>视图的查询 - DQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu_view;</span><br></pre></td></tr></table></figure></li><li><p>修改原表,看是否对视图造成影响 - 会</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update student set sname=&#x27;admin&#x27; where id=1;</span><br><span class="line">   </span><br><span class="line">select * from stu_view;</span><br><span class="line">|    1 | admin  | 1990-01-01 00:00:00 | 男   |</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>能不能对简单视图进行dml操作 - 可以</p><p><code>对视图的dml操作同样也会对原表产生影响</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update stu_view set sname=&#x27;success&#x27; where id=1;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="复杂视图"><a href="#复杂视图" class="headerlink" title="复杂视图"></a>复杂视图</h2><blockquote><p>复杂视图代表整个视图的来源是关联表的查询  - 就是用来被查询的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询区域名以及这个区域上的员工的first_name</span><br><span class="line">drop view region_view;</span><br><span class="line">create view region_view</span><br><span class="line">as </span><br><span class="line">select r.name,e.first_name from s_region r </span><br><span class="line">join s_dept d on d.region_id = r.id</span><br><span class="line">join s_emp e on e.dept_id = d.id;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from region_view;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>它和简单视图的一个区别在于,复杂视图是不能够执行DML操作的</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from region_view where name = &#x27;North America&#x27;;</span><br><span class="line">ERROR 1395 (HY000): Can not delete from join view &#x27;j03s.region_view&#x27;</span><br></pre></td></tr></table></figure></blockquote><h1 id="with-check-option"><a href="#with-check-option" class="headerlink" title="with check option"></a>with check option</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">drop view stu_view;</span><br><span class="line">create view stu_view</span><br><span class="line">as </span><br><span class="line">select id,sname from student where id=13;</span><br><span class="line"></span><br><span class="line">select * from stu_view;</span><br><span class="line"></span><br><span class="line">-- 更新视图 - 更新的是视图来源的那条sql的where中的条件列</span><br><span class="line">update stu_view set id=100 where id=13;</span><br><span class="line"></span><br><span class="line">-- 视图没有了 - 原表中已经没有了 - 视图的更新会同步给原表[对原表产生了影响了]</span><br><span class="line">mysql&gt; select * from stu_view;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 不允许视图去更新自己来源的那条sql中的where条件列.</span><br><span class="line">drop view stu_view;</span><br><span class="line">create view stu_view</span><br><span class="line">as </span><br><span class="line">select id,sname from student where id=11 with check option;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from stu_view;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | sname  |</span><br><span class="line">+------+--------+</span><br><span class="line">|   11 | 李四   |</span><br><span class="line">+------+--------+</span><br><span class="line"></span><br><span class="line">-- 检测with check option的效果 - 更新视图的时候,是不允许更新id列</span><br><span class="line">update stu_view set id=900 where id=11;</span><br><span class="line">ERROR 1369 (HY000): CHECK OPTION failed &#x27;j03s.stu_view&#x27;</span><br></pre></td></tr></table></figure></blockquote><h1 id="总结面试题"><a href="#总结面试题" class="headerlink" title="总结面试题"></a>总结面试题</h1><blockquote><ol><li><p><strong>DB,DBA,DBS,DBMS,RDBMS</strong> </p></li><li><p><strong>delete和truncate和drop区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delete - DML</span><br><span class="line">truncate - DDL</span><br><span class="line">-- 清空表</span><br><span class="line">truncate 表名;</span><br><span class="line"></span><br><span class="line">drop  - ddl - 删除表</span><br></pre></td></tr></table></figure></li><li><p>数据库优化 - sql优化</p></li><li><p><strong>悲观锁和乐观锁</strong></p></li><li><p>innodb和myisam区别</p></li><li><p>索引底层原理[innodb和myisam] - b+树</p></li><li><p>聚簇索引和非聚簇索引[辅助索引]</p></li><li><p>事务的隔离级别</p></li><li><p>脏读,<strong>不可重复读</strong>,可重复读**,幻读**</p></li><li><p><strong>DQL查询语句</strong> - 项目</p></li><li><p>存储过程和函数的区别</p></li><li><p>视图的优势</p></li><li><p>三大范式概念</p></li><li><p><strong>SQL按照功能分类[DCL,DTL,DML,DQL,DDL]</strong></p></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="http://example.com/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/"/>
    <id>http://example.com/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/</id>
    <published>2021-08-17T11:02:10.000Z</published>
    <updated>2022-01-11T06:20:16.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h1><blockquote><p>解释底层的索引的数据结构 - b+树</p></blockquote><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p> InnoDB 存储引擎中的 <em><strong>B+ 树索引</strong></em>。要介绍 B+ 树索引，就不得不提二叉查找树，</p><p>平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。</p><p><strong>索引文件和数据文件 - innodb中 - 合二为一的 - 只有1个文件</strong></p><p><strong>索引文件和数据文件 - myisam中 - 分开独立的 - 俩个文件</strong></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg">  </p><p><em><strong>节点(每个圆圈圈)中存储了键（key - 主键索引列）和数据（data - 每一个行记录）</strong></em>。<strong>键对应 user 表中的 id</strong>，<strong>数据对应 user 表中的行数据。</strong></p><p>二叉查找树的特点就是任何节点的<strong>左子节点的键值都小于当前节点的键值</strong>，<strong>右子节点的键值都大于当前节点的键值</strong>。顶端的节点我们称为<strong>根节点</strong>，<strong>没有子节点的节点我们称之为<em>叶节点</em>。</strong></p><blockquote><p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p><ol><li><p>id=12先和根节点[只有一个]key=10,发现id=12&gt;id=10 - 顺利向着根节点的右边去匹配</p></li><li><p>id=12和非叶节点id=13的进行匹配,顺利执行id=13的左边</p></li><li><p>id=12和id=12比较 - 两者是相同的.由于每个节点除了保存key还保存了value[行记录 - 行真实的行数据]</p><p>直接将这个节点的value直接取出来了.</p></li></ol><p>总结 - <strong>总共匹配了3次就可以顺利找到我们的数据.</strong></p><p><strong>如果没有创建二叉树索引.查找id=12,必然会进行全表扫描.从表的第一行向下找.最好的状态也得找6次</strong></p></blockquote><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="二叉树带来的弊端"><a href="#二叉树带来的弊端" class="headerlink" title="二叉树带来的弊端"></a>二叉树带来的弊端</h2><blockquote><p>二叉查找树的特点就是任何节点的<strong>左子节点的键值都小于当前节点的键值</strong>，<strong>右子节点的键值都大于当前节点的键值</strong></p><p>二叉树在极端的场景下有可能成为一个链表的结构[链表的查询效率很低很低的.]</p><p>查找id=12,”链表结构”,只能从链表的头节点开始查找,最佳状态也得寻找找了5次.</p></blockquote><blockquote><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/link.jpg"> </p></blockquote><h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2><p>为了解决这个问题[<strong>防止二叉树变成了链表结构导致查询效率依然低下</strong>]，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树.</p><p><strong>平衡二叉树又称 AVL 树</strong>，在满足二叉查找树特性的基础上，要求<strong>每个节点的左右子树的高度差不能超过 1。</strong> </p><p>下面是平衡二叉树和非平衡二叉树的对比：</p><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/diff.png"> </p><p><code>只要找到任何一个节点的左右子树高度差的绝对值大于1 - 非平衡二叉树</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点45 - 左子树高度 = 左边的子节点的个数 = 2</span><br><span class="line">- 右子树高度 = 右边没有节点 = 0</span><br><span class="line">- |高度差|=2&gt;1</span><br></pre></td></tr></table></figure><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><blockquote><p><strong>平衡二叉树暴露出来了一些缺点:</strong></p><p>每个<strong>节点仅仅保存一个key-value键值对[每个节点可保存的键值对数据太少了]</strong>.每次进行查询的时候,实际上都是需要从磁盘中读取数据的.</p><p><strong>那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块</strong></p><p>由于每个节点可保存的数据不多,仅仅保存了一个key-value.在查找数据的过程中,它就不断去和磁盘进行IO交互.</p><p>导致平衡二叉树的节点比较多.也就导致了平衡二叉树的高度比较高 - 导致比较的次数比较多 - 频繁和IO进行交互 - 查询效率低下.</p></blockquote><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/n.jpg"> </p><blockquote><p>为了解决平衡二叉树的高度太高问题.B树登场了.</p><p>B树特点</p><ol><li><p>根节点[第一页] - 永驻内存.</p></li><li><p>每个节点可以保存多个key-value - 导致子节点也会增多.B树又矮又胖.</p></li><li><p>没有子节点的节点 - 叶节点,有子节点的节点 - 非叶节点</p></li><li><p>B树的m阶 - m值就是看它最大的子节点的个数 - 3 , 下面的图代表的就是3阶b树.</p><p>如果有10亿条数据,<strong>只需要和磁盘进行交互2次.把磁盘块中的一页数据[16kb]全部加载到内存中.</strong></p></li><li><p>页page的概念 - 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块</p><p>读取的单位是 - 页 - 1页的磁盘块的数据大小是<strong>16kb</strong>,每个节点可以更多的key-value</p></li><li><p><strong>页与也之间是一个链表的结构</strong></p></li><li><p>查找id=28的数据 - 磁盘交互了3次</p><p>①id=28到第一页中进行匹配,发现id=28在17和35之间,获取p2指针.p2指向到页3</p><p>②定位到页3,发现id=28在26~30之间,继续拿到p2指针,p2指向的是页8</p><p>③定位到页8,顺利匹配查找到id=28这条数据</p></li></ol></blockquote><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/b.jpg"> </p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><blockquote><p>是Innodb和myisam存储引擎中索引底层的数据结构 - B+树</p><p>B树中每个节点中不仅仅存储key[索引列值,主键列值],还存储了数据.因为数据库中的页的大小是固定的[Innodb默认是16kb],</p><p>导致每个节点的存储资源有点浪费了.</p></blockquote><blockquote><p>B+树和B树的重要区别就是</p><ol><li><p>B+树中非叶节点,仅仅保存了key值[索引列,主键列值],没有保存数据.每个非叶节点可以保存更多的key.</p></li><li><p>B+树中索引的所有的数据都放在了叶子节点中,而且是<strong>按照顺序排列的.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- 演示一下顺序</span><br><span class="line">drop table tb;</span><br><span class="line">create table tb(</span><br><span class="line">  -- 主键索引列</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  name varchar(29)</span><br><span class="line">);</span><br><span class="line">insert into tb values(1,&#x27;admin&#x27;);</span><br><span class="line">insert into tb values(3,&#x27;tom&#x27;);</span><br><span class="line">      </span><br><span class="line">mysql&gt; select * from tb;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | admin |</span><br><span class="line">|  3 | tom   |</span><br><span class="line">+----+-------+</span><br><span class="line">      </span><br><span class="line">-- 再插入一条数据,但是id=2,介于1,3之间</span><br><span class="line">insert into tb values(2,&#x27;jack&#x27;);</span><br><span class="line">-- 出来的效果居然是排好序的.实际上是插入的时候,自动根据主键列索引排序后插入到合适的位置.</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | admin |</span><br><span class="line">|  2 | jack  |</span><br><span class="line">|  3 | tom   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>**页与页之间是双向链表结构,**叶节点中的每个数据节点单向链表</li><li>下面这个图展示的是Innodb中的索引的结构.并不是Myisam中索引的结构</li><li>以下图示本质上就是<strong>聚簇索引的方式 - key - 主键列</strong></li></ol></blockquote><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/B+.jpg"> </p><h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。</p><p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p><p>这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><ul><li><p>聚集索引（聚簇索引）：<em><strong>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</strong></em></p><p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，<strong>在 B+ 树的叶子节点中，存储了表中所有的数据。</strong></p><p><strong>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</strong></p></li><li><p>非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于<em><strong>非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键</strong></em>，想要<strong>查找数据我们还需要根据主键再去聚集索引中进行查找</strong>，这个再根据聚集索引查找数据的过程，我们称为<em><strong>回表</strong></em>。</p></li></ul><h2 id="聚簇索引存储和查找"><a href="#聚簇索引存储和查找" class="headerlink" title="聚簇索引存储和查找"></a>聚簇索引存储和查找</h2><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/jusearch.jpg"> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from xx where id&gt;=18 and id&lt;41;</span><br><span class="line">-- 聚簇索引的查找方式 - 根据主键列id列进行查找的流程</span><br><span class="line">1. 先从页1中看id的区间,定位到p2-&gt;页3</span><br><span class="line">2. 定位到页3,定位到p1-&gt;页8[叶节点-单向链表 - 查找必须从头节点开始找]</span><br><span class="line">3. 依次按照链表的顺序一致找到id开始&lt;41的这个节点.满足条件的叶节点中的数据全部查出来 [叶节点中保存了真实的数据]</span><br></pre></td></tr></table></figure><h2 id="非聚簇索引存储和查找"><a href="#非聚簇索引存储和查找" class="headerlink" title="非聚簇索引存储和查找"></a>非聚簇索引存储和查找</h2><blockquote><p>B+树的结构</p><p>表结构:<strong>id</strong> age <strong>name</strong></p><p>id - 主键列 - 默认是聚簇索引列 - 主键列</p><p>name - <strong>非聚簇索引列 - 索引列 - 辅助索引</strong></p></blockquote><blockquote><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/x.png"> </p></blockquote><blockquote><p>非聚簇索引 - 非主键列索引 - <strong>name列创建了索引</strong> - 辅助索引.</p></blockquote><blockquote><p>结构:</p><ol><li><p>根节点 - 一页数据 - 非聚簇索引列值 - name</p></li><li><p>非叶节点 - 非聚簇索引列值</p></li><li><p>页节点存储的东西 - name索引列以及该列对应的主键列值.</p><p>它和聚簇索引最大的区别是页节点中没有存储最终的数据.而是存储的是键值对x-y</p><p>x就是非聚簇索引列值,y是对应的主键列值.</p></li></ol></blockquote><blockquote><p>非聚簇索引的查找方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx where name=&#x27;Bob&#x27;;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>按照B+树的查找流程 - 确认name=’Bob’的具体位置</p></li><li><p>由于非聚簇索引的结构中叶节点仅仅保存了name-主键列值</p></li><li><p>先根据name=’Bob’这个条件找到对应的主键列值id=15</p></li><li><p><strong>要进行”回表操作”</strong></p><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/y.png"> </p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li><p>继续拿着主键列id=15到索引的结构中继续查找一次 - “一次回表查找”.</p><p>id也是聚簇索引 - B+树的结构 - 叶子节点中存储的就是数据.</p><p>根据聚簇索引列的查找方式 - id=15的叶节点 - 拿到里面的数据</p></li></ol></blockquote></blockquote><h2 id="非聚簇索引列查找一定会回表"><a href="#非聚簇索引列查找一定会回表" class="headerlink" title="非聚簇索引列查找一定会回表?????"></a>非聚簇索引列查找一定会回表?????</h2><blockquote><p><strong>未必</strong> - 因为非叶节点中存储的就是索引列值.</p><p>查询**: select name from xx where name=’Blob’;**</p><p>不需要回表了.这条语句查询的结果name已经在非聚簇索引的非叶节点中保存了.</p></blockquote><blockquote><p>回表 </p><ol><li><p>根据一个非聚簇索引列查找 - 优先先到非聚簇索引的B+树中找到该列对应的主键列值[聚簇索引列值]</p></li><li><p>再拿着这个聚簇索引列的值再去到聚簇索引列的B+树中再查找一次</p></li></ol></blockquote><h1 id="myisam中的索引特点"><a href="#myisam中的索引特点" class="headerlink" title="myisam中的索引特点"></a>myisam中的索引特点</h1><blockquote><ol><li><p>innodb中索引和数据合并到一个文件中</p></li><li><p>myisam中索引和数据是单独的俩个文件,分别是索引文件和数据文件.</p></li><li><p>myisam中采用的是”非聚集的方式”</p></li><li><p>无论是聚簇索引还是非聚簇索引,查找方式是一样.</p></li><li><p>采用的也是B+树的结构**.只是叶节点中存储的是索引的列值以及该对应的行记录的地址.**</p><p>需要再根据行记录地址到表中进行定位[回表] </p></li></ol></blockquote><blockquote><p><img src="/2021/08/17/mysql-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91/z.png"> </p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主键列 - key是不允许重复的</span><br><span class="line">非主键列 - key是允许重复的.</span><br><span class="line">select * from xxx where id=5;</span><br><span class="line"></span><br><span class="line">1. 先到B+树找到找到id=5对应的节点 - 取出里面的行记录的物理地址0x6a</span><br><span class="line">2. 回表 - 直接根据行记录的物理地址直接定位到具体的一行.</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>函数与存储过程</title>
    <link href="http://example.com/2021/08/17/mysql-%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/08/17/mysql-%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-08-17T11:02:10.000Z</published>
    <updated>2022-01-11T06:20:58.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数function"><a href="#函数function" class="headerlink" title="函数function"></a>函数function</h1><blockquote><p>了解即可 - 开发中肯定用不到.</p></blockquote><blockquote><p>单行函数 - 字符串函数,数字函数,日期函数</p><p>多行函数(组函数)</p><p>实际上数据库是可以进行编程的.</p></blockquote><blockquote><p>如果使用的是mysql8.x,需要设置一下才能允许自定义函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 在my.ini文件下添加：log-bin-trust-function-creators=1 </span><br><span class="line">   需要重启db服务器</span><br><span class="line">   </span><br><span class="line">2. 在mysql客户端[终端] - set global log_bin_trust_function_creators=TRUE;</span><br></pre></td></tr></table></figure></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>函数语法 - 创建</code></p><p><code>注意点:</code></p><p><code>1. 函数体中肯定有return语句</code></p><p><code>2. 只要遇到varchar类型,必须要指定参数的长度</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- mysql中默认的结束符号使用的是;</span><br><span class="line">-- 修改了默认的结束符号位$$</span><br><span class="line">-- 函数体中肯定会出现分号</span><br><span class="line">delimiter $$</span><br><span class="line"></span><br><span class="line">-- 创建函数</span><br><span class="line">create function 函数名([变量 数据类型(长度)]) returns 返回数据类型</span><br><span class="line">begin</span><br><span class="line">-- 函数体</span><br><span class="line">return 结果;</span><br><span class="line">end $$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p><code>删除函数</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除函数</span><br><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure><h2 id="练习1-自定义函数"><a href="#练习1-自定义函数" class="headerlink" title="练习1 - 自定义函数"></a>练习1 - 自定义函数</h2><blockquote><p>传入俩个整数,返回俩个整数的相加的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop function adds;</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line">create function adds(a int,b int) returns int</span><br><span class="line">begin</span><br><span class="line">return a + b;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select adds(10,30);</span><br></pre></td></tr></table></figure></blockquote><h2 id="练习2-自定义函数"><a href="#练习2-自定义函数" class="headerlink" title="练习2 - 自定义函数"></a>练习2 - 自定义函数</h2><blockquote><p>日期格式化  xxxx年xx月xx日</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop function my_date;</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line">create function my_date(dt date) returns varchar(20)</span><br><span class="line">begin</span><br><span class="line">return date_format(dt,&#x27;%Y年%m月%d日&#x27;);</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用</span><br><span class="line">select my_date(now());</span><br><span class="line"></span><br><span class="line">select my_date(&#x27;2010-09-09&#x27;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="练习3-while-do…end-while"><a href="#练习3-while-do…end-while" class="headerlink" title="练习3 - while..do…end while"></a>练习3 - while..do…end while</h2><blockquote><p><strong>感受循环语句(while .. do. .. end while)以及局部变量(declare)以及变量如何重新设置(set)</strong></p><p>1~x之间的总和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">drop function x_add;</span><br><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create function x_add(x int) returns int</span><br><span class="line">begin</span><br><span class="line">-- 定义俩个局部变量</span><br><span class="line">declare i int default 1;</span><br><span class="line">declare sums int default 0;</span><br><span class="line">-- 循环</span><br><span class="line">while i&lt;=x do</span><br><span class="line">-- sums加</span><br><span class="line">set sums = sums+i;</span><br><span class="line">-- i自增</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">return sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select x_add(100);</span><br></pre></td></tr></table></figure></blockquote><h2 id="练习4-if…end-if"><a href="#练习4-if…end-if" class="headerlink" title="练习4 - if…end if"></a>练习4 - if…end if</h2><blockquote><p>分支语句</p><p>1~x之间的偶数奇数进行相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drop function ji_add;</span><br><span class="line">delimiter //</span><br><span class="line">create function ji_add(x int) returns int</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">declare sums int default 0;</span><br><span class="line">while i&lt;=x do</span><br><span class="line">if i%2!=0 then</span><br><span class="line">set sums = sums+i;</span><br><span class="line">end if;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">return sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select ji_add(100);</span><br></pre></td></tr></table></figure></blockquote><h2 id="练习4-全局变量"><a href="#练习4-全局变量" class="headerlink" title="练习4 - 全局变量"></a>练习4 - 全局变量</h2><blockquote><p>1~x之间的数字之后,但是不包括5的倍数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">drop function jis_add;</span><br><span class="line">delimiter //</span><br><span class="line">create function jis_add(x int) returns int</span><br><span class="line">begin</span><br><span class="line">-- 定义一个局部变量</span><br><span class="line">declare i int default 1;</span><br><span class="line">-- 定义一个全局变量 - mysql能够识别到的符号@ - @变量名 - 全局变量</span><br><span class="line">set @sums = 0;</span><br><span class="line">-- 类似于java中的continue语句 + 代码块命名</span><br><span class="line">-- success是一个循环语句标签名称 - 随便命名的</span><br><span class="line">success:while i&lt;=x do</span><br><span class="line">if i%5=0 then</span><br><span class="line">set i = i + 1;</span><br><span class="line">-- 下面的代码不执行</span><br><span class="line">-- 继续迭代success的循环 - continue - 继续下一轮循环,忽略本轮的循环</span><br><span class="line">iterate success;</span><br><span class="line">end if;</span><br><span class="line">set @sums = @sums + i;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">return @sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select jis_add(100);</span><br><span class="line">-- 全局变量 - 函数体外部是可以访问得到的</span><br><span class="line">select @sums;</span><br></pre></td></tr></table></figure></blockquote><h1 id="存储过程procedure"><a href="#存储过程procedure" class="headerlink" title="存储过程procedure"></a>存储过程procedure</h1><blockquote><p>安装好mysql环境之后,实际上就是在本地中安装好了mysql-server - mysql的服务器端以及mysql-client - mysql的客户端</p><p>mysql-server - 右击计算机 - 管理 - 服务 - 服务和应用程序 - 右边👉 - Mysql服务</p><p>mysql-client - mysql自带的一个客户端.市面上还有很多第三方的客户端[可视化效果不错] - navicat[收费的],idea</p></blockquote><blockquote><p><em><strong>一条sql语句的执行的流程.</strong></em></p><p><strong>mysql&gt; select * from s_emp;</strong></p><p><em><strong>①当输入sql完毕之后,敲下enter键之后,客户端检测一下sql的语法是否规范.如果不规范,直接报错.</strong></em></p><p><em><strong>②如果sql语法是规范的,客户端会负责将这条合法的sql语法发送到mysql-server  - mysql服务器端</strong></em></p><p><em><strong>③mysql-server接受到来自于客户端的sql之后.mysql-server会对这条sql进行编译和解析</strong></em></p><p><em><strong>④mysql-server会将解析的结果返回给mysql-client端[sql语句的执行结果]</strong></em></p><p><em><strong>总结: sql语句 - 语法检测 - 发送到mysql-server - 编译,解析,返回给mysql-client</strong></em>,将这次sql执行的结果保存</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>为了完成一些特定的功能,提前讲sql预编译好,存储在mysql-server端系统的执行计划表中.第一次去调用存储过程的时候</p><p>会对sql进行预编译并且进行保存.第二次再调用的时候,省去了sql语句的编译的过程.</p><p><strong>存储过程可以做到标准的组件编程[封装sql语句]</strong></p></blockquote><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 删除存储过程</span><br><span class="line">drop procedure 存储过程名;</span><br><span class="line"></span><br><span class="line">-- 创建存储过程</span><br><span class="line">delimiter //</span><br><span class="line">create procedure 存储过程名([in|out] [参数列表])</span><br><span class="line">begin</span><br><span class="line">-- 过程体</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 把s_emp表中的员工的平均薪资的sql预编译好放在mysql-server端</span><br><span class="line">-- select avg(salary) from s_emp;</span><br><span class="line">-- 该条sql经常会被频繁调用/或者该条sql写法比较复杂.</span><br><span class="line">-- 考虑把这条sql封装到 - 存储过程</span><br><span class="line"></span><br><span class="line">drop procedure sal_pro;</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line">create procedure sal_pro()</span><br><span class="line">begin</span><br><span class="line">-- 封装sql语句</span><br><span class="line">select avg(salary) from s_emp;</span><br><span class="line">end //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 预编译sql语句 - 创建存储过程的时候</span><br><span class="line">-- mysql-server会对这个存储过程中的sql语句进行编译,解析,将sql语句的编译的结果进行保存.</span><br><span class="line">-- 后续的每次调用的过程中.应该不会再对这条sql语句进行编译了.</span><br><span class="line"></span><br><span class="line">-- 使用call关键字来调用,不需要编译</span><br><span class="line">-- 第一次调用,</span><br><span class="line">call sal_pro();</span><br><span class="line"></span><br><span class="line">-- 第二次调用</span><br><span class="line">-- mysql-server不需要对这个存储过程中的sql语句再去进行编译了[省略了],直接返回之前保存的结果.</span><br><span class="line">call sal_pro();</span><br></pre></td></tr></table></figure><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><blockquote><ol><li>in</li><li>out</li><li>inout</li></ol></blockquote><h3 id="in输入"><a href="#in输入" class="headerlink" title="in输入"></a>in输入</h3><blockquote><p>创建存储过程的时候,参数列表.确认这个参数到底是用来接受参数的,还是用来返回存储过程的结果的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">drop procedure in_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure in_pro(in a int)</span><br><span class="line">begin</span><br><span class="line">-- System.out.println(a);</span><br><span class="line">select a;</span><br><span class="line">-- 对a重新赋值</span><br><span class="line">set a = 10;</span><br><span class="line">select a;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用</span><br><span class="line">-- 直接传入一个字面量</span><br><span class="line">call in_pro(20);</span><br><span class="line"></span><br><span class="line">-- 测试一下使用全局变量进行传参</span><br><span class="line">set @i = 20;</span><br><span class="line">call in_pro(@i);</span><br></pre></td></tr></table></figure></blockquote><h3 id="out输出"><a href="#out输出" class="headerlink" title="out输出"></a>out输出</h3><blockquote><p>如果参数是使用out来修饰的,它是不能够用来保存接受到的数据的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">drop procedure out_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure out_pro(out a int)</span><br><span class="line">begin</span><br><span class="line">-- a是用out修饰的,所以为null</span><br><span class="line">select a;</span><br><span class="line">-- a是out - 存储过程返回出去的数据</span><br><span class="line">set a = 10;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 报错,如果参数是out修饰的,那么是不能够直接传入一个字面量的</span><br><span class="line">-- call out_pro(100);</span><br><span class="line"></span><br><span class="line">-- 如果是out修饰的,调用存储过程,只能传入一个全局变量</span><br><span class="line">set @i=100;</span><br><span class="line">call out_pro(@i);</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| NULL |</span><br><span class="line">+------+</span><br><span class="line">里面的a是没有绑定到你的100 - 原因就是因为a是使用out修饰的.不能接受参数</span><br><span class="line"></span><br><span class="line">select @i;</span><br><span class="line">+------+</span><br><span class="line">| @i   |</span><br><span class="line">+------+</span><br><span class="line">|   10 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure></blockquote><h2 id="练习-封装单个结果集"><a href="#练习-封装单个结果集" class="headerlink" title="练习 - 封装单个结果集"></a>练习 - 封装单个结果集</h2><blockquote><ol><li><p>根据员工的id来返回员工的名称,薪资 - sql语句 - 封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">drop procedure emp_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure emp_pro(in eid int(7),out fname varchar(25),out sal float(11,2))</span><br><span class="line">begin</span><br><span class="line">select first_name into fname from s_emp where id=eid;</span><br><span class="line">select salary into sal from s_emp where id = eid;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">         </span><br><span class="line">-- 如果参数是out修饰的,必须只能传入全局变量[作用就是来保存存储过程一些执行结果的值]</span><br><span class="line">call emp_pro(1,@fname,@sal);</span><br><span class="line">         </span><br><span class="line">select @fname;</span><br><span class="line">select @sal;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>第二种写法 - 针对的是单个结果集的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop procedure emp_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure emp_pro(in eid int(7),out fname varchar(25),out sal float(11,2))</span><br><span class="line">begin</span><br><span class="line">select first_name,salary into fname,sal from s_emp where id=eid;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">         </span><br><span class="line">-- 如果参数是out修饰的,必须只能传入全局变量[作用就是来保存存储过程一些执行结果的值]</span><br><span class="line">call emp_pro(1,@fname,@sal);</span><br><span class="line">         </span><br><span class="line">select @fname;</span><br><span class="line">select @sal;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="练习-封装的是多行结果集"><a href="#练习-封装的是多行结果集" class="headerlink" title="练习 - 封装的是多行结果集"></a>练习 - 封装的是多行结果集</h2><blockquote><p>找出大于某个id的first_name和salary - 结果可能是多行的</p><ol><li><p>现在已经被弃用的游标 - 性能很低下.</p></li><li><p><strong>需要定义第三方表来存储我们的多行结果集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 根据具体的查询的业务来构建第三方表 </span><br><span class="line">   业务中最终查询出来的数据正好都在s_emp表中.</span><br><span class="line">            </span><br><span class="line">   -- 仅仅保留结构,但是不保留结果</span><br><span class="line">   create table s_emp_pro select first_name,salary from s_emp where 1=2;</span><br><span class="line">            </span><br><span class="line">2. 比如分组统计,查询出来的数据不在某个表中存在 - 一定要根据具体的查询出来的数据 - 手动构建一张表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drop procedure emp_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure emp_pro(in eid int(7))</span><br><span class="line">begin</span><br><span class="line">-- insert into 表名 select 语句;</span><br><span class="line">insert into s_emp_pro(first_name,salary) select first_name,salary from s_emp where id &gt;= eid;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">         </span><br><span class="line">-- 如果参数是out修饰的,必须只能传入全局变量[作用就是来保存存储过程一些执行结果的值]</span><br><span class="line">call emp_pro(20);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="练习-带事务"><a href="#练习-带事务" class="headerlink" title="练习 - 带事务"></a>练习 - 带事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- 转账功能,同时成功,同时失败.</span><br><span class="line">drop procedure transfer_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure transfer_pro(in sid int(7),in tid int(7),in money double(7,2),in st int(7))</span><br><span class="line">begin</span><br><span class="line">-- 定义一个局部变量 - 展示信息</span><br><span class="line">declare msg varchar(20) default &#x27;0&#x27;;</span><br><span class="line">-- 手动开启一个事务</span><br><span class="line">start transaction;</span><br><span class="line">update account set balance = balance-money where id = sid;</span><br><span class="line">-- 模拟一个异常</span><br><span class="line">if st=1 then</span><br><span class="line">set msg = &#x27;sorry,转账失败了!&#x27;;</span><br><span class="line">rollback;</span><br><span class="line">else</span><br><span class="line">update account set balance = balance+money where id = tid;</span><br><span class="line">-- 手动提交一个事务</span><br><span class="line">set msg = &#x27;good,转账成功了!&#x27;;</span><br><span class="line">commit;</span><br><span class="line">end if;</span><br><span class="line">select msg;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- st=1,进入到异常块的.</span><br><span class="line">call transfer_pro(1,2,1000.0,1);</span><br><span class="line"></span><br><span class="line">-- st=2,正常执行转账的业务功能</span><br><span class="line">call transfer_pro(1,2,1000.0,2);</span><br></pre></td></tr></table></figure><h1 id="语句使用"><a href="#语句使用" class="headerlink" title="语句使用"></a>语句使用</h1><h2 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h2><blockquote><ol><li><p>if .. then .. elseif .. then ..elseif.. then … else.. end if;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drop procedure if_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure if_pro(in a int)</span><br><span class="line">begin</span><br><span class="line">declare msg varchar(20) default &#x27;&#x27;;</span><br><span class="line">if a&gt;=90 then</span><br><span class="line">set msg = &#x27;优秀&#x27;;</span><br><span class="line">elseif a&gt;=80 then</span><br><span class="line">set msg = &#x27;良好&#x27;;</span><br><span class="line">else</span><br><span class="line">set msg = &#x27;及格&#x27;;</span><br><span class="line">end if;</span><br><span class="line">select msg;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call if_pro(85);</span><br></pre></td></tr></table></figure></li><li><p>case .. when .. then..else… end case</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop procedure case_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure case_pro(in a int)</span><br><span class="line">begin</span><br><span class="line">declare msg varchar(20) default &#x27;&#x27;;</span><br><span class="line">case a</span><br><span class="line">when 1 then</span><br><span class="line">set msg=&#x27;1&#x27;;</span><br><span class="line">when 2 then</span><br><span class="line">set msg = &#x27;2&#x27;;</span><br><span class="line">else</span><br><span class="line">set msg = &#x27;3&#x27;;</span><br><span class="line">end case;</span><br><span class="line">select msg;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">         </span><br><span class="line">call case_pro(2);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><blockquote><ol><li><p>while .. do .. end while</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">drop procedure while_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure while_pro(in x int,out result int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">declare sums int default 0;</span><br><span class="line">while i&lt;=x do</span><br><span class="line">set sums = sums + i;</span><br><span class="line">set i = i+1;</span><br><span class="line">end while;</span><br><span class="line">-- result修饰成out =return result</span><br><span class="line">set result = sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">         </span><br><span class="line">-- out修饰的,只能传入全局变量</span><br><span class="line">call while_pro(100,@result);</span><br><span class="line">         </span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>loop … end loop</p><p>类似于while(true)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 求1~x结束</span><br><span class="line">drop procedure loop_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure loop_pro(in x int,out result int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">set result=0;</span><br><span class="line">success:loop</span><br><span class="line">if i&gt;x then</span><br><span class="line">-- 打破循环</span><br><span class="line">-- iterate success; -- conintue</span><br><span class="line">leave success; </span><br><span class="line">end if;</span><br><span class="line">set result = result + i;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end loop;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call loop_pro(100,@result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure></li><li><p>repeat .. until .. end repeat</p><p>类似于java-&gt; do..while</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop procedure repeat_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure repeat_pro(in x int)</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">set x = x + 1;</span><br><span class="line">select x;</span><br><span class="line">until x&gt;0</span><br><span class="line">end repeat;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">         </span><br><span class="line">call repeat_pro(-1);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="总结函数和存储过程的区别"><a href="#总结函数和存储过程的区别" class="headerlink" title="总结函数和存储过程的区别"></a>总结函数和存储过程的区别</h1><blockquote><ol><li>定义函数的时候,必须指定returns 返回类型.定义存储过程的时候不需要使用returns 返回类型</li><li>函数体中必须要有return语句+返回结果,但是存储过程可以没有return语句</li><li>函数的调用用select关键字,存储过程调用使用call关键字</li><li>存储过程更加侧重于封装以及预编译sql语句,提高sql语句的复用性.</li><li>存储过程中是使用in来接受参数,out来返回结果.</li></ol></blockquote><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><blockquote><p>在mysql中,当我们执行一些操作的时候[比如dml操作 - 触发器能够触发的事件],一旦事件被触发,就会执行一段程序</p><p>触发器的本质上就是一个特殊的存储过程</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><blockquote><ol><li>after触发器 - 在触发条件之后执行</li><li>before触发器 - 在触发条件之前执行</li></ol></blockquote><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 删除触发器</span><br><span class="line">drop trigger 触发器名称;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger 触发器名称</span><br><span class="line">触发时机(after,before) 触发事件(insert,delete,update) on 触发器事件所在的表名</span><br><span class="line">for each row</span><br><span class="line">-- 触发器事件程序</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="体验-1"><a href="#体验-1" class="headerlink" title="体验"></a>体验</h2><blockquote><ol><li><p>删除account表中的任意一条数据的时候[触发事件],并且把这条数据放入到备份表中acc_copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建备份表</span><br><span class="line">create table acc_copy select * from account where 1=2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">drop trigger acc_tri;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger acc_tri</span><br><span class="line">after delete on account</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">-- old.列名 - 刚刚删除的那条数据</span><br><span class="line">insert into acc_copy values(old.id,old.name,old.balance);</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">   </span><br><span class="line">-- 触发器是遇到触发的事件才会执行的.不是我们手动去调用的.</span><br><span class="line">delete from account where id=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">   +----+------+----------+</span><br><span class="line">   | id | name | balance  |</span><br><span class="line">   +----+------+----------+</span><br><span class="line">   |  2 | tom  | 10000.00 |</span><br><span class="line">   |  3 | jack |  9000.00 |</span><br><span class="line">   |  4 | ss   |  9000.00 |</span><br><span class="line">   |  5 | ss2  |  9000.00 |</span><br><span class="line">   +----+------+----------+</span><br><span class="line">   4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">   mysql&gt; select * from acc_copy;</span><br><span class="line">   +----+-------+---------+</span><br><span class="line">   | id | name  | balance |</span><br><span class="line">   +----+-------+---------+</span><br><span class="line">   |  1 | admin | 8000.00 |</span><br><span class="line">   +----+-------+---------+</span><br><span class="line">   1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>如果表和表之间存在约束关系,比如1:N,无论是在drop或者delete的时候.必须要先删除多的一方,然后再删除一的一方</p><p>必须先把一的一方的所有子记录全部删除完毕,才能删除一的一方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">drop table tri_cus;</span><br><span class="line">drop table tri_ord;</span><br><span class="line"></span><br><span class="line">create table tri_cus(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  name varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into tri_cus values(1,&#x27;admin&#x27;);</span><br><span class="line">insert into tri_cus values(2,&#x27;tom&#x27;);</span><br><span class="line"></span><br><span class="line">create table tri_ord(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  ord_no varchar(20),</span><br><span class="line">  cus_id int(7),</span><br><span class="line">  foreign key(cus_id) references tri_cus(id)</span><br><span class="line">);</span><br><span class="line">insert into tri_ord values(1,&#x27;1001&#x27;,1);</span><br><span class="line">insert into tri_ord values(2,&#x27;1002&#x27;,1);</span><br><span class="line">insert into tri_ord values(3,&#x27;1003&#x27;,2);</span><br><span class="line"></span><br><span class="line">-- 外键约束存在的原因</span><br><span class="line">mysql&gt; delete from tri_cus where id=1;</span><br><span class="line">ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tri_ord`, CONSTRAINT `tri_ord_ibfk_1` FOREIGN KEY (`cus_id`) REFERENCES `tri_cus` (`id`))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 删除客户之前,应该先删除订单</span><br><span class="line">drop trigger cus_tri;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger cus_tri</span><br><span class="line">before delete on tri_cus</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">-- 先去删除这个客户的子记录</span><br><span class="line">delete from tri_ord where cus_id=old.id;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from tri_cus where id=1;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tri_cus;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  2 | tom  |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tri_ord;</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | ord_no | cus_id |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  3 | 1003   |      2 |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>oracle数据库中还会多一个自检约束[自定义检测],check约束</p><p>但是Mysql中是不存在check约束.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- oracle - 使用check约束</span><br><span class="line">create table ckt(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  age int(1) check(age&gt;0 and age&lt;100)</span><br><span class="line">)</span><br><span class="line">-- 插入数据的时候,age插入的值只能在check约束自定义的规则之内,否则插入失败.</span><br><span class="line">   </span><br><span class="line">-- 面试题 - mysql中如何实现oracle数据库中的check自检约束的功能.</span><br><span class="line">-- 在执行insert的时候,对某些数据进行进一步的校验 - 触发器</span><br><span class="line">create table ckt(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  age int(1)</span><br><span class="line">);</span><br><span class="line">   </span><br><span class="line">drop trigger ckt_tri;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger ckt_tri</span><br><span class="line">before insert on ckt</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">-- 对新插入的数据进行一个校验</span><br><span class="line">-- old.列还是使用new.old列 - 看该列在表中有没有.</span><br><span class="line">if new.age&lt;18 then</span><br><span class="line">signal sqlstate &#x27;HY000&#x27; set message_text=&#x27;age不合法&#x27;;</span><br><span class="line">end if;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line">   </span><br><span class="line">insert into ckt values(1,20);</span><br><span class="line">   </span><br><span class="line">insert into ckt values(2,17);</span><br><span class="line">mysql&gt; insert into ckt values(2,17);</span><br><span class="line">ERROR 1644 (HY000): age不合法</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><ul><li><p>分表/分库</p></li><li><p>主从复制</p></li><li><p><em><strong>sql优化操作</strong></em></p><ul><li><p>select查询列不要出现 *</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">尽量还是select 具体的列名称,</span><br><span class="line">select * 效率低于select 具体的列 - &quot;争议&quot;</span><br><span class="line"></span><br><span class="line">为了数据的安全.</span><br></pre></td></tr></table></figure></li><li><p>不鼓励使用order by语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql中的order by性能是及其低下,业务中如果遇到排序.</span><br><span class="line">建议是先把数据取出来放入到java内存中 - 集合中.</span><br><span class="line"></span><br><span class="line">再通过java代码的集合排序的各种方式来进行对数据的排序.</span><br></pre></td></tr></table></figure></li><li><p>查询唯一的非索引列的值的时候,配合limit 1语句,避免全表扫描.</p></li><li><p>索引优化</p></li></ul></li></ul><h2 id="sql优化-至少背10条"><a href="#sql优化-至少背10条" class="headerlink" title="sql优化 - 至少背10条"></a>sql优化 - 至少背10条</h2><ol><li><p>MySQL如何执行区分大小写的字符串比较？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from s_emp where binary first_name = &#x27;Carmen&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎进行全表扫描。</p></li><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p></li><li><p>应尽量避免在where子句中对字段进行not null值判断，否则将导致引擎放弃使用索引而进行全表扫描</p></li><li><p>尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p></li></ol><p>​    select id from t where num=10 or num=20<br>​    可以这样查询：<br>​    <em>sel</em>ect id from t where num=10<br>​    <em>union</em><br>​    select id from t where num=20</p><ol start="6"><li><p>下面的查询也将导致全表扫描：(不能前置百分号)</p><p>select id from t where name like ‘c%’;//走索引.</p></li><li><p>not in也要慎用，否则会导致全表扫描，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于连续的数值，能用between就不要用in了：</span><br><span class="line">select id from t where num between 1 and 3</span><br></pre></td></tr></table></figure></li><li><p>尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where num/2=100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">应改为:</span><br><span class="line">select id from t where num=100*2</span><br></pre></td></tr></table></figure></li><li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p></li><li><p>不要在where子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p></li><li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><ul><li>遵循最左原则.</li></ul></li><li><p>很多时候用exists代替in[查询性能很低]是一个好的选择：</p></li></ol><p>​        select num from a where num in(select num from b)<br>​         用下面的语句替换：<br>​         <em><strong>select num from a where exists(select 1 from b where num=a.num)</strong></em></p><ol start="14"><li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用 - 索引有效 - 数据控制30%;</p></li><li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<em><strong>一个表的索引数最好不要超过6个</strong></em>，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p></li><li><p>应尽可能的避免更新 clustered [聚簇]索引数据列，因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>尽可能的使用<strong>varchar</strong>/nvarchar代替<strong>char</strong>/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>任何地方都不要使用select * from t，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p></li><li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">临时表和表变量 - 推荐表变量来代替临时表的用法.</span><br></pre></td></tr></table></figure></li><li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table，避免造成大量log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate table，然后drop table，这样可以避免系统表的较长时间锁定。</p></li><li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>索引高级</title>
    <link href="http://example.com/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/"/>
    <id>http://example.com/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/</id>
    <published>2021-08-16T11:02:10.000Z</published>
    <updated>2022-01-11T06:19:45.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySql索引B-树🌲"><a href="#MySql索引B-树🌲" class="headerlink" title="MySql索引B+树🌲"></a>MySql索引B+树🌲</h1><p> InnoDB 存储引擎中的 <em><strong>B+ 树索引</strong></em>。要介绍 B+ 树索引，就不得不提二叉查找树，</p><p>平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。</p><p><strong>索引文件和数据文件 - innodb中 - 合二为一的.</strong></p><p><strong>索引文件和数据文件 - myisam中 - 分开独立的.</strong></p><h1 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h1><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg">  </p><p>从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。</p><p>图中的圆为二叉查找树的节点，<em><strong>节点中存储了键（key）和数据（data）</strong></em>。<strong>键对应 user 表中的 id</strong>，<strong>数据对应 user 表中的行数据。</strong></p><p>二叉查找树的特点就是任何节点的<strong>左子节点的键值都小于当前节点的键值</strong>，<strong>右子节点的键值都大于当前节点的键值</strong>。顶端的节点我们称为<strong>根节点</strong>，<strong>没有子节点的节点我们称之为<em>叶节点</em>。</strong></p><p><em><strong>二叉树查找流程:</strong></em></p><p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p><ul><li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。</li><li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li><li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li></ul><p>利用二叉查找树我们只<strong>需要 3 次即可找到匹配的数据</strong>。如果在表中一条条的查找的话，<strong>我们需要 6 次才能找到。</strong></p><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造：</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/link.jpg"> </p><p>这个时候可以看到我们的<strong>二叉查找树变成了一个链表</strong>。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于<strong>全表扫描了</strong>。 </p><p>导致这个现象的原因其实是<strong>二叉查找树变得不平衡了</strong>，也就是<strong>高度太高了</strong>，从而导致查找效率的不稳定。</p><p>为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 </p><p><strong>平衡二叉树又称 AVL 树</strong>，在满足二叉查找树特性的基础上，要求<strong>每个节点的左右子树的高度差不能超过 1。</strong> </p><p>下面是平衡二叉树和非平衡二叉树的对比：</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/diff.png"> </p><p>左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2</p><p>  在图二右边的AVL树上：<br>  节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1；<br>  节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1；<br>  节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0；<br>  节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1；<br>  对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。</p><h1 id="B树🌲"><a href="#B树🌲" class="headerlink" title="B树🌲"></a>B树🌲</h1><p>因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。</p><p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我<strong>们应当尽量减少从磁盘中读取数据的次数</strong>。另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。</p><p>如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。如果我们用树这种数据结构作为索引的数据结构，<strong>那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块</strong>。我们都知道平衡<strong>二叉树可是每个节点只存储一个键值和数据的</strong>。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？</p><p>可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/n.jpg"> </p><p>为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树</p><p>B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/B.jpg"> </p><p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。</p><p>图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。</p><p>从上图可以看出，<strong>B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点</strong>，子节点的个数一般称为阶，<strong>上述图中的 B 树为 3 阶 B 树，高度也会很低。</strong></p><p>基于这个特性，<em><strong>B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</strong></em></p><p>假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：</p><ul><li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。</li><li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。</li><li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li></ul><h1 id="B-树🌲"><a href="#B-树🌲" class="headerlink" title="B+树🌲"></a>B+树🌲</h1><p>B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图：</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/B+.jpg"> </p><p>B+ 树和 B 树有什么不同:</p><ul><li><p>B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p><p>之所以这么做是因为在数据库中页的大小是固定的，<em><strong>InnoDB 中页的默认大小是 16KB。</strong></em></p><p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p><p>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p></li><li><p>因为 B+ 树索引的所有数据均存储在叶子节点，而<em><strong>且数据是按照顺序排列的。</strong></em></p><p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。有心的读者可能还发现上图 B+ 树中<strong>各个页之间是通过双向链表连接的</strong>，<strong>叶子节点中的数据是通过单向链表连接的</strong>。其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p><p>也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。通过上图可以看到，在 InnoDB 中，<strong>我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</strong></p><p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。<strong>在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</strong></p></li></ul><h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。</p><p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p><p>这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><ul><li><p>聚集索引（聚簇索引）：<em><strong>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</strong></em></p><p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，<strong>在 B+ 树的叶子节点中，存储了表中所有的数据。</strong></p><p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p></li><li><p>非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于<em><strong>非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键</strong></em>，想要<strong>查找数据我们还需要根据主键再去聚集索引中进行查找</strong>，这个再根据聚集索引查找数据的过程，我们称为<em><strong>回表</strong></em>。</p></li></ul><h2 id="聚簇索引查找流程"><a href="#聚簇索引查找流程" class="headerlink" title="聚簇索引查找流程"></a>聚簇索引查找流程</h2><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/jucu.jpg"> </p><p><strong>select</strong> * <strong>from</strong> <strong>user</strong> <strong>where</strong> id&gt;=18 <strong>and</strong> id &lt;40</p><p>其中 id 为主键，具体的查找过程如下：</p><p>①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p><p>从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p><p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 <em><strong>p2，定位到页 3。</strong></em></p><p>②要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。</p><p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，<em><strong>然后再拿到页 3 中的指针 p1，定位到页 8。</strong></em></p><p>③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p><p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，<em><strong>而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</strong></em></p><p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p><p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p><p>我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 <strong>8 中的 p 指针去读取页 9 中的数据。</strong></p><p>④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p><p>最终我们找到满足条件的所有数据，总共 12 条记录：</p><p>(18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。</p><p>下面看下具体的查找流程图:</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/jusearch.jpg"> </p><h2 id="非聚集索引查找数据"><a href="#非聚集索引查找数据" class="headerlink" title="非聚集索引查找数据"></a>非聚集索引查找数据</h2><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/noju.jpg"> </p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/noju.jpg"> </p><p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键.</p><h2 id="总结聚簇和非聚簇"><a href="#总结聚簇和非聚簇" class="headerlink" title="总结聚簇和非聚簇"></a>总结聚簇和非聚簇</h2><p><em><strong>select * from xxx where name =”Jim”;</strong></em></p><p>name是非关键列,但是<em><strong>name同时也是索引列 - 非聚簇索引.</strong></em></p><ul><li>非叶节点 - 索引列对应的值.</li><li>叶节点 - 键值对(name索引值 - 主键值)</li></ul><p><em><strong>从图一中可以通过非聚簇索引列的值 -&gt; 确定到该索引列值对应的主键值id.</strong></em></p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/x.png"> </p><p>根据图一找到的主键id,然后进行一<em><strong>次回表操作</strong></em>.再继续按照聚簇索引的搜索方式来确定到具体的行记录</p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/y.png"> </p><h1 id="MyISAM-索引"><a href="#MyISAM-索引" class="headerlink" title="MyISAM - 索引"></a>MyISAM - 索引</h1><p>***索引文件和数据文件是分开的.***B+树结构.</p><p>在 MyISAM 中，<em><strong>聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。</strong></em> </p><p><img src="/2021/08/16/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7/z.png">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>索引基础</title>
    <link href="http://example.com/2021/08/15/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/08/15/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-15T11:02:10.000Z</published>
    <updated>2022-01-11T06:19:16.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><blockquote><ol><li><p>用户表 - 自定义的表 - 存储用户的数据</p></li><li><p><strong>系统表 - 数据字典 - 存储的是用户表的元信息.</strong></p><p>用户表仅仅可能只是系统表中的一个字段存在着而已.</p></li><li><p>类似于java.lang.Class<T>,所有的类都是属于Class的对象 - <strong>类是用来描述对象</strong>.我们是可以通过Class对象的API来获取类的信息.</T></p><p>Class用来描述类的类.</p></li></ol></blockquote><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><blockquote><p>tbl_comment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">use information_schema;</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">发现里面有一个系统表 - TABLE_CONSTRAINTS - 数据字典 - 保存的是所有的表的约束信息.</span><br><span class="line"></span><br><span class="line">desc table_constraints;</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field              | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">table_name,constraint_name,constraint_type</span><br><span class="line">表名          约束名称           约束类型</span><br><span class="line"></span><br><span class="line">--1. 查什么</span><br><span class="line">--2. 到哪里查</span><br><span class="line"></span><br><span class="line">-- 查看tbl_comment表中以上三个字段</span><br><span class="line">mysql&gt; select table_name,constraint_name,constraint_type from table_constraints where table_name=&#x27;tbl_comment&#x27;;</span><br><span class="line"></span><br><span class="line">+-------------+-------------------------+-----------------+</span><br><span class="line">| table_name  | constraint_name         | constraint_type |</span><br><span class="line">+-------------+-------------------------+-----------------+</span><br><span class="line">| tbl_comment | PRIMARY                 | PRIMARY KEY     |</span><br><span class="line">| tbl_comment | tbl_comment_id_fk       | FOREIGN KEY     |</span><br><span class="line">| tbl_comment | tbl_comment_user_id_fk  | FOREIGN KEY     |</span><br><span class="line">| tbl_comment | tbl_comment_video_id_fk | FOREIGN KEY     |</span><br><span class="line">+-------------+-------------------------+-----------------+</span><br><span class="line"></span><br><span class="line">-- 查看tbl_comment表中的列的名称[COLUMN_NAME],列的数据类型[COLUMN_TYPE]</span><br><span class="line">mysql&gt; select column_name,column_type from columns where table_name=&#x27;tbl_comment&#x27;;</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| column_name | column_type |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| id          | int(7)      |</span><br><span class="line">| user_id     | int(7)      |</span><br><span class="line">| video_id    | int(7)      |</span><br><span class="line">| content     | varchar(50) |</span><br><span class="line">| comment_id  | int(7)      |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></blockquote><h1 id="索引基础篇"><a href="#索引基础篇" class="headerlink" title="索引基础篇"></a>索引基础篇</h1><p>简介:mysql中不同的存储引擎的索引的实现方式是不同的.</p><p><strong>索引最大的好处就是会提高查询效率,但是索引也是占内存空间,索引也是需要进行维护[更新 - 消耗时间]的.并不是索引建立的越多越好.</strong></p><p>**5.7及其以后默认的存储引擎就是innodb,**之前默认采用的是myisam</p><p>myisam和innodb有何区别</p><ol><li><p><strong>innodb支持事务,myisam不支持事务 [DTL命令是不支持的]</strong></p></li><li><p>myisam支持全文索引.但是innodb不支持全文索引.</p></li><li><p>innode可以支持到行锁.myisam支持到表锁.</p><p>行锁的性能高于表锁.</p></li><li><p>innodb支持b+树索引 - 笔试索引的底层原理 = <strong>B+树相关</strong></p></li><li><p><strong>innodb支持外键约束的.</strong></p></li></ol><p><img src="/2021/08/15/mysql_%E4%B8%93%E9%A2%98%E7%AF%87_%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80/engine.png"> </p><h2 id="索引的底层-见高级篇"><a href="#索引的底层-见高级篇" class="headerlink" title="索引的底层 - 见高级篇"></a>索引的底层 - 见高级篇</h2><ul><li><p>MyISAM</p><ul><li><p>有单独的<strong>索引文件</strong>的,索引过多 - 索引文件变大(占空间的)</p></li><li><p><strong>叶子节点中保存的是索引+物理行地址的</strong></p><p>索引的本质:键值对(索引列值,物理行地址)</p></li><li><p>先判断查询是否走了索引,先查询索引文件,找到物理行地址</p><p>再由地址直接定位到数据表.</p></li><li><p>索引是单独的文件</p></li></ul></li><li><p>InnoDB</p><ul><li>索<em><strong>引文件不是一个单独的文件,它和数据文件是合二为一的.</strong></em></li><li>索引和数据-&gt;数据文件中 -&gt; 聚簇索引</li></ul></li></ul><h2 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a>索引算法</h2><ul><li>B+Tree(索引数据结构)<ul><li>聚簇索引 - mysql会自动选择主键列作为聚簇索引列<ul><li>非叶节点 - 聚簇索引列的值</li><li>叶节点 - 聚簇索引列值以及真实的数据.</li></ul></li><li>非聚簇索引<ul><li>非叶节点 - 非聚簇索引列的值</li><li>叶节点 - 键值对(非聚簇索引列的值,主键值)</li></ul></li></ul></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ol><li>好处:加快了查询速度(select )</li><li>坏处:降低了增,删,改的速度(update/delete/insert),增大了表的文件大小(索引文件甚至可能比数据文件还大)</li></ol><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ol><li><p>普通索引(index)：仅仅是加快了查询速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给非唯一,非主键的列添加的索引.比如表中的某列字段经常被用来搜索,比如email</span><br><span class="line">create index 索引名 on 表名(列名);</span><br><span class="line">-- 删除</span><br><span class="line">alter table 表名 drop index 索引名;</span><br></pre></td></tr></table></figure></li><li><p><strong>唯一索引(unique)：</strong>行上的值不能重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果创建列的时候,给该列添加了唯一约束unique.那么这个列默认就是唯一索引.</span><br></pre></td></tr></table></figure></li><li><p><strong>主键索引(primary key)：</strong>不能重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果某列是主键列,那么该列默认就是索引列.</span><br><span class="line">-- 删除主键索引.索引索引自动创建的.索引名是系统自动分配的,特殊的名称PRIMARY</span><br><span class="line">alter table 表名 drop primary key;</span><br><span class="line"></span><br><span class="line">-- show index from 表名;</span><br><span class="line">-- 查看数据字典 - 保存了所有表的索引信息.</span><br></pre></td></tr></table></figure></li><li><p><strong>全文索引(fulltext):仅可用于 MyISAM 表</strong>，针对较大的数据，生成全文索引很耗时空间。</p></li><li><p>组合索引[覆盖索引]：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">俩列作为一个整体 - 实际上是构成了一个索引.</span><br><span class="line">where province = ? and  city = ?   </span><br><span class="line">create index pro_city_index on xx(province,city);</span><br></pre></td></tr></table></figure></li></ol><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h2 id="创建索引总览"><a href="#创建索引总览" class="headerlink" title="创建索引总览"></a>创建索引总览</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    [col_name data type]</span><br><span class="line">[<span class="keyword">unique</span><span class="operator">|</span>fulltext][index<span class="operator">|</span>key] [index_name](col_name[length]) [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>unique|fulltext为可选参数，分别表示唯一索引、全文索引</li><li>index和key为同义词，两者作用相同，用来指定创建索引</li><li>col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</li><li>index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</li><li>length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</li><li>asc或desc指定升序或降序的索引值存储</li></ol><h2 id="索引使用方式"><a href="#索引使用方式" class="headerlink" title="索引使用方式"></a>索引使用方式</h2><ol><li><p>查看某张表上的所有索引</p><p>show index from tableName [\G,如果是在cmd窗口，可以换行];</p></li><li><p>建立索引</p><p><strong>CREATE INDEX  索引名 ON 表名(列值)</strong></p><p>删除索引 - <strong>alter table 表名 drop index 索引名;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">drop table index_test;</span><br><span class="line">create table index_test(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  a int(7),</span><br><span class="line">  b int(7),</span><br><span class="line">  c varchar(20),</span><br><span class="line">  d varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into index_test values(1,100,10,&#x27;aaa&#x27;,&#x27;A&#x27;);</span><br><span class="line">insert into index_test values(2,300,30,&#x27;aba&#x27;,&#x27;BB&#x27;);</span><br><span class="line">insert into index_test values(3,200,20,&#x27;caa&#x27;,&#x27;CC&#x27;);</span><br><span class="line">insert into index_test values(4,100,10,&#x27;daa&#x27;,&#x27;DD&#x27;);</span><br><span class="line">insert into index_test values(5,500,50,&#x27;aad&#x27;,&#x27;FF&#x27;);</span><br><span class="line"></span><br><span class="line">-- 默认主键列就是属于索引列 - 主键索引</span><br><span class="line">mysql&gt; show index from index_test \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: index_test</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 5</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 给a列单独创建一个索引 - 普通索引 - 非聚簇索引</span><br><span class="line">create index index_test_a on index_test(a);</span><br><span class="line"></span><br><span class="line">-- 删除普通索引</span><br><span class="line">alter table index_test drop index index_test_a;</span><br><span class="line"></span><br><span class="line">-- 创建一个组合索引 - 非聚簇索引</span><br><span class="line">-- 非聚簇索引 - 非主键列索引</span><br><span class="line">-- 聚簇索引 - 主键列索引</span><br><span class="line">-- a,b当成一个整体来处理 - 实际上仍然是只有一个索引</span><br><span class="line">create index index_test_a_b on index_test(a,b);</span><br><span class="line"></span><br><span class="line">-- 给定一个索引的长度key_len,列的数据类型应该是字符串类型</span><br><span class="line">create index index_test on index_test(c(1));</span><br><span class="line">比如c列是学生的名称</span><br><span class="line">王三</span><br><span class="line">王静静</span><br><span class="line">王老二</span><br><span class="line">王八犊子</span><br><span class="line">王静二</span><br><span class="line">王静三</span><br><span class="line"></span><br><span class="line">-- 给某列创建索引的目的就是为了提高根据该列进行查询的效率</span><br><span class="line">-- 索引长度是1,区分度不够.假设的是姓王的比较多.</span><br><span class="line">-- 并没有提高多少查询效率</span><br><span class="line">-- 目录页 -&gt;    王  -&gt; 2页到10页</span><br><span class="line">select * from student where c=&#x27;王静%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 长度为2</span><br><span class="line">-- 目录页</span><br><span class="line">-- 王三  - 2页</span><br><span class="line">-- 王静  - 4页~5页</span><br><span class="line">-- 王老,王八....</span><br><span class="line"></span><br><span class="line">-- create index index_test on index_test(c(2));</span><br><span class="line">-- 前俩个</span><br><span class="line">select * from student where c=&#x27;王静%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 如果很多位重复,如何处理.....</span><br><span class="line"></span><br><span class="line">-- 自己了解...</span><br></pre></td></tr></table></figure><p><em><strong>alter table 表名 add primary key(列名) –不要加索引名，因为主键只有一个</strong></em></p></li><li><p>删除非主键索引</p><p>alter table 表名 drop index 索引名；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除主键索引：</p><p><em><strong>alter table 表名 drop primary key;</strong></em></p></li></ol><h2 id="查看查询是否使用到了索引"><a href="#查看查询是否使用到了索引" class="headerlink" title="查看查询是否使用到了索引"></a>查看查询是否使用到了索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>explain <span class="keyword">select</span>语句;</span><br></pre></td></tr></table></figure><h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>(5)复合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表(列1,列2,列n);</span><br></pre></td></tr></table></figure><h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><blockquote><p><strong>面试题 - 数据库如何进行优化 - 谈到如何解决索引失效.</strong></p></blockquote><p>索引type从优到差：System–&gt;**const–&gt;eq_ref–&gt;ref–&gt;ref_or_null–&gt;index_merge–&gt;unique_subquery–&gt;index_subquery–&gt;**range–&gt;index–&gt;<strong>all(全表扫描的意思)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">drop table index_test;</span><br><span class="line">create table index_test(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  a int(7),</span><br><span class="line">  b int(7),</span><br><span class="line">  c varchar(20),</span><br><span class="line">  d varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into index_test values(1,100,10,&#x27;aaa&#x27;,&#x27;A&#x27;);</span><br><span class="line">insert into index_test values(2,300,30,&#x27;aba&#x27;,&#x27;BB&#x27;);</span><br><span class="line">insert into index_test values(3,200,20,&#x27;caa&#x27;,&#x27;CC&#x27;);</span><br><span class="line">insert into index_test values(4,100,10,&#x27;daa&#x27;,&#x27;DD&#x27;);</span><br><span class="line">insert into index_test values(5,500,50,&#x27;aad&#x27;,&#x27;FF&#x27;);</span><br><span class="line"></span><br><span class="line">-- 复合索引</span><br><span class="line">create index index_test_abc on index_test(a,b,c);</span><br><span class="line"></span><br><span class="line">-- 测试explain - 测试查询是否使用到了索引.</span><br><span class="line">-- 测试主键索引</span><br><span class="line">mysql&gt; explain select * from index_test where id = 4;</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | index_test | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">主要就是观察type=&#x27;const&#x27;;</span><br><span class="line">所谓创建索引 - 索引高级篇.</span><br><span class="line">索引文件采取一个数据结构[b+树]用来专门存放索引.</span><br><span class="line">为何根据索引查找比较快 - 先查索引[先查目录] - 进行定位到行的操作 - myisam中.</span><br><span class="line"></span><br><span class="line">myisam中索引文件和数据文件.独立存储的,也是分开的存储.</span><br><span class="line"></span><br><span class="line">1. 数据文件[磁盘上的]也就是所谓的表文件.加载到mysql内存中[select].</span><br><span class="line">   表里面的每一行在内存中也有一个内存地址.</span><br><span class="line"></span><br><span class="line">2. 索引文件存储的是索引列的值以及该索引列对应的行记录的内存地址.</span><br><span class="line">   索引列   内存地址</span><br><span class="line">   1       0x7a</span><br><span class="line">   2       0x7b</span><br><span class="line">   3       0x7c</span><br><span class="line">   4       0x7d</span><br><span class="line">   5       0x7e</span><br><span class="line">   myisam索引 - 键值对索引[键 - 索引列值,值 - 行记录的内存地址]</span><br><span class="line">   键值对存储在B+树中.</span><br><span class="line">   select * from index_test where id = 4;</span><br><span class="line">   </span><br><span class="line">   1. 根据id=4先到索引文件中去查找了[消耗时间的]</span><br><span class="line">   2. 找到id=4对应的行记录地址[唯一的映射关系]</span><br><span class="line">   3. 直接根据行记录地址定位到具体的一行,不需要在数据文件中进行一个全表扫描了.</span><br><span class="line"></span><br><span class="line">-- 测试非索引列的查询 d</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from index_test where d = &#x27;DD&#x27;;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | index_test | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |    20.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">Type=&#x27;all&#x27; , 全表扫描 , 没有用到索引或者索引失效 , 从表里面的第一行一直扫描到最后一行 - 查询性能肯定是低下的.</span><br></pre></td></tr></table></figure><h3 id="遵循最左原则"><a href="#遵循最左原则" class="headerlink" title="遵循最左原则"></a>遵循最左原则</h3><p>简介:<em><strong>针对的是复合索引</strong></em> - 查询语句where最左边的列一定要和创建复合索引的第一个列保持一致.</p><ul><li>复合索引(a,b,c) - 必须要连续.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-- 创建复合索引的第一个列a</span><br><span class="line">create index index_test_abc on index_test(a,b,c);</span><br><span class="line"></span><br><span class="line">-- a,b,c都是生效的-100 |   10 | daa</span><br><span class="line">explain select * from index_test where a=100 and b=10 and c=&#x27;daa&#x27;;</span><br><span class="line">-- key_len 是73,三个索引都走了.</span><br><span class="line"></span><br><span class="line">-- 比如b失效的场景,c也是失效</span><br><span class="line">explain select * from index_test where b=10;//不走索引</span><br><span class="line">explain select * from index_test where c=&#x27;daa&#x27;;//不走索引</span><br><span class="line"></span><br><span class="line">-- 不生效 - mysql5.7以后对where语句进行了优化.</span><br><span class="line">-- oracle中where语句如果跟了多个条件,执行顺序 - 从右到左</span><br><span class="line">-- mysql中where语句条件默认是从左到右的.</span><br><span class="line">-- mysql低版本中where c=&#x27;daa&#x27; and a=100;//不会走索引的</span><br><span class="line">-- mysql5.7优化,优化成where a=100 and c=&#x27;add&#x27;;//才会走索引.</span><br><span class="line"></span><br><span class="line">-- a走了索引,c没有索引 - 特殊的场景 - 底层优化了.</span><br><span class="line">explain select * from index_test where c=&#x27;daa&#x27; and a=100;</span><br><span class="line">-- key_len = 5</span><br><span class="line"></span><br><span class="line">-- a列索引生效</span><br><span class="line">explain select * from index_test where a = 100;</span><br><span class="line">-- key_len = 5</span><br><span class="line"></span><br><span class="line">-- a,b生效</span><br><span class="line">explain select * from index_test where a=100 and b=10;</span><br><span class="line">-- key_len = 10</span><br><span class="line">-- 如果仅仅是根据a列查询,key_len是5,但是此时key_len是10.说明a,b索引都生效.</span><br><span class="line"></span><br><span class="line">-- a列是走了索引,但是c列没有走索引</span><br><span class="line">-- 必须要连续.这个是时候a和c是不连续的,中间跳过了b.所以只有a是生效的,但是c是不生效的.</span><br><span class="line">explain select * from index_test where a=100 and c=&#x27;daa&#x27;;</span><br><span class="line">-- key_len=5</span><br></pre></td></tr></table></figure><h3 id="范围之后索引列也会失效"><a href="#范围之后索引列也会失效" class="headerlink" title="范围之后索引列也会失效"></a>范围之后索引列也会失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- a列和b列是走了索引的,但是c列没有走索引.因为c列是范围之后的判断</span><br><span class="line">mysql&gt;explain select * from index_test where a=100 and b&gt;10 and c=&#x27;daa&#x27;;</span><br><span class="line"></span><br><span class="line">-- 如果三个索引都生效 - key_len=73</span><br><span class="line">-- 如果只有a,b走索引 - key_len=10   √</span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">like &#x27;%&#x27;出现在末尾,仍然a,b,c都是走索引</span><br><span class="line">-- key_len = 73 - a,b,c都是走了索引的</span><br><span class="line">mysql&gt; explain select * from index_test where a=100 and b=10 and c like &#x27;d%&#x27;;</span><br><span class="line"></span><br><span class="line">-- like &#x27;%&#x27;如果出现在开始,不走索引的</span><br><span class="line">-- 只有a,b是走了索引的,c是没有走索引的</span><br><span class="line">-- key_len = 10 </span><br><span class="line">mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d&#x27;;</span><br><span class="line"></span><br><span class="line">-- 只有a,b是走了索引的,c是没有走索引的</span><br><span class="line">-- key_len=10</span><br><span class="line">mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="索引列使用函数"><a href="#索引列使用函数" class="headerlink" title="索引列使用函数"></a>索引列使用函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">索引列套在函数中使用,将会导致索引失效</span><br><span class="line"></span><br><span class="line">-- 进行了ALL全表扫描</span><br><span class="line">mysql&gt; explain select * from index_test where abs(id)=1;</span><br><span class="line"></span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | index_test | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h3 id="索引列参加了计算"><a href="#索引列参加了计算" class="headerlink" title="索引列参加了计算"></a>索引列参加了计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 导致索引列失效</span><br><span class="line">mysql&gt; explain select * from index_test where id+1=2;</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from index_test where id = 2 - 1;</span><br></pre></td></tr></table></figure><h3 id="索引列参加运算符"><a href="#索引列参加运算符" class="headerlink" title="索引列参加运算符"></a>索引列参加运算符</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给员工表的提成率列添加一个索引-普通索引</span></span><br><span class="line"><span class="keyword">create</span> index s_emp_cp <span class="keyword">on</span> s_emp(commission_pct);</span><br><span class="line"><span class="comment">-- is null(没有走索引)和is not null(走索引)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- is null - type=&#x27;ALL&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span>explain <span class="keyword">select</span> first_name,commission_pct <span class="keyword">from</span> s_emp <span class="keyword">where</span> commission_pct <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> s_emp_cp      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span>    <span class="number">80.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- is not null type=&#x27;range&#x27; - 走了索引的.</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> first_name,commission_pct <span class="keyword">from</span> s_emp <span class="keyword">where</span> commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> s_emp_cp      <span class="operator">|</span> s_emp_cp <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- in(走索引 - range)  not in(不走索引 - ALL)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> index_test <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> index_test <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 能用关联解决的,尽量不要使用not</span></span><br><span class="line"><span class="comment">-- 找出没有选择任何一门课程的学生的信息</span></span><br></pre></td></tr></table></figure><h3 id="利用索引列查询出来的数据超过整张表的30"><a href="#利用索引列查询出来的数据超过整张表的30" class="headerlink" title="利用索引列查询出来的数据超过整张表的30%."></a>利用索引列查询出来的数据超过整张表的30%.</h3><blockquote><p>当数据量达到百万级别.</p></blockquote><blockquote><p>索引对应的重复的数据太多也是不适合创建索引的.</p><p>city=’苏州’</p></blockquote><h2 id="建立索引的策略"><a href="#建立索引的策略" class="headerlink" title="建立索引的策略"></a>建立索引的策略</h2><blockquote><p>a. 索引不是越多越好的 </p><p>   因为索引也是需要占内容,也是需要到索引文件中去匹配索引的 - 需要消耗时间的.</p><p>   更新数据的同时,我们更新索引数据.</p></blockquote><ol><li>主键列和唯一性列                        √</li><li>不经常发生改变的[在update列数据的数据的时候,也会更新索引文件]                √</li><li>满足以上2个条件,经常作为查询条件的列    √</li><li>重复值太多的列                        ×</li><li>null值太多的列                        ×</li></ol><h1 id="查询效率"><a href="#查询效率" class="headerlink" title="查询效率"></a>查询效率</h1><ol><li>数据库读写分离.</li><li>分表分库 - 水平分割和垂直分割</li><li>使用专门的搜索引擎 - es - elasticsearch/solr</li><li>避免使用索引查询导致索引失效 - 规避问题.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>DTL与事务</title>
    <link href="http://example.com/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-08-13T11:02:10.000Z</published>
    <updated>2022-01-11T06:18:46.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DTL"><a href="#DTL" class="headerlink" title="DTL"></a>DTL</h1><blockquote><p>Data Transaction Language - 数据事务语言</p><p>commit,begin,start transction,savepoint,rollback</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote><p>只要使用客户端连接到mysql-server[mysql服务器],就会自动打开一个事务</p></blockquote><p>在MYSQL中,<em><strong>所有的DML(insert,update,delete)操作</strong></em>在执行之后都会有一个<strong>commit操作</strong>[隐式的]</p><p><strong>commit - 提交事务</strong></p><p>在ORACLE中,所有的DML(insert,update,delete)操作之后,如果没有手动commit,那么在另外一个事务中是读不到最新的更新数据的.</p><p><strong>DTL,数据事务语言</strong></p><p><strong>事务的定义:</strong></p><p>就是指<strong>一组相关的SQL操作</strong>,我们所有的操作都是处在事务中的.</p><p>执行业务的基本单位是 - 不是sql,而是事务.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java 代码 - 转账</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> srcid,<span class="keyword">int</span> targetid,<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">  <span class="comment">//设置不要自动提交模式</span></span><br><span class="line">  conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">  Transaction tx = conn.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//事务保证原子性  - 要么同时成功,要么同时失败.</span></span><br><span class="line">    String sql = <span class="string">&quot;update xx set balance = balance-&quot;</span>+money+<span class="string">&quot;where id=&quot;</span>+srcid;</span><br><span class="line">    <span class="comment">//TODO... 执行sql,默认会自动提交事务的 -commit;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一旦是手动提交事务,那么上面的update操作仅仅是内存中的操作.尚未提交到db中.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他代码... 出现了异常  , 手动提交 - 进入到catch</span></span><br><span class="line"></span><br><span class="line">    String sql2 = <span class="string">&quot;update xx set balance = balance+&quot;</span>+money+<span class="string">&quot;where id=&quot;</span>+targetid;</span><br><span class="line">    <span class="comment">//TODO ... 执行sql默认会自动提交事务的 -commit;</span></span><br><span class="line">    </span><br><span class="line">    tx.commit();</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    tx.rollback();<span class="comment">//进行一个事务的回滚操作.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制事务 - 就是控制事务的边界(事务的开始(begin) - 事务的结束(commit,rollback))</p><p><em><strong>一个事务的结束,代表着下一个事务的开始.</strong></em></p><p><strong>注意:</strong></p><ol><li><p>在数据库中**,执行业务的基本单位是事务,不是以某一条SQL**</p></li><li><p>数据库在默认情况下,事务都是打开的,也就是说它是一直</p></li><li><p>处在事务中的,一个事务的结束,代表着下一个事务的开启</p></li><li><p>执行commit或者rollback指令时,<strong>会结束当前事务</strong></p><p><strong>[已经提交的事务将不能够被回滚 - 已经不处于同一个事务中了,而事务与事务之间是隔离的]</strong></p></li></ol><p><strong>作用:用来保证数据的平稳性和可预测性.</strong></p><h1 id="事务的四大特性-ACID-笔试"><a href="#事务的四大特性-ACID-笔试" class="headerlink" title="事务的四大特性(ACID): - 笔试"></a><strong>事务的四大特性(ACID):</strong> - 笔试</h1><ol><li><p><strong>Atomicity,原子性</strong>,事务是不可再分割的,要么同时成功,要么同时失败.</p><p>转账业务(账户+money,账户-money - 一组sql - 至于一个事务当中,并且要保证原子性.)</p></li><li><p><strong>Consistency,一致性</strong>,<strong>事务一旦结束,内存中的数据和数据库中的数据是保持一致的</strong></p><p>example：A用户和B用户进行转账1000元，A账户减少1000和B账户增加1000的sql语句必须全部执行成功，不存在一半成功，一半失败。<br>但是无论如何执行，两个账户金额的改变加起来一定1000元，<strong>这就是一致性(数据的完整性)。</strong></p></li><li><p><strong>Isolation,隔离性</strong>,事务之间互不干扰,一多个用户并发访问数据库，比如同时操作一张表。数据库为每一个用户开启事务。<strong>每个事务相互独立，互不干扰。</strong></p></li><li><p><strong>Durability,持久性</strong>,事务一旦提交,则内存中的数据持久化[保存,序列化]到数据库中,<strong>永久保存</strong></p><p>[涉及到数据库的备份和恢复的一些技术,冷备份,热备份…]</p><p>DB - sqlData数据文件以及log目录[日志文件 - 记录了用户的sql操作]</p></li></ol><h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><p>DTL - 事务控制语言.</p><ol><li><strong>BEGIN或START TRANSACTION</strong>；显式地开启一个事务；</li><li><strong>COMMIT；</strong>也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；</li><li><strong>ROLLBACK；</strong>有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；</li><li>RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>ROLLBACK TO identifier；把事务回滚到标记点；</li><li>SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有<em><strong>READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</strong></em></li></ol><h3 id="rollback-demo-回滚所有"><a href="#rollback-demo-回滚所有" class="headerlink" title="rollback - demo - 回滚所有"></a>rollback - demo - 回滚所有</h3><blockquote><p>前提 - 设置成手动提交事务</p><p><code>注意:1. 如果没有设置事务点 - rollabck撤销所有的dml操作的</code></p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/rollback.png"> </p></blockquote><blockquote><p><code>注意的是rollback只能撤销/回滚尚未提交的事务.如果一个事务已经提交了,那么是回滚不了的</code></p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/r2.png"> </p></blockquote><h3 id="设置事务点"><a href="#设置事务点" class="headerlink" title="设置事务点"></a>设置事务点</h3><blockquote><p>命令 - savepoint 事务点名称;</p><p>rollback to 事务点名称.</p><p><code>效果就是会撤销到设置事务点下方的dml操作.事务点之前的dml操作将不会撤销</code></p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/r3.png"> </p></blockquote><h2 id="MYSQL-事务处理主要有两种方法"><a href="#MYSQL-事务处理主要有两种方法" class="headerlink" title="MYSQL 事务处理主要有两种方法"></a>MYSQL 事务处理主要有两种方法</h2><h2 id="自动开始事务"><a href="#自动开始事务" class="headerlink" title="自动开始事务"></a>自动开始事务</h2><blockquote><ol><li>当我们mysql客户端连接到mysql服务器 - 自动开启</li><li>当执行完sql语句之后,自动会commit[事务的提交 - 意味着当前事务已经结束]</li><li>一个事务的结束意味着下一个事务的开始.</li><li><strong>commit/rollback - 结束事务.</strong></li></ol></blockquote><h2 id="手动开启事务"><a href="#手动开启事务" class="headerlink" title="手动开启事务"></a>手动开启事务</h2><blockquote><p>执行dml操作之后,就不会自动提交事务[commit],需要手动commit</p></blockquote><blockquote><ol><li><p>用 BEGIN, ROLLBACK, COMMIT来实现</p><p>1-1. <strong>BEGIN 开始一个事务</strong></p><p>1-2. <strong>start transaction - 手动开始一个事务</strong></p></li><li><p>ROLLBACK 事务回滚</p></li><li><p>COMMIT 事务确认</p></li></ol></blockquote><h3 id="demo01"><a href="#demo01" class="headerlink" title="demo01"></a>demo01</h3><blockquote><p>A事务 - 执行了delete操作,但是还没有commit.</p><p>但是在A事务当中,查询的时候,是可以查询到delete的效果的</p><p>mysql&gt;begin;</p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/tx01.png"> </p></blockquote><blockquote><p>但是在另外一个事务B中,是看不到A事务中尚未提交的数据的[仍然是可以看到id=2这条数据的]</p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/tx02.png"> </p></blockquote><p><code>对A事务进行一个commit操作</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>对于B事务来讲,分俩种情况.第一种情况是B一开始的事务还未提交,看到的效果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from video_copy;</span><br><span class="line">+----+--------------+-------+---------------------+-------------+</span><br><span class="line">| id | title        | likes | create_time         | tbl_user_id |</span><br><span class="line">+----+--------------+-------+---------------------+-------------+</span><br><span class="line">|  1 | java无敌     |   200 | 2021-08-19 13:38:38 |           1 |</span><br><span class="line">|  2 | python不错   |   200 | 2021-08-19 13:39:45 |           1 |</span><br><span class="line">+----+--------------+-------+---------------------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>B事务提交,也结束了当前的事务,自动开启一个新的事务,在新的事务中重新再查一次</code>,可以看到A事务提交的结果了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from video_copy;</span><br><span class="line">+----+------------+-------+---------------------+-------------+</span><br><span class="line">| id | title      | likes | create_time         | tbl_user_id |</span><br><span class="line">+----+------------+-------+---------------------+-------------+</span><br><span class="line">|  1 | java无敌   |   200 | 2021-08-19 13:38:38 |           1 |</span><br><span class="line">+----+------------+-------+---------------------+-------------+</span><br><span class="line">1 row in set (0.00 sec)   </span><br></pre></td></tr></table></figure><ol start="2"><li><p>直接用 SET 来改变 MySQL 的自动提交模式: </p><p>2-1. <strong>SET AUTOCOMMIT=0 禁止自动提交</strong></p><p>2-2. SET AUTOCOMMIT=1 开启自动提交</p><p>注意:设置成禁止自动提交的操作的话,这个操作仅仅是针对当前的会话窗口有效.</p></li></ol><h1 id="多事务的并发处理机制"><a href="#多事务的并发处理机制" class="headerlink" title="多事务的并发处理机制"></a>多事务的并发处理机制</h1><p>原因:多个事务同时操作一个表中的<strong>同一行数据(争抢临界资源)</strong>,如果这些操作是.修改操作的话,就会产生并发问题,如果不处理,则会造成数据不一致的情况.</p><p>数据库可能产生的并发问题包括:</p><blockquote><ol><li><code>脏读</code></li></ol><p> 简介:一个事务读取到了另外一个事务中尚未提交的数据.</p><blockquote><p>是指一个事务正在访问数据,并且对这个数据进行修改,而这种修改<br>还没有提交到数据库中,而另一个事务也访问了这个数据,并且使用了这个数据<br>解决方法:一个事务在修改数据时,该数据不能被其他事务访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;所有的数据库都是拒绝脏读 - &quot;会读到脏数据&quot;.</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><ol start="2"><li><code>不可重复读</code></li></ol><blockquote><p>是指一个事务多次读取同一条记录,如果此时另一个事务也访问并且<br>修改了该数据,则就会出现多次读取出现数据不一致的情况,原来的<br>数据变成了不可重复读取的数据<br>解决方法:只有在修改事务完全提交过后才可以读取到数据</p></blockquote></blockquote><blockquote><ol start="3"><li><code>幻读</code></li></ol><blockquote><p>是指一个事务修改表中的多行记录[比如查询也是可以的],但是此时另一个事务对该表格进行<br>了<strong>插入数据</strong>的操作,则第一个事务会发现表格中会出现没有被修改的行<br>就像发生了幻觉一样<br>解决方法:在一个事务提交数据之前,其他事务不能添加数据</p></blockquote></blockquote><p><strong>不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了幻读的重点在于新增或者删除</strong></p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><blockquote><ol><li>READ UNCOMMITTED</li></ol><blockquote><p>这是事务最低的隔离级别，<strong>它允许另外一个事务可以看到这个事务未提交的数据</strong>。<br>解决第一类丢失更新的问题，但是会出现脏读、不可重复读.</p></blockquote></blockquote><blockquote><ol start="2"><li>READ COMMITTED</li></ol><blockquote><p>保<strong>证一个事务修改的数据提交后才能被另外一个事务读取</strong>，即另<strong>外一个事务不能读取该事务未提交的数据</strong>。<br>解决第一类丢失更新和脏读的问题，但会出现不可重复读.</p></blockquote></blockquote><blockquote><ol start="3"><li><strong>REPEATABLE READ</strong></li></ol><p>  <strong>简介:mysql默认的事务的隔离级别.</strong></p><blockquote><p>保证一个事务相同条件下前后两次获取的数据是一致的<br>解决第一类丢失更新，脏读、不可重复读.</p></blockquote></blockquote><blockquote><ol start="4"><li>SERIALIZABLE - 串行化</li></ol><blockquote><p>事务被处理为顺序执行。解决所有问题 - 有点类似于<strong>锁表.</strong></p></blockquote><blockquote><p>性能及其低下.</p></blockquote></blockquote><p><strong>提醒：</strong><br><strong>Mysql默认的事务隔离级别为repeatable_read</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;set session transaction isolation level read uncommitted;</span><br><span class="line">mysql&gt;select @@tx_isolation;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交-(read committed)  - 不可重复读</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读(repeatable read)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化(serializable)</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h1 id="事务的演示"><a href="#事务的演示" class="headerlink" title="事务的演示"></a>事务的演示</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drop table account;</span><br><span class="line">create table account(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  balance double(7,2)</span><br><span class="line">);</span><br><span class="line">insert into account values(1,&#x27;admin&#x27;,1000.00),(2,&#x27;tom&#x27;,2000.00);</span><br></pre></td></tr></table></figure><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><blockquote><ol><li><p>设置事务的隔离级别READ UNCOMMITTED - 一个事务才可以读取到另外一个事务尚未提交的数据.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/zd.png"> </p></li></ol></blockquote><p>​            <code>总结-一旦事务设置成了读未提交的隔离级别.产生脏读以及不可重复读的效果</code></p><p>​            <code>不可重复读 - 在同一个事务中,多次读取到的数据不一样</code></p><h2 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h2><blockquote><p>set session transaction isolation level read committed;</p><ol><li>一个事务只能读取到另外一个事务中已经提交的数据</li><li>不会出现脏读了.但是仍然会出现<strong>不可重复读</strong>[一定是在同一个事务中多次读取到的结果是不一样的].</li></ol></blockquote><blockquote><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/rc.png"> </p></blockquote><h2 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a><strong>REPEATABLE READ</strong></h2><blockquote><p>可重复读 - 在同一个事务中,多次读取到的数据是一样的[不关心其他事务做了什么] - mysql的默认的隔离级别</p><p>set session transaction isolation level repeatable read;</p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/ke.png"> </p></blockquote><h2 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h2><blockquote><p>最高的隔离级别 - 效率最低的 - 类似于锁表</p><p>set session transaction isolation level serializable;</p><p>A事务在查看表的时候.其他事务是不能对这张表进行任何的DML[insert,update,delete]操作 .</p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/tx.png"> </p></blockquote><h1 id="不可重复读和幻读区别"><a href="#不可重复读和幻读区别" class="headerlink" title="不可重复读和幻读区别"></a>不可重复读和幻读区别</h1><blockquote><p>set session transaction isolation level READ COMMITTED</p><p><strong>读已提交 - 才可能产生不可重复读.</strong></p></blockquote><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><blockquote><p><strong>针对”update”</strong></p><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/rc.png"> </p></blockquote><blockquote><p>右边的窗口 - A事务,左边的窗口是 - B事务</p><p>A事务在查看某张表[查看一次①]的同时.B事务同时在对<strong>这张表进行update操作</strong>.<strong>并且B事务手动提交了事务</strong></p><p>这个时候A事务在当前事务中[自己的事务还未提交]再次查看这张表.多次读取出现不一样的数据 - 不可重复读.</p></blockquote><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><blockquote><p><strong>针对”insert和delete”</strong></p></blockquote><blockquote><p><img src="/2021/08/13/mysql_DTL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/huan.png"> </p></blockquote><p><code>左边的窗口 - A事务,右边的窗口 - B事务</code></p><blockquote><p>A事务在更新某张表的时候/或者查看这张表,B事务同时正在对这张表进行<strong>insert操作</strong><strong>.并且B事务手动提交了事务</strong></p><p>这个时候A事务继续查看这张表[确认一下自己的更新动作是否完成],这个时候发现表中**”居然好像还有未被更新的数据”**,</p><p>该条数据实际上是B事务已经插入进去的 - 对于A事务就好像产生了幻觉一样.</p></blockquote><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ol><li>事务的四大特性[ACID]</li><li>DTL命令</li><li>解释四个隔离级别,默认的隔离级别是可重复读</li><li>脏读,不可重复读,幻读.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>DDL和DML</title>
    <link href="http://example.com/2021/08/12/mysql-ddl-dml/"/>
    <id>http://example.com/2021/08/12/mysql-ddl-dml/</id>
    <published>2021-08-12T11:02:10.000Z</published>
    <updated>2022-01-11T06:17:54.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><blockquote><p>DDL[Data Definition Language] - 数据定义语言</p><p>涉及到的sql命令如下:</p><ol><li><p><strong>create命令 - 创建</strong></p><p><strong>创建表(table)</strong>,视图(view),用户(user),函数(function),存储过程(procedure),数据库[database],约束(constraints)</p><p>以上构建的都是属于数据库DB的对象/单位 - DB的基本单位是table</p></li><li><p><strong>drop命令 - 删除</strong></p><p><strong>删除表(table),视图(view),用户(user),函数(function),存储过程(procedure),数据库[database]</strong>,约束[constraints]</p><p>但是不能够删除表中具体行记录,是由delete命令</p></li><li><p>alter命令 - 修改 - 了解即可</p><p>修改列名,列的类型,修改约束.列的类型 - 使用情况很少</p></li><li><p>rename to - 修改表名</p></li><li><p>comment - 创建列的时候加上注释</p></li><li><p>truncate - 清空整张表</p></li></ol></blockquote><h1 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h1><blockquote><p><strong>Obejct-Relational-Mapping - 对象关系映射</strong></p><p>需要用到OO思想[第一步找出对象,分析对象的属性,分析对象的功能.考虑对象之间的关系]来进行实体类的设计 - 数据库的设计.</p><p><strong>掌握目标 - 看到实体类-表结构.看到表结构-实体类.</strong></p><p>映射规则:</p><ol><li><p>实体名 - 表名</p></li><li><p>对象标识(id) - 主键(id) -primary key - [特点,非空且唯一]</p></li><li><p>普通属性 - 普通列[推荐俩者的名称保持一致.需要注意的是如果列是多个名称[匈牙利] - 小驼峰]</p></li><li><p>对象之间的关系 - 外键(foreign key) - 表与表之间是通过<strong>外键</strong>来进行关联[进行关联查询的基础]</p><p><strong>通常情况下某张表的外键是指向另外一张表的主键的.</strong></p></li></ol></blockquote><h2 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h2><blockquote><p>分析一个”小米商城”,利用OO思想,找出业务中的关键对象</p><ul><li><p>登录,注册 - “用户User对象” - (id,phone,password,login_time,login_ip)</p></li><li><p>个人中心 - 其中有一块是用来负责展示用户的详情UserInfo</p></li><li><p>产品</p></li><li><p>产品详情</p></li><li><p>购物车 - id,商品id,商品名称,商品单价,num,小计算,总价,备注</p></li><li><p>订单 - 一个用户拥有多个订单,一个订单只能属于一个用户</p></li><li><p>产品分类表</p><p>1:N</p><p>N:N</p></li></ul></blockquote><h3 id="1-1"><a href="#1-1" class="headerlink" title="1:1"></a>1:1</h3><blockquote><p>User和UserInfo: 一个用户匹配一个用户详情,一个用户详情仅属于一个用户</p><p>强调的是平等性 - 表设计中,外键可以出现在任何一方表中.</p><p>原则 - 能用单向关联解决的业务就不要使用双向关联.</p></blockquote><blockquote><ol><li><p>java实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">现阶段的思想 - 实体类中没有外键的概念.</span><br><span class="line">-- 关系具有方向性</span><br><span class="line">-- 单向关联 - 关系的维护仅仅在其中一方存在.</span><br><span class="line">-- 根据第一表进行设计</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">              </span><br><span class="line">  <span class="keyword">private</span> String phone;</span><br><span class="line">              </span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">              </span><br><span class="line">  <span class="comment">//一个用户拥有一个用户详情对象</span></span><br><span class="line">  <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">              </span><br><span class="line">  <span class="comment">//现阶段 - 千万不要写成 - 对象里面是没有外键的概念的</span></span><br><span class="line">  <span class="comment">//private Integer user_info_id;</span></span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">              </span><br><span class="line">  <span class="keyword">private</span> String header;</span><br><span class="line">              </span><br><span class="line">  <span class="keyword">private</span> Gender sex;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">-- 单向关联 - 第二张表</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String phone;</span><br><span class="line">                  </span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String header;</span><br><span class="line">                  </span><br><span class="line">  <span class="keyword">private</span> Gender sex;</span><br><span class="line">                  </span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- ORM思想的精髓 - 如何进行映射以及为什么需要这种思想???</span><br><span class="line">  </span><br><span class="line">未来的操作 - java代码去连接db - 查询user表中所有的数据 -&gt; List&lt;User&gt;</span><br><span class="line">取出每一行数据 - 创建一个user对象[数据在内存中的载体.对象特殊类型的数组]</span><br><span class="line"></span><br><span class="line"><span class="comment">//db中的每一行数据 - java代码来进行获取</span></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">循环体中&#123;</span><br><span class="line">  <span class="comment">//jdbc代码</span></span><br><span class="line">  Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">  String phone = rs.getString(<span class="number">2</span>);</span><br><span class="line">  String passwrod = rs.getString(<span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用对象来封装每一行数据</span></span><br><span class="line">  User user = <span class="keyword">new</span> User(id,phone,password);</span><br><span class="line">  users.add(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未来学习了前端 - 后台list集合中的数据显示到网页上.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 双向关联 - 彼此之间相互维护</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String phone;</span><br><span class="line">                  </span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">                    </span><br><span class="line">  <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String header;</span><br><span class="line">                  </span><br><span class="line">  <span class="keyword">private</span> Gender sex;</span><br><span class="line">                  </span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>表设计</p><p><img src="/2021/08/12/mysql-ddl-dml/onetoone01.png"> </p></li></ol></blockquote><blockquote><p>​        <img src="/2021/08/12/mysql-ddl-dml/onetoone02.png"> </p></blockquote><h3 id="1-N"><a href="#1-N" class="headerlink" title="1:N"></a>1:N</h3><blockquote><p>一个用户对象和购物车对象</p><p>一个用户可以拥有多个购物车对象,但是一个购物车对象只能属于一个用户.</p><p><strong>外键是存储在多的一方</strong></p><p><code>实体类</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-- 单向关联<span class="number">01</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="comment">//普通属性</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一个用户拥有多个购物车</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Cart&gt; carts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cart</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- 单向关联<span class="number">02</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="comment">//普通属性</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cart</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">//一个购物车只能属于一个用户</span></span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 双向关联</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="comment">//普通属性</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一个用户拥有多个购物车</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Cart&gt; carts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cart</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>表结构</code></p><p>User表</p><table><thead><tr><th>id</th><th>phone</th><th>password</th><th></th></tr></thead><tbody><tr><td>1</td><td>110</td><td>123</td><td></td></tr><tr><td>2</td><td>114</td><td>123</td><td></td></tr><tr><td>3</td><td>115</td><td>123</td><td></td></tr></tbody></table><p>购物车Cart表</p><table><thead><tr><th>2</th><th>2</th><th>mi02</th><th>1</th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>mi01</td><td>1</td><td></td><td></td></tr><tr><td>3</td><td>3</td><td>mi03</td><td>2</td><td></td><td></td></tr><tr><td>4</td><td>4</td><td>mi04</td><td>2</td><td></td><td></td></tr><tr><td>id</td><td>product_id</td><td>product_name</td><td>user_id</td><td></td><td></td></tr><tr><td>5</td><td>5</td><td>mi05</td><td>2</td><td></td><td></td></tr></tbody></table></blockquote><h3 id="N-N"><a href="#N-N" class="headerlink" title="N:N"></a>N:N</h3><blockquote><p>需要拆分成俩个一对多</p></blockquote><blockquote><p>一个学生可以选择多门课程,</p><p>一门课程可以被多个学生去选择.</p><p>比如:客户表,商品表,购买表</p><p>一个客户拥有多个商品</p><p>一个商品可以被多个用户购买.</p><p>customer表</p><table><thead><tr><th>id</th><th>cname</th><th></th></tr></thead><tbody><tr><td>1</td><td>admin</td><td></td></tr><tr><td>2</td><td>tom</td><td></td></tr></tbody></table><p>product表</p><table><thead><tr><th>id</th><th>pname</th><th>price</th></tr></thead><tbody><tr><td>1</td><td>mac</td><td>100000</td></tr><tr><td>2</td><td>xiaomi</td><td>8000</td></tr><tr><td>3</td><td>huawei</td><td>8000</td></tr><tr><td>4</td><td>联想</td><td>7000</td></tr></tbody></table></blockquote><blockquote><p>需要建立第三方表,来确定customer表和product表的关系 . <strong>N:N-&gt;拆分成俩个1:N</strong></p><p>purcase表 - 购买表 </p><p>采用的是联合主键[<strong>组合主键]</strong> </p><p><strong>主键-primary key - 非空且唯一.作用:用来确定唯一元组[行]</strong></p><p>所谓的”俩个1:n” - <strong>customer表和purcase表</strong>以及<strong>product表和purcase表</strong></p><ol><li>一个客户拥有多条购买记录[1:N]</li><li>一个产品拥有多条被购买记录[1:N]</li></ol><p>主键列未必是单列[常见的id列] , N:N场景可以采取联合主键,主键列由俩列共同组成**(customer_id,product_id)**</p><p><strong>外键列通常情况是引入另外一张表的主键列.在该表中.外键列有2列</strong></p><p><strong>分别是customer_id 引用了customer表中的id列</strong></p><p><strong>product_id引用了product表中的id列</strong></p><table><thead><tr><th>customer_id</th><th>product_id</th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td></td></tr><tr><td>1</td><td>2</td><td></td></tr><tr><td>2</td><td>1</td><td></td></tr><tr><td>2</td><td>3</td><td></td></tr><tr><td>2</td><td>4</td><td></td></tr></tbody></table></blockquote><blockquote><p>另一种情况关于主键的选择.第三方表[用来维护关系的表],开发的时候,还是推荐给这张自己一个<strong>单独的主键列</strong></p><table><thead><tr><th>id</th><th>customer_id</th><th>product_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>3</td></tr><tr><td>5</td><td>2</td><td>4</td></tr></tbody></table></blockquote><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><blockquote><p>当前表中的外键列自关联到了自己表中的主键列</p></blockquote><blockquote><p>s_emp</p><table><thead><tr><th>id</th><th>first_name</th><th>manager_id[上司id]</th></tr></thead><tbody><tr><td>1</td><td>Carmen</td><td></td></tr><tr><td>2</td><td>Mark</td><td>1</td></tr><tr><td>3</td><td>tom</td><td>1</td></tr><tr><td>4</td><td>admin</td><td>2</td></tr><tr><td>5</td><td>jack</td><td>2</td></tr></tbody></table></blockquote><h2 id="分析评论业务"><a href="#分析评论业务" class="headerlink" title="分析评论业务"></a>分析评论业务</h2><blockquote><p>以”抖音”</p><p>User - Viedo</p><p>关注评论功能.一个用户可以评论多个视频.一个视频可以被多个用户进行评论  - N:N</p></blockquote><blockquote><p>User表</p><table><thead><tr><th>id</th><th>phone</th><th>password</th><th>username</th></tr></thead><tbody><tr><td>1</td><td>110</td><td>123</td><td>吴签</td></tr><tr><td>2</td><td>114</td><td>123</td><td>霍针</td></tr><tr><td>3</td><td>115</td><td>123</td><td>孙岩</td></tr></tbody></table></blockquote><blockquote><p>Viedo表</p><p>一个用户可以发布多个视频,但是一个视频只能由一个用户去发布</p><table><thead><tr><th>id</th><th>视频标题</th><th>视频点赞量</th><th>user_id</th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>吴签</td><td>100万+</td><td>2</td><td></td><td></td></tr><tr><td>2</td><td>霍针</td><td>100万+</td><td>1</td><td></td><td></td></tr><tr><td>3</td><td>杨晓轩</td><td>10+</td><td>3</td><td></td><td></td></tr><tr><td>4</td><td>孙岩</td><td>10+</td><td>3</td><td></td><td></td></tr><tr><td>5</td><td>闫昊</td><td>10+</td><td>3</td><td></td><td></td></tr></tbody></table></blockquote><blockquote><p>评论表 - 重点 体现出谁评论了哪个视频即可.comment</p><p>外键列是可以为空的</p><p>id=5的人并不是直接对视频进行评论的 - 属于第二层评论,他是对id=1的这个人进行评论的</p><p>若comment_id为null,说明这个人是直接对视频进行评论的,属于业务的第一级评论</p><table><thead><tr><th>id</th><th>视频id</th><th>user_id</th><th>评论内容</th><th>comment_pid</th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>3</td><td>很羡慕</td><td></td><td></td></tr><tr><td>2</td><td>1</td><td>4</td><td>渣男</td><td></td><td></td></tr><tr><td>3</td><td>1</td><td>5</td><td>渣男</td><td></td><td></td></tr><tr><td>4</td><td>2</td><td>1</td><td>彼此彼此</td><td></td><td></td></tr><tr><td>5</td><td>2</td><td>5</td><td>你还是人么?你这样认为</td><td>1</td><td></td></tr></tbody></table></blockquote><p><img src="/2021/08/12/mysql-ddl-dml/reply.png"> </p><p>除了评论还有回复….</p><p>第一层 - 属于评论表的数据</p><p>第二层 - 对第一级的评论继续评论</p><p>第三层 - 对第二层及其以后的评论/回复 - 叫做回复.</p><blockquote><p>回复表</p><p>一条评论可以引起多个回复 - reply</p><table><thead><tr><th>id</th><th>comment_id</th><th>content</th><th>replay_id</th><th>user_id</th><th></th></tr></thead><tbody><tr><td>1</td><td>5</td><td>难道你不羡慕吗</td><td></td><td>1</td><td></td></tr><tr><td>2</td><td>5</td><td>我羡慕</td><td>1</td><td>2</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>结构:</p><p>一条视频发出来id=5的视频</p><p>user_id=3: 很羡慕</p><p>​    user_id=5:你还是人么?你这样认为</p><p>​        user_id=1回复了user_id=5:难道你不羡慕吗</p><p>​        user_id=2回复了user_id=1:我羡慕</p></blockquote><h1 id="表设计-三大范式"><a href="#表设计-三大范式" class="headerlink" title="表设计-三大范式"></a>表设计-三大范式</h1><blockquote><p>表设计一定<strong>尽可能去遵守三大方式</strong>.作用:指导db的设计更加合理化,避免数据的冗余.</p><p>笔试题中简答题.</p><ol><li><p><strong>1NF(第一范式):保证列的原子性.列不可再分割.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s_emp(id,name);</span><br><span class="line">但是发现外国的name比较特殊.发现name列是可再分割的.不符合1NF.需要对name进行切割</span><br><span class="line">s_emp(id,first_name,last_name);</span><br><span class="line"></span><br><span class="line">address只需要包含省市区</span><br><span class="line">school(id,name,address);</span><br><span class="line"><span class="number">1</span>  苏州大学  江苏省苏州市工业园区</span><br><span class="line"><span class="number">2</span>  常州大学  江苏省常州市武进区</span><br><span class="line"><span class="number">3</span>  苏州科技学院  江苏省苏州市高新区</span><br><span class="line"></span><br><span class="line">school(id,name,province,city,area);</span><br></pre></td></tr></table></figure></li><li><p><strong>2NF(第二范式):基于1NF,不存在非关键列部分依赖于关键列.非关键列要全部依赖于关键列</strong></p><p><code>关键列 - 主键列;非关键列 - 非主键列</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- student,course表 - 所有的信息合并到一张表了.</span><br><span class="line">--1. student信息以及course信息都会存在数据的冗余性</span><br><span class="line">-- 如何确定主键列[单列,组合形式] - 能够确定唯一的一条行记录 - sid,cid</span><br><span class="line"></span><br><span class="line">-- db设计中,并不是表的数量或者列的数量越少越好的 - 满足三大范式</span><br><span class="line">-- 关键列(sid,cid),非关键列(sname,cname)</span><br><span class="line">-- ①(sid,cid) -&gt; 唯一确定 sname</span><br><span class="line"> 实际上如果关键列中的部分列sid就可以确定了sname的值</span><br><span class="line"> sname只需要由关键列(sid,cid)中的部分列[也就是sid列]就可以确定了.</span><br><span class="line"> 存在了非关键列sname部分依赖于关键列,违背了2NF</span><br><span class="line">-- ②(sid,cid) -&gt; 唯一确定 cname</span><br><span class="line">student_course(sid,sname,cid,cname)</span><br><span class="line">sid  sname  cid  cname</span><br><span class="line">1     tom    1    java</span><br><span class="line">1     tom    2    python</span><br><span class="line">2     admin  1    java</span><br><span class="line">2     admin  3    jack</span><br><span class="line"></span><br><span class="line">为了满足2NF</span><br><span class="line">student(sid,sname);//学生表 sid-&gt;sname</span><br><span class="line">course(cid,cname);//课程表  cid-&gt;cname</span><br><span class="line">sc(sid,cid,score);//选课表  (sid,cid)-&gt; score</span><br></pre></td></tr></table></figure></li><li><p>3NF(第三范式):基于2NF.不存在非关键列传递依赖于关键列.所有的非关键列要直接依赖于关键列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">student(id,sname,uno,uname,address)</span><br><span class="line">1  tom   x1001  苏州大学 江苏省</span><br><span class="line">2  jack  x1002  社会大学 东北省</span><br><span class="line">3  james x1001  苏州大学 江苏省</span><br><span class="line">      </span><br><span class="line">关键列只有id列</span><br><span class="line">①关键列id可以直接确定一个唯一的uno的</span><br><span class="line">②uno又可以直接确定唯一的一个uname</span><br><span class="line">③给定一个学生的id,也是可以确定一个唯一的uname</span><br><span class="line">      </span><br><span class="line">id -&gt; uno -&gt; uname  =&gt; id -&gt; uname</span><br><span class="line">uname是间接被id确定下来的-uname是间接依赖[通过一个uno传递依赖]于关建列id.</span><br><span class="line">违背了3NF,存在了非关键列传递依赖于关键列.</span><br><span class="line">      </span><br><span class="line">所有的非关键列要直接依赖于关键列 - 所有的非关键列应该是直接被关键列来确定的.</span><br><span class="line">      </span><br><span class="line">修改 - 拆分</span><br><span class="line">student(id,sname,uid);//uid就是大学的id</span><br><span class="line">id -&gt; uid(引用university表中的id列)</span><br><span class="line">      </span><br><span class="line">university(id,uno,uname,adress)</span><br><span class="line">uid-&gt;uname</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">  列名 数据类型[(长度)],</span><br><span class="line">  列2  数据类型[(长度)],</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  列  数据类型[(n)]</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- mysql5.7及其以上可以省略了ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">-- 前提是my.ini文件配置好了</span><br><span class="line">-- 指定我们的数据的存储引擎InnoDB,表编码是utf8</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>列的数据类型就是用来限制你将来插入数据到该列的限制.该列是什么类型,就需要插入什么类型的数据</p></blockquote><blockquote><ol><li><p>数字相关的</p><p>a. 整数 - int和bigint</p><p>b. 小数 - float,double[使用最多],decimal</p><p>笔试题中:TINYINT(1个字节)或者smallint(2个字节)</p></li><li><p>字符串相关的 - mysql中字符串是用单引号表示的</p><p>a. char(n)    -  固定长度 - 0-255 bytes[ascill]</p><p>b. varchar(n) - 可变长度 - 0-65535 bytes[unicode的范围]</p><p>c. text - 长文本数据</p><p>笔试题中:mysql中char和varchar的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数字5代表的是该列可以存储的字符串的个数.不是代表字节数</span><br><span class="line">char(5) - 定长字符的意思是即时该列仅仅保存一个字母&#x27;a&#x27;,那么在内存中,char的实际消耗的长度就是5个 - &quot;浪费&quot;</span><br><span class="line">对char类型的列的读写操作效率高于varchar</span><br><span class="line"></span><br><span class="line">varchar(5) - 可变长度[最大可保存的字符串的长度],实际存储了一个字母&#x27;a&#x27;.实际也就只消耗了一个1长度 - &quot;节约了内存&quot; - 按需分配.</span><br><span class="line"></span><br><span class="line">因此,开发中尽可能字符串使用varchar,而不使用char.</span><br></pre></td></tr></table></figure></li><li><p>日期</p><p>a. date -&gt; 即使保存的是年月日时分秒,查询出来的也仅仅只会显示到<strong>年月日</strong></p><p>b. datetime-&gt;年月日时分秒.即使保存的数据仅仅是年月日.但是查询出来的时候,可以显示年月日时分秒</p></li></ol></blockquote><h2 id="建表demo"><a href="#建表demo" class="headerlink" title="建表demo"></a>建表demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">drop table tbl_product;</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(3),</span><br><span class="line">  name varchar(20),</span><br><span class="line">  create_time date,</span><br><span class="line">  price double(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 分析括号中的参数</span><br><span class="line">-- int(3)-并不会影响该列可插入数据的一个范围.范围仍然是int型的范围</span><br><span class="line">-- 为了看出来int(3),修改一下建表语句</span><br><span class="line">-- int(13)想要看出来效果,这个列一定要加上zerofill,不足位数的用0填充</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(13) zerofill,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  create_time date,</span><br><span class="line">  price double(7,2)</span><br><span class="line">);</span><br><span class="line">mysql&gt; insert into tbl_product values(1234,&#x27;tom&#x27;,now(),123.45);</span><br><span class="line">mysql&gt; select * from tbl_product;</span><br><span class="line">+---------------+------+-------------+--------+</span><br><span class="line">| id            | name | create_time | price  |</span><br><span class="line">+---------------+------+-------------+--------+</span><br><span class="line">| 0000000001234 | tom  | 2021-08-19  | 123.45 |</span><br><span class="line">+---------------+------+-------------+--------+</span><br><span class="line">总结:int(n)此处的n不会影响插入到该列的数据的大小.那么n是配合zerofill来进行的.查询的时候,不足n位的数字全部用0填充.</span><br><span class="line"></span><br><span class="line">-- 修改表结构-测试varchar(n)中的n - 个数</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(7),</span><br><span class="line">  name varchar(2),</span><br><span class="line">  create_time date,</span><br><span class="line">  price double(10,2)</span><br><span class="line">);</span><br><span class="line">-- 如果varchar(n)设置成了2,但是插入了&#x27;tom&#x27;,报错</span><br><span class="line">-- ERROR 1406 (22001): Data too long for column &#x27;name&#x27; at row 1</span><br><span class="line">mysql&gt; insert into tbl_product values(1,&#x27;tom&#x27;,now(),123.45);</span><br><span class="line">-- 总结:varchar(n) - 中的n是代表的是字符的个数[一个汉字就是代表一个]</span><br><span class="line"></span><br><span class="line">-- double(m,n)</span><br><span class="line">-- m代表的是总长度,n代表的是精度 - double(7,2)</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(7),</span><br><span class="line">  name varchar(20),</span><br><span class="line">  create_time date,</span><br><span class="line">  price double(7,1)</span><br><span class="line">);</span><br><span class="line">mysql&gt; insert into tbl_product values(2,&#x27;admin&#x27;,&#x27;2021-10-01&#x27;,123456.56789);</span><br><span class="line">-- double(7,2) -&gt; 7就是总的长度,2代表的精度[四舍五入] - 123456.56789 </span><br><span class="line">-- 插入失败了 - Out of range value for column &#x27;price&#x27; at row 1</span><br><span class="line">-- 插入失败的原因是123456.57 -&gt; 这个结果已经超过了总的长度7了.</span><br><span class="line"></span><br><span class="line">-- 修改double(7,1) -&gt; 123456.56789 -&gt; 123456.6 -&gt; 仍然没有超过7这个总的长度的. - 可以被插入进去的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">mysql&gt; desc tables;</span><br><span class="line">-- 查看建表语句</span><br><span class="line">mysql&gt; show create table tbl_product</span><br><span class="line"></span><br><span class="line"> CREATE TABLE `tbl_product` (</span><br><span class="line">   `id` int(7) DEFAULT NULL,</span><br><span class="line">   `name` varchar(20) DEFAULT NULL,</span><br><span class="line">   `create_time` date DEFAULT NULL,</span><br><span class="line">   `price` double(3,2) DEFAULT NULL</span><br><span class="line"> ) ENGINE=InnoDB DEFAULT CHARSET=utf8 </span><br></pre></td></tr></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><blockquote><ol><li><p>在不考虑有外键因素的情况下,可以直接删除表的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE 表名;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="约束constraint"><a href="#约束constraint" class="headerlink" title="约束constraint"></a>约束constraint</h1><blockquote><p>作用:在插入到表中列的数据进行进一步的限制</p></blockquote><h2 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h2><blockquote><ol><li>主键约束[primary key] - 非空且唯一.用来确定唯一的一行记录 - pk</li><li>非空约束[not null] - 非空 - 该列不能为null.必须插入值或者给定一个默认值 - nn</li><li>唯一约束[unique] - 唯一性 - nq</li><li>外键约束[foreign key] - 表与表之间的关系是通过外键来进行维护的.外键列一般是对应某张表的主键列.可以允许为null  - fk</li></ol></blockquote><h3 id="列级添加"><a href="#列级添加" class="headerlink" title="列级添加"></a>列级添加</h3><blockquote><p>优点:比较简单,缺点:不能给约束取名字</p><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">  列名 数据类型[(长度)] [约束类型1],</span><br><span class="line">  列2  数据类型[(长度)] [约束类型2],</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  列  数据类型[(n)]</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">drop table tbl_product;</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(7) primary key comment &#x27;产品的id&#x27;,</span><br><span class="line">  -- 给某列增加俩个约束,用空格隔开</span><br><span class="line">  name varchar(20) not null unique comment &#x27;产品的名称&#x27;,</span><br><span class="line">  -- 如果该列没有插入数据,则使用default给定的默认值</span><br><span class="line">  create_date date not null default now(),</span><br><span class="line">  -- 非空</span><br><span class="line">  price double(7,2) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 死记住</span><br><span class="line">-- 如果上面的create_date使用的是date,给定默认值的时候,是不能直接使用now()函数的.如果想要给定默认值是now(),那么这个列必须是datetime</span><br><span class="line">-- 修改date类型列的默认值</span><br><span class="line">drop table tbl_product;</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(7) primary key comment &#x27;产品的id&#x27;,</span><br><span class="line">  -- 给某列增加俩个约束,用空格隔开</span><br><span class="line">  name varchar(20) not null unique comment &#x27;产品的名称&#x27;,</span><br><span class="line">  -- 如果该列没有插入数据,则使用default给定的默认值</span><br><span class="line">  create_date date not null default &#x27;2019-01-01&#x27;,</span><br><span class="line">  -- 非空</span><br><span class="line">  price double(7,2) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 演示primary key</span><br><span class="line">insert into tbl_product(id,name,price) values(1,&#x27;tom&#x27;,123.567);</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tbl_product;</span><br><span class="line">+----+------+-------------+--------+</span><br><span class="line">| id | name | create_date | price  |</span><br><span class="line">+----+------+-------------+--------+</span><br><span class="line">|  1 | tom  | 2019-01-01  | 123.57 |</span><br><span class="line">+----+------+-------------+--------+</span><br><span class="line"></span><br><span class="line">-- 继续插入一个id也是1的值</span><br><span class="line">insert into tbl_product(id,name,price) values(1,&#x27;admin&#x27;,123.567);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line">-- 违背了primary key主键约束的规则 - 重复了.</span><br><span class="line"></span><br><span class="line">-- not null</span><br><span class="line">-- 没有给price插入值,但是该列存在一个not null非空约束</span><br><span class="line">insert into tbl_product(id,name) values (2,&#x27;tom&#x27;);</span><br><span class="line">-- ERROR 1364 (HY000): Field &#x27;price&#x27; doesn&#x27;t have a default value</span><br><span class="line"></span><br><span class="line">-- unique 唯一性,表中已经存在了一行记录是tom</span><br><span class="line">insert into tbl_product(id,name,price) values(2,&#x27;tom&#x27;,12.3);</span><br><span class="line">-- name字段/列值重复了.</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;tom&#x27; for key &#x27;name&#x27;</span><br></pre></td></tr></table></figure></blockquote><h3 id="表级添加"><a href="#表级添加" class="headerlink" title="表级添加"></a>表级添加</h3><blockquote><p>优势可以给约束命名,记住列级添加是不支持给列取名称的</p><p>not null非空约束以及default仅仅是支持列级添加的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">  列名 数据类型[(长度)],</span><br><span class="line">  列2  数据类型[(长度)],</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  列  数据类型[(n)],</span><br><span class="line">  [constraint 约束名称] 约束类型(列)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">drop table tbl_product;</span><br><span class="line">create table tbl_product(</span><br><span class="line">id int(7) comment &#x27;产品的id&#x27;,</span><br><span class="line">  -- 给某列增加俩个约束,用空格隔开</span><br><span class="line">  name varchar(20) not null comment &#x27;产品的名称&#x27;,</span><br><span class="line">  -- 如果该列没有插入数据,则使用default给定的默认值</span><br><span class="line">  create_date date not null default &#x27;2019-01-01&#x27;,</span><br><span class="line">  -- 非空</span><br><span class="line">  price double(7,2) not null,</span><br><span class="line">  </span><br><span class="line">  -- 给列添加约束</span><br><span class="line">  -- 约束命名 - 表名_列名_约束类型缩写</span><br><span class="line">  constraint tbl_product_id_pk primary key(id),</span><br><span class="line">  constraint tbl_product_name_uq unique(name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into tbl_product values(1,&#x27;tom&#x27;,now(),1223.3);</span><br><span class="line">-- 让name违背了unique约束</span><br><span class="line">insert into tbl_product values(2,&#x27;tom&#x27;,now(),14.56);</span><br><span class="line"></span><br><span class="line">-- for key &#x27;约束名称&#x27;,如果采用的是列添加.系统会默认给定一个约束名称[就是列的名称]</span><br><span class="line">-- 默认的约束名=&#x27;name&#x27;和给定的约束名称&#x27;tbl_product_name_uq&#x27;</span><br><span class="line">-- 自定义的约束名称 - 精确定位错误的位置</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;tom&#x27; for key &#x27;tbl_product_name_uq&#x27;</span><br></pre></td></tr></table></figure></blockquote><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><blockquote><p>foreign key - 简称fk.用来确定表之间的关系的.外键通常是是在多的一方.</p><ol><li><p>1:N或者1:1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">   drop table tbl_user;</span><br><span class="line">   create table tbl_user(</span><br><span class="line">     id int(7) primary key,</span><br><span class="line">     username varchar(20) not null unique</span><br><span class="line">   );</span><br><span class="line">   insert into tbl_user values(1,&#x27;tom&#x27;);</span><br><span class="line">   insert into tbl_user values(2,&#x27;admin&#x27;);</span><br><span class="line">      </span><br><span class="line">   drop table tbl_video;</span><br><span class="line">   create table tbl_video(</span><br><span class="line">   id int(7) primary key,</span><br><span class="line">     title varchar(20),</span><br><span class="line">     likes int(7),</span><br><span class="line">     create_time datetime default now(),</span><br><span class="line">     -- 外键列命名方式 表名_另外一张表的引用列名[主键列]</span><br><span class="line">     -- 外键列的数据类型和长度和你引用的地方保持一致</span><br><span class="line">     tbl_user_id int(7),</span><br><span class="line">     -- 表级添加</span><br><span class="line">     constraint tbl_video_table_user_id_fk foreign key(tbl_user_id) references tbl_user(id)</span><br><span class="line">   );</span><br><span class="line">   -- 一旦创建了约束,插入数据的时候需要注意的是.</span><br><span class="line">   -- 外键列是允许为空的.</span><br><span class="line">   insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);</span><br><span class="line">   insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);</span><br><span class="line">   insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);</span><br><span class="line">      </span><br><span class="line">   -- 注意.既然已经定义了外键的约束.那么插入数据的时候,引用的外键列的值在另外一张表中一定要有行记录的</span><br><span class="line">   -- tbl_user表中是不存在id=3的行记录的</span><br><span class="line">   insert into tbl_video values(3,&#x27;mysql太简单了&#x27;,100,now(),3);</span><br><span class="line">      </span><br><span class="line">   -- 报错</span><br><span class="line">   ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`))</span><br><span class="line"></span><br><span class="line">2. N:N</span><br><span class="line"></span><br><span class="line">   ~~~mysql</span><br><span class="line">   -- 评论表</span><br><span class="line">   -- 一个用户可以对多个视频进行评论</span><br><span class="line">   -- 一个视频可以被多个用户进行评论</span><br><span class="line">   -- 拆分成俩个1:N</span><br><span class="line">      </span><br><span class="line">   -- 组合主键 + 列级添加</span><br><span class="line">   drop table tbl_comment;</span><br><span class="line">   create table tbl_comment(</span><br><span class="line">     -- 组合主键 - 分别给俩个列都去定义了主键列 - 抛出错误ERROR 1068 (42000): Multiple primary key defined</span><br><span class="line">     -- 认为这张表中存在俩个主键,这是不允许的.</span><br><span class="line">   user_id int(7) references tbl_user(id),</span><br><span class="line">     video_id int(7) references tbl_video(id),</span><br><span class="line">     content varchar(50),</span><br><span class="line">     -- 组合主键的正确定义方式</span><br><span class="line">     constraint tbl_comemnt_pk primary key(user_id,video_id),</span><br><span class="line">     -- 外键的列级添加方式</span><br><span class="line">     comment_id int(7) references tbl_comemnt(id)</span><br><span class="line">   );</span><br><span class="line">      </span><br><span class="line">   -- 评论表拥有独立的主键id + 外键约束(表级添加方式)</span><br><span class="line">   drop table tbl_comment;</span><br><span class="line">   create table tbl_comment(</span><br><span class="line">   id int(7) primary key,</span><br><span class="line">     user_id int(7),</span><br><span class="line">     video_id int(7),</span><br><span class="line">     content varchar(50),</span><br><span class="line">     comment_id int(7),</span><br><span class="line">     constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id),</span><br><span class="line">     constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id),</span><br><span class="line">     constraint tbl_comment_id_fk foreign key(comment_id) references tbl_comment(id)</span><br><span class="line">   );</span><br><span class="line">   insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);</span><br><span class="line">   insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="建表补充"><a href="#建表补充" class="headerlink" title="建表补充"></a>建表补充</h2><blockquote><p>由一张表来构建另外一张表</p><ol><li><p>保留原表的表结构+数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名 select语句;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop table video_copy;</span><br><span class="line">-- 保留原表中的所有的列的数据</span><br><span class="line">create table video_copy select * from tbl_video;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table video_copy;</span><br><span class="line">create table video_copy select id,title from tbl_video;</span><br></pre></td></tr></table></figure></li><li><p>保留原表的表结构 + 但是不需要原表的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table video_copy;</span><br><span class="line">create table video_copy select id,title from tbl_video where 1=2;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h1><blockquote><p>insert 插入数据</p><p>delete 删除数据</p><p>update 更新数据</p></blockquote><h2 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h2><blockquote><ol><li><p>语法一:给表中所有的列添加数据</p><p><strong>插入的列值要和建表语句中列顺序以及列的类型以及列的约束高度保持一致.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES(列值1,列值2,列值3,..,列值N)</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li> 语法二:给表中的指定列插入数据</li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2) VALUES(列值1,列值2);</span><br></pre></td></tr></table></figure></blockquote><h2 id="insert-select"><a href="#insert-select" class="headerlink" title="insert+select"></a>insert+select</h2><blockquote><p><strong>insert into 表名 select 语句;</strong></p><p>把查询结果的数据插入到该表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 统计视频的被评论的用户量,并且保存到另外一张表中 video_id,comment_num</span><br><span class="line">drop table comment_aly;</span><br><span class="line">create table comment_aly(</span><br><span class="line"> video_id int(7),</span><br><span class="line">   comment_num int(7)</span><br><span class="line">);</span><br><span class="line">insert into comment_aly select video_id,count(user_id) from tbl_comment group by video_id;</span><br></pre></td></tr></table></figure></blockquote><h1 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto_increment"></a>auto_increment</h1><blockquote><p>mysql中的主键的生成策略 - 自增长策略 - auto_increment[默认的是从1开始,步长为1]</p><p>oracle中的主键的生成策略 - 自增长 - sequence</p><p>应用场景:以后插入的时候[除非是模拟数据],id肯定是后台自动生成 - 唯一性.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table comment_aly;</span><br><span class="line">create table comment_aly(</span><br><span class="line">   id int(7) primary key auto_increment,</span><br><span class="line"> video_id int(7),</span><br><span class="line">   comment_num int(7)</span><br><span class="line">);</span><br><span class="line">insert into comment_aly(video_id,comment_num) select video_id,count(user_id) from tbl_comment group by video_id;</span><br><span class="line"></span><br><span class="line">-- mysql中提供了一个函数last_insert()</span><br><span class="line">-- 查看最后一个id的插入的数据</span><br><span class="line">mysql&gt; select last_insert_id();</span><br><span class="line"></span><br><span class="line">-- 还希望模拟数据的时候接着使用这个自增长</span><br><span class="line">-- 修改自增长的初始值.</span><br><span class="line">mysql&gt; alter table comment_aly auto_increment=6;</span><br><span class="line"></span><br><span class="line">-- 比如数据就是自己插入进去的</span><br><span class="line">insert into comment_aly(video_id,comment_num) values(1,3);</span><br></pre></td></tr></table></figure></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote><p>hive+hbase[分布式数据库] - 大数据</p><p>数据分析业务</p><ol><li><p>数据的获取</p><p>1-1. 爬数据 - 爬虫 - 大公司都有反爬技术[前端的js算法是公开的.万一被破解了.需要重新制定算法]</p><p>爬虫工程师 = 低级的[网站没有反爬技术]和高级的[反爬]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">验证发展历程 - 为了阻止程序模拟用户进行登录的过程.</span><br><span class="line"><span class="number">1.</span> 早期是没有验证码 - 模拟用户登录的程序不断去尝试登录的过程.</span><br><span class="line">   - 网站可能卡死</span><br><span class="line">     </span><br><span class="line"><span class="number">2.</span> 简单的文字或者数字框/弹出框 <span class="number">1</span>+<span class="number">1</span>=?  <span class="number">1</span>+<span class="number">2</span>=?</span><br><span class="line">     </span><br><span class="line"><span class="number">3.</span> 图片验证码 - 图像处理技术-识别出图像中的文字的</span><br><span class="line">   图片中文字尽可能做得非常非常非常模糊,颠倒 - 程序识别不出来.</span><br><span class="line">     </span><br><span class="line"><span class="number">4.</span> 手机验证/滑动块 - 区分程序在操作还是人操作</span><br></pre></td></tr></table></figure><p>1-2. 日志文件 - 比如后台会记录用户的行为轨迹 - 透露出用户的爱好.</p></li></ol></blockquote><blockquote><ol start="2"><li><p>数据的清洗</p><p>日志文件/爬过来的数据 [字段比较多的.需要在有<strong>业务经验</strong>的基础之上]需要对若干个字段进行进一步的筛选工作.</p><p>把关心的和业务相关的字段清洗出来.</p></li><li><p>数据的分析</p><p>找出某个分类的共性的特征.比如代码好的-睡眠时间长,敲代码时间比较长等…</p></li><li><p>数据的挖掘</p><p>金融行业,房地产行业</p><p>根据数据分析的结果来预判下一次的结果 - 建模</p><p>理想状态中 -&gt; y = ax + b;</p><p>现实状态中,不可能得到一个100%的模型的 - 最优模型-最优的解-模型的准确率</p><p>x值,y值 -&gt; y=ax+b</p><p>x     y     -&gt;    z</p><p>8h   3h   - &gt; good</p><p>8.5h 3.5h -&gt; good</p><p>1h 30min -&gt; error</p><p>…</p><p>…</p><p>…</p><p>…</p><p>x和y与z之间的关系</p><p>未来接触到了新生,8.8h,10h -&gt; 可能是good[概率高于error]</p></li></ol></blockquote><h1 id="delete语句"><a href="#delete语句" class="headerlink" title="delete语句"></a>delete语句</h1><blockquote><ol><li><p>清空表 - delete语句不带where</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名;</span><br><span class="line"></span><br><span class="line">delete from video_copy;</span><br></pre></td></tr></table></figure></li><li><p>带条件的删除 - 删除1条,不删除,删除多条</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where语句;</span><br><span class="line">   </span><br><span class="line">-- 删除video_copy表中id=2的行记录</span><br><span class="line">delete from video_copy where id=2;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="update语句"><a href="#update语句" class="headerlink" title="update语句"></a>update语句</h1><blockquote><ol><li><p>更新的整张表的数据 - 不带where语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">-- 更新所有的行的单列</span><br><span class="line">update 表名 set 列名=新的列值;</span><br><span class="line"></span><br><span class="line">-- 更新所有的行的多列.</span><br><span class="line">update 表名 set 列1=新的列值1,列2=新的列值2,列n=新的列值n;</span><br><span class="line"></span><br><span class="line">-- 比如更新video_copy表中的likes</span><br><span class="line">update video_copy set likes=likes*1.1;</span><br><span class="line"></span><br><span class="line">-- 比如更新video_copy表中的likes和title</span><br><span class="line">update video_copy set likes=200,title=&#x27;java无敌&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>更新指定条件的行记录 - where语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">更新id=2的title</span><br><span class="line">update video_copy set title=&#x27;python不错&#x27; where id=2;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="总结约束注意点"><a href="#总结约束注意点" class="headerlink" title="总结约束注意点"></a>总结约束注意点</h1><blockquote><p><strong>列添加了约束,需要注意的地方有哪些</strong></p><ol><li> 先删除多的一方表,再删除的一的一方的表</li><li>删除行记录的时候,需要先把这个行记录在其他表中被引用的行记录要全部删除之后,才能删除自己.</li><li>创建表的时候,应该先创建一的一方,然后创建多的一方</li></ol></blockquote><h2 id="删除表-1"><a href="#删除表-1" class="headerlink" title="删除表"></a>删除表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">-- 删除表不是随意删除的 - 前提是创建了外键约束</span><br><span class="line">--  先删除多的一方表,再删除的一的一方的表</span><br><span class="line">drop table tbl_comment;</span><br><span class="line">drop table tbl_user;</span><br><span class="line">drop table tbl_video;</span><br><span class="line"></span><br><span class="line">-- 用户表</span><br><span class="line">create table tbl_user(</span><br><span class="line">  id int(7) primary key,</span><br><span class="line">  username varchar(20) not null unique</span><br><span class="line">);</span><br><span class="line">insert into tbl_user values(1,&#x27;tom&#x27;);</span><br><span class="line">insert into tbl_user values(2,&#x27;admin&#x27;);</span><br><span class="line"></span><br><span class="line">-- 视频表</span><br><span class="line">create table tbl_video(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  title varchar(20),</span><br><span class="line">  likes int(7),</span><br><span class="line">  create_time datetime default now(),</span><br><span class="line">  -- 外键列命名方式 表名_另外一张表的引用列名[主键列]</span><br><span class="line">  -- 外键列的数据类型和长度和你引用的地方保持一致</span><br><span class="line">  tbl_user_id int(7),</span><br><span class="line">  -- 表级添加</span><br><span class="line">  constraint tbl_video_table_user_id_fk foreign key(tbl_user_id) references tbl_user(id)</span><br><span class="line">);</span><br><span class="line">-- 一旦创建了约束,插入数据的时候需要注意的是.</span><br><span class="line">-- 外键列是允许为空的.</span><br><span class="line">insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);</span><br><span class="line">insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);</span><br><span class="line">insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);</span><br><span class="line"></span><br><span class="line">-- 评论表</span><br><span class="line">create table tbl_comment(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  user_id int(7),</span><br><span class="line">  video_id int(7),</span><br><span class="line">  content varchar(50),</span><br><span class="line">  comment_id int(7),</span><br><span class="line">  constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id),</span><br><span class="line">  constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id),</span><br><span class="line">  constraint tbl_comment_id_fk foreign key(comment_id) references tbl_comment(id)</span><br><span class="line">);</span><br><span class="line">insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);</span><br><span class="line">insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1);</span><br></pre></td></tr></table></figure><p><code>分析删除表的顺序</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 如果删除的是tbl_user或者tbl_video都会报错</span><br><span class="line">-- 报错的原因就是由外键约束存在导致的</span><br><span class="line"></span><br><span class="line">mysql&gt; drop table tbl_user;</span><br><span class="line">ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails</span><br><span class="line">mysql&gt; drop table tbl_video;</span><br><span class="line">ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails</span><br><span class="line"></span><br><span class="line">-- 应该要先删除子记录[外键所在的表中的记录],然后再删除父记录 - 先删除多的一方表,再删除的一的一方的表</span><br><span class="line">-- 多的一方的外键引用的是一的一方的主键.</span><br></pre></td></tr></table></figure><h2 id="删除行记录"><a href="#删除行记录" class="headerlink" title="删除行记录"></a>删除行记录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- id=2的用户是在tbl_comment中存在一条行记录的,它是被引用了.</span><br><span class="line">mysql&gt; delete from tbl_user where id=2;</span><br><span class="line">ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_comment`, CONSTRAINT `tbl_comment_user_id_fk` FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`))</span><br><span class="line"></span><br><span class="line">-- id=2的所有的评论的全部删除[删除子记录],然后再去删除id=2的用户</span><br><span class="line">mysql&gt; delete from tbl_comment where user_id=2;</span><br><span class="line"></span><br><span class="line">-- 然后才能去删除id=2的用户,已经把用户id=2这个用户的所有的评论全部删除了</span><br><span class="line">mysql&gt; delete from tbl_user where id=2;</span><br><span class="line"></span><br><span class="line">ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`))</span><br><span class="line"></span><br><span class="line">id=2的用户又发布了一条视频,它也在tbl_video表中被引用了.</span><br><span class="line">mysql&gt; delete from tbl_video where tbl_user_id=2;</span><br><span class="line"></span><br><span class="line">-- 等把id=2的用户的所有评论信息以及发布的视频全部删除完毕之后,才可以删除自己</span><br><span class="line">mysql&gt; delete from tbl_user where id=2;</span><br></pre></td></tr></table></figure><h2 id="约束的缺点"><a href="#约束的缺点" class="headerlink" title="约束的缺点"></a>约束的缺点</h2><blockquote><p>外键约束 - 保证数据的完整性和一致性.缺点 - 表之间的关系越强烈[手动创建了约束条件] - 表之间的耦合越高.</p><p>在下周DB设计 - <strong>不要手动创建约束</strong> - 弱化表之间的关系 - <strong>“表的关系 - 心中”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">驰星CRM系统 - 学生信息,项目经理信息</span><br><span class="line"></span><br><span class="line">-- 假设一个项目经理可以教多个学生</span><br><span class="line">-- dev_id是外键列</span><br><span class="line">student(id,sname,school,dev_id);</span><br><span class="line">1 杨晓轩 文正养老学院 2</span><br><span class="line">2 闫昊   八一农垦    1</span><br><span class="line">3 刘静   八一农垦    2</span><br><span class="line"></span><br><span class="line">dev(id,dev_name,age);</span><br><span class="line">1 success 18</span><br><span class="line">2 james  45</span><br><span class="line">3 小强    19</span><br><span class="line"></span><br><span class="line">如果建表的时候</span><br><span class="line">create table student(</span><br><span class="line">//...</span><br><span class="line">  </span><br><span class="line">  foreign key(dv_id) references dev(id);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 导致的后果,不能随意删除项目经理.项目经理只要有学生信息.就不能删除项目经理.</span><br><span class="line"></span><br><span class="line">-- 现实生活中 - success上台了,james开除了...</span><br><span class="line">mysql&gt; delete from dev where id=2;//删除失败了.因为james在student表中有子记录</span><br><span class="line">-- 要想删除james,需要删除他所有的学生.实际的业务 - 肯定不允许我去删除&quot;宝贵的学生信息&quot;</span><br><span class="line"></span><br><span class="line">-- 目标 - 1. 成功删除项目经理</span><br><span class="line">--       2. 知道学生曾经是哪个老师带过的.</span><br><span class="line"></span><br><span class="line">-- 因此,在建表的时候,其实是允许数据的冗余性的.</span><br><span class="line">drop table t_student;</span><br><span class="line">drop table dev;</span><br><span class="line">create table dev(</span><br><span class="line">id int(7) primary key auto_increment,</span><br><span class="line">  dev_name varchar(20),</span><br><span class="line">  age int(3)</span><br><span class="line">);</span><br><span class="line">insert into dev values(1,&#x27;success&#x27;,18);</span><br><span class="line">insert into dev values(2,&#x27;james&#x27;,45);</span><br><span class="line"></span><br><span class="line">create table t_student(</span><br><span class="line">id int(7) primary key auto_increment,</span><br><span class="line">  sname varchar(20),</span><br><span class="line">  school varchar(20),</span><br><span class="line">  -- 此处没有进行约束的添加 - &quot;关系在心中即可&quot;</span><br><span class="line">  dev_id int(7),</span><br><span class="line">  -- 数据的冗余 - 防止项目经理的记录被删除</span><br><span class="line">  dev_name varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into t_student values(1,&#x27;杨晓轩&#x27;,&#x27;文正养老学院&#x27;,2,&#x27;james&#x27;);</span><br><span class="line">insert into t_student values(2,&#x27;闫昊&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);</span><br><span class="line">insert into t_student values(3,&#x27;刘静&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);</span><br><span class="line"></span><br><span class="line">-- 虽然没有给dev_id列创建约束,业务分析可以确定该列就是用来&quot;维护俩表之间的关系的&quot;</span><br><span class="line">-- 查询学生的姓名以及项目经理的姓名以及年龄</span><br><span class="line">mysql&gt; select s.sname,d.dev_name,d.age from t_student s join dev d on s.dev_id=d.id;</span><br><span class="line"></span><br><span class="line">-- 开除james,没有约束,可以直接删除</span><br><span class="line">mysql&gt; delete from dev where id=2;</span><br></pre></td></tr></table></figure></blockquote><h1 id="物理删除和逻辑删除"><a href="#物理删除和逻辑删除" class="headerlink" title="物理删除和逻辑删除"></a>物理删除和逻辑删除</h1><blockquote><ol><li><p>物理删除就是真正意义上的delete语句</p></li><li><p><strong>逻辑删除 - 建议 - 比较安全.</strong></p><p>因为数据是不能随意删除的.数据是需要后台进行数据分析的.<strong>用户的端的删除大部分都是逻辑删除.</strong></p><p>实际上就是每张表都会增加逻辑列.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drop table xx_del;</span><br><span class="line">create table xx_del(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  status int(7)</span><br><span class="line">);</span><br><span class="line">insert into xx_del values(1,&#x27;tom&#x27;,0);</span><br><span class="line">insert into xx_del values(2,&#x27;admin&#x27;,0);</span><br><span class="line">   </span><br><span class="line">-- 首页 - 加载xx_del表中所有的信息</span><br><span class="line">-- 查询逻辑列 - 把status=0的行记录全部加载</span><br><span class="line">List&lt;XX&gt; list = &quot;select * from xx_del where status=0&quot;;</span><br><span class="line">   </span><br><span class="line">-- 删除按钮 - 删除 - 实际上是逻辑删 - 并不会执行delete语句,执行的是update语句</span><br><span class="line">update xx_del set status=1 where id=1;</span><br><span class="line">   </span><br><span class="line">-- 再去根据status=0去加载,给用户端的感觉好像是这条记录被删除了.</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>DQL</title>
    <link href="http://example.com/2021/08/11/mysql_DQL_%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2021/08/11/mysql_DQL_%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-08-11T11:02:10.000Z</published>
    <updated>2022-01-11T06:18:12.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><blockquote><p><strong>数据库(Database - 简称DB)</strong></p></blockquote><blockquote><p>数据按照一定的数据结构来进行组织,存储和管理的仓库.</p><p>学习的数据库mysql - 目前最主流的<strong>关系型数据库</strong>[免费的.现在属于oracle公司的]</p><p>安装的版本&gt;=5.7.x -&gt; 发展[mysql5.5.x,mysql5.6.x,<strong>mysql.5.7.x,mysql8.x</strong>] - 版本不一样,语法存在差异.</p></blockquote><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><blockquote><p>SQL - Structured Query Language - 结构化查询语言.</p><p>作用:</p><ol><li>脚本文件 - 以.sql为脚本的文件</li><li>我们本质上就是通过sql语法/命令来操作我们的DB</li></ol></blockquote><h2 id="按照功能来进行分类"><a href="#按照功能来进行分类" class="headerlink" title="按照功能来进行分类"></a>按照功能来进行分类</h2><blockquote><ol><li><p>DQL(Data Query Language) - 数据查询语言 - 也是整个sql的核心 - 最难的</p><p>select</p></li><li><p>DML(Data Manipulation Language) - 数据操纵语言</p><p>insert update delete</p></li><li><p>DDL(Data definition Language) - 数据定义语言</p><p><strong>create</strong> alter drop</p></li><li><p>DCL(Data Control Language) - 数据控制语言</p><p>grant[授权],revoke[取消权限]</p></li><li><p>DTL(Data Transaction Language) - 数据事务语言</p><p>commit savepoint rollback</p></li></ol></blockquote><h2 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h2><blockquote><p>mysql中的script文件 - 是以.sql为后缀的文件.</p></blockquote><blockquote><p>mysql - 数据库-<strong>由若干张表组成的仓库</strong>,数据是存储在一张二维**表[关系]**中的</p><p>如果一个数据库存储数据的格式是一个行和列组成表 - <strong>关系[表格]型数据库</strong></p></blockquote><blockquote><ol><li><strong>生成若干张表</strong></li><li><strong>表中插入若干条数据</strong></li></ol></blockquote><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>##登录mysql</p><blockquote><p>打开cmd</p><p>mysql -u用户名 -p密码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admindeMacBook-Pro:~ admin$ mysql -uroot -proot</span><br></pre></td></tr></table></figure></blockquote><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><blockquote><p>MYSQL就是通过仓库的形式来管理我们的数据的.</p><p>语法:CREATE DATABASE 仓库名;  </p><p>sql的语法大小写是不敏感的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database j03s;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></blockquote><h2 id="查看所有的仓库"><a href="#查看所有的仓库" class="headerlink" title="查看所有的仓库"></a>查看所有的仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| j03s               |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><h2 id="使用仓库"><a href="#使用仓库" class="headerlink" title="使用仓库"></a>使用仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use j03s</span><br></pre></td></tr></table></figure><h2 id="查看所有的表"><a href="#查看所有的表" class="headerlink" title="查看所有的表"></a>查看所有的表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br></pre></td></tr></table></figure><h2 id="导入脚本"><a href="#导入脚本" class="headerlink" title="导入脚本"></a>导入脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source sql脚本文件的绝对路径;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source /Users/admin/Desktop/j03s_mysql_all/教学脚本/mysql_cn.sql;</span><br></pre></td></tr></table></figure><p><code>该脚本文件中的表</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| Tables_in_j03s |</span><br><span class="line">+----------------+</span><br><span class="line">| s_customer     |</span><br><span class="line">| s_dept         |</span><br><span class="line">| s_emp          |</span><br><span class="line">| s_ord          |</span><br><span class="line">| s_region       |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><p><code>继续导入 - 面试中常常使用到的一个脚本</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| Tables_in_j03s |</span><br><span class="line">+----------------+</span><br><span class="line">| course         |</span><br><span class="line">| sc             |</span><br><span class="line">| student        |</span><br><span class="line">| teacher        |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><h2 id="确认数据的编码"><a href="#确认数据的编码" class="headerlink" title="确认数据的编码"></a>确认数据的编码</h2><blockquote><p>建议修改编码之后,建议重启mysql服务</p><p>右击计算机 - 管理 - 服务 - 服务和应用程序 - 右边的窗口 - mysql - 右击重启</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;char%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                                     |</span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                                      |</span><br><span class="line">| character_set_connection | utf8                                                      |</span><br><span class="line">| character_set_database   | utf8                                                      |</span><br><span class="line">| character_set_filesystem | binary                                                    |</span><br><span class="line">| character_set_results    | utf8                                                      |</span><br><span class="line">| character_set_server     | utf8                                                      |</span><br><span class="line">| character_set_system     | utf8                                                      |</span><br><span class="line">| character_sets_dir       | /usr/local/mysql-5.7.28-macos10.14-x86_64/share/charsets/ |</span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要对每一项进行单独的设置</span><br><span class="line">mysql&gt;set character_set_client=utf8;</span><br></pre></td></tr></table></figure><h3 id="mysql插入中文乱码"><a href="#mysql插入中文乱码" class="headerlink" title="mysql插入中文乱码"></a>mysql插入中文乱码</h3><blockquote><ol><li><p>检测上面的编码</p></li><li><p><strong>my.ini文件在哪里</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br></pre></td></tr></table></figure></li><li><p>本身自己的cmd的编码</p></li><li><p>如果还有问题,卸载重来.</p></li></ol></blockquote><h1 id="简单Query"><a href="#简单Query" class="headerlink" title="简单Query"></a>简单Query</h1><blockquote><p>属于DQL命令 - select命令</p><p>query语法</p><p>查询的本质</p><ol><li>查什么</li><li>到哪里查[必须先使用数据库,然后才能查看这个库下的表]</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询整张表的某些列</span><br><span class="line">SELECT 列1,列2,列n FROM 表名;</span><br><span class="line">-- 查询整张表中的所有列,*代表所有的列</span><br><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure></blockquote><h2 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">mysql&gt; desc student;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10)     | YES  |     | NULL    |       |</span><br><span class="line">| sname | varchar(10) | YES  |     | NULL    |       |</span><br><span class="line">| age   | datetime    | YES  |     | NULL    |       |</span><br><span class="line">| sex   | varchar(10) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><blockquote><ol><li><p>查询student表中的姓名sname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sname from student;</span><br></pre></td></tr></table></figure></li><li><p>查询student表中的学生信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br></pre></td></tr></table></figure></li><li><p>查询s_emp员工表中的first_name和last_name</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,last_name from s_emp;</span><br></pre></td></tr></table></figure></li><li><p>查询客户[s_customer]的姓名以及客户的电话号码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,phone from s_customer;</span><br></pre></td></tr></table></figure></li><li><p>查询s_emp中的title列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select title from s_emp;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="6"><li><p>排重关键字distinct 列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct title from s_emp;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><blockquote><p>query-conditional语法</p><ol><li><p>如果查询语句后面不加where条件,查询的是整张表中的数据</p></li><li><p>需要对数据进行筛选,需要使用条件查询</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询满足条件表达式的数据</span><br><span class="line">SELECT 列1,列2,列n</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote><ol><li><p>比较运算符</p><blockquote><p> =,&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;</p></blockquote></li><li><p>其他运算符</p><blockquote><p>2-1. in(集合列表)</p><p>2-2. not in(集合列表)</p><p>2-3. between … and … 在 … 和 …区间 - 是一个闭区间</p></blockquote></li><li><p>is null - 判断某列是否为空,注意判断是否为空,不能使用=</p></li><li><p>is not null - 判断某列是否不为空,不能使用!=</p></li></ol></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><blockquote><ol><li>not</li><li>and - 用来连接多个条件的,多个条件同时为true,才能返回结果</li><li>or  - 用来连接多个条件的,只要有一个条件成立,就会返回结果.</li></ol></blockquote><h2 id="条件查询练习"><a href="#条件查询练习" class="headerlink" title="条件查询练习"></a>条件查询练习</h2><blockquote><ol><li><p>查询工资高于1200的员工的信息[id,first_name,salary]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,first_name,salary from s_emp where salary&gt;1200;</span><br></pre></td></tr></table></figure></li><li><p>把部门编号为41,42,43的员工信息查询出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 写法使用in关键字 - db设计,表列命名不能使用mysql关键字</span><br><span class="line">mysql&gt; select id,first_name,dept_id from s_emp where dept_id in(41,42,43);</span><br><span class="line"></span><br><span class="line">-- 写法 - 使用or逻辑运算符</span><br><span class="line">mysql&gt; select id,first_name,dept_id from s_emp where dept_id=41 or dept_id=42 or dept_id=43;</span><br></pre></td></tr></table></figure></li><li><p>查询工资在1200~1450之间的员工的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- between .. and .. 闭区间</span><br><span class="line">mysql&gt; select id,first_name,salary from s_emp where salary between 1200 and 1450;</span><br><span class="line"></span><br><span class="line">-- and逻辑运算符</span><br><span class="line">mysql&gt; select id,first_name,salary from s_emp where salary&gt;=1200 and salary&lt;=1450;</span><br></pre></td></tr></table></figure></li><li><p>查询title[职称]为Stock Clerk的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 注意title列的数据类型varchar(25) - 字符串</span><br><span class="line">-- mysql中使用单引号来表示字符串</span><br><span class="line">mysql&gt; select id,first_name,title from s_emp where title=&#x27;Stock Clerk&#x27;;</span><br><span class="line"></span><br><span class="line">-- 具体存储的值全部换成小写 - 也是可以查询出来的.</span><br><span class="line">-- mysql5.7.x版本不仅仅是sql语法忽略了大小写,表中查询也是忽略的 - 但是不建议这样做.</span><br><span class="line">mysql&gt; select id,first_name,title from s_emp where title=&#x27;stock clerk&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>查询有提成[commission_pct]的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,first_name,commission_pct from s_emp where commission_pct is not null;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="列别名和列的计算"><a href="#列别名和列的计算" class="headerlink" title="列别名和列的计算"></a>列别名和列的计算</h1><blockquote><ol><li><p>我们可以给列重新命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 语法一:列1 列别名1 - 推荐使用的语法</span><br><span class="line">mysql&gt; SELECT 列1 列别名1,列2 列别名2 FROM 表名 [WHERE条件查询];</span><br><span class="line"></span><br><span class="line">mysql&gt; select id 编号,first_name 名字,salary 工资 from s_emp;</span><br><span class="line"></span><br><span class="line">-- 语法二: 列1 as 列别名1 - 不推荐使用</span><br><span class="line">mysql&gt;select id as 编号,first_name as 名字,salary as 工资 from s_emp;</span><br><span class="line"></span><br><span class="line">-- 语法三: mysql中可以使用双引号来保持/包裹格式</span><br><span class="line">-- 列1 &quot;列别名1&quot;</span><br><span class="line">mysql&gt; select id &quot;编号&quot;,first_name &quot;名字&quot;,salary &quot;工资&quot; from s_emp;</span><br><span class="line"></span><br><span class="line">-- 需求:希望列别名每个汉字间距一点[空一格]</span><br><span class="line">mysql&gt; select id &quot;编 号&quot;,first_name &quot;名 字&quot;,salary &quot;工 资&quot; from s_emp;</span><br></pre></td></tr></table></figure></li><li><p>mysql中的列支持计算的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工的年薪</span><br><span class="line">mysql&gt; select first_name,salary*12 年薪 from s_emp;</span><br></pre></td></tr></table></figure><p><code>练习</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工的年薪,但是要包括提成</span><br><span class="line">mysql&gt; select first_name,salary*12*(1+commission_pct/100) 年薪 from s_emp;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>以上的查询结果 - 有提成的员工全部查询成功,没有提成的员工,计算年薪都是null</p><p><em><strong>在mysql中null值直接进行计算,结果还是null值</strong></em>,因此一般需要对null值进行处理,如果是数字列为null.需要作为0来进行处理</p><p>mysql中内置了很多函数 - <strong>空值置换函数 - coalesce(m,n)</strong> 计算规则类似于java中的三元操作符<strong>m==null?n:m</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,salary*12*(1+coalesce(commission_pct,0)/100) 年薪 from s_emp;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h1><blockquote><p>使用like关键字</p><ol><li>% - 占位符 - 代表任意<strong>多个</strong>任意字符</li><li>_ 占位符 - 代表任意<strong>单个</strong>任意字符</li></ol></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li><p>比如查询teacher表中所有的李姓老师</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher where tname like &#x27;李%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>比如查询first_name第三个字母是e的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   mysql&gt; select first_name from s_emp where first_name like &#x27;__e%&#x27;;</span><br><span class="line"></span><br><span class="line">3. 查询职称title中包含VP的并且工资高于1200的员工信息</span><br><span class="line"></span><br><span class="line">   ~~~mysql</span><br><span class="line">   mysql&gt; select first_name,title,salary from s_emp where title like &#x27;%VP%&#x27; and salary&gt;1200;</span><br></pre></td></tr></table></figure></li><li><p>查询first_name以M开头的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name from s_emp where first_name like &#x27;M%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>查询first_name中不包含字母n的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   mysql&gt; select first_name from s_emp where first_name not like &#x27;%n%&#x27;;</span><br><span class="line"></span><br><span class="line">6. 找出非41,42,43部门的员工</span><br><span class="line"></span><br><span class="line">   ~~~mysql</span><br><span class="line">   mysql&gt; select first_name,dept_id from s_emp where dept_id not in(41,42,43);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><blockquote><p><strong>了解即可</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update s_emp set first_name=&#x27;Car_men&#x27; where id=1;</span><br><span class="line">mysql&gt; update s_emp set first_name=&#x27;Ma_rk&#x27; where id=4;</span><br></pre></td></tr></table></figure><p>需求 - 查询first_name中包含_的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name from s_emp where first_name like &#x27;%_%&#x27;;</span><br><span class="line"></span><br><span class="line">默认的转义字符</span><br><span class="line">mysql&gt; select first_name from s_emp where first_name like &#x27;%\_%&#x27;;</span><br><span class="line"></span><br><span class="line">自定义转义字符</span><br><span class="line">mysql&gt; select first_name from s_emp where first_name like &#x27;%?_%&#x27; escape &#x27;?&#x27;;</span><br></pre></td></tr></table></figure></blockquote><h1 id="列的拼接功能"><a href="#列的拼接功能" class="headerlink" title="列的拼接功能"></a>列的拼接功能</h1><blockquote><p>s_emp表中first_name[名]和last_name[姓]</p><p><strong>db设计满足三大范式.第一范式保证列的原子性 - 列不可再分割.</strong></p><p>姓名 -姓一列+名一列</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;-- 拼接的过程也使用到了内置函数concat(...) - 可变长列表</span><br><span class="line">&gt;mysql&gt; select concat(last_name,&#x27;  &#x27;,first_name) 姓名 from s_emp;</span><br></pre></td></tr></table></figure></blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 排序的语法</span><br><span class="line">SELECT 列1,列2,列n</span><br><span class="line">FROM 表名</span><br><span class="line">[WHERE 条件表达式]</span><br><span class="line">[ORDER BY 列名] [asc | desc];</span><br></pre></td></tr></table></figure></blockquote><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li><p>查看员工的信息,找出工资大于1200的,并且根据salary来升序</p><p><code>order by + 列的名称</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- asc可以省略不写</span><br><span class="line">mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by salary;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 如果是降序的,desc不能省略的</span><br><span class="line">mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by salary desc;</span><br></pre></td></tr></table></figure></li><li><p><code>order by + 列的序号</code> - 推荐使用的.</p><p>列的序号是查询语句中的列的序号,列的序号是从1开始的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by 2;</span><br></pre></td></tr></table></figure></li><li><p><code>order by + 列别名</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,salary _sal from s_emp where salary&gt;1200 order by _sal desc;</span><br></pre></td></tr></table></figure></li><li><p>查看员工的信息,找出工资大于1200的,并且根据salary来降序.如果salary一样,那么继续根据first_name来进行一个升序.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by 2 desc,1;</span><br></pre></td></tr></table></figure></li><li><p>找出年薪高于21000的员工的信息[包括提成的],并且根据年薪降序排.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp where salary*12*(1+coalesce(commission_pct,0)/100)&gt;21000 order by 2 desc;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="6"><li><p>为高级查询作个铺垫 - 子查询语法 - 精髓 - 就是把查询语句得到的表看成是真正的”临时表”.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 分解  - &quot;临时表&quot;</span><br><span class="line">select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 整合</span><br><span class="line">-- select * from (另外一个查询语句) 表别名</span><br><span class="line">select * from (select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp) core_ where year_salary&gt;21000 order by 2 desc;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="高级查询-part01-最关键"><a href="#高级查询-part01-最关键" class="headerlink" title="高级查询-part01 - 最关键"></a>高级查询-part01 - 最关键</h1><blockquote><p>多表查询,表和表之间的关系 - 通过<strong>外键列</strong>来维护的.</p><p>RDBMS专业术语</p><ol><li>主键列 </li><li><strong>外键列</strong> - 确定好外键列是进行多表查询的前提,通常外键列是交给多的一方进行维护的</li></ol></blockquote><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><h3 id="传统的写法"><a href="#传统的写法" class="headerlink" title="传统的写法"></a>传统的写法</h3><blockquote><p><em><strong>如果没有直接关系的俩张表,它们是不能够直接进行一个join操作.</strong></em></p></blockquote><blockquote><ol><li><p>错误的写法❌  - 笛卡尔积</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工(s_emp)的id,first_name以及这个员工所在的部门(s_dept)的id以及部门的名称</span><br><span class="line">mysql&gt; select id,first_name,id,name from s_emp,s_dept;</span><br><span class="line">               </span><br><span class="line">ERROR 1052 (23000): Column &#x27;id&#x27; in field list is ambiguous</span><br><span class="line">               </span><br><span class="line">如果查询的结果中出现多个表中同名的列,请你给表取别名,通过表别名.列名</span><br><span class="line">mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d;</span><br><span class="line">               </span><br><span class="line">总共出现了300条 = 25 * 12</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>进行筛选 - 去除错误的笛卡尔积</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d where e.dept_id = d.id;</span><br></pre></td></tr></table></figure></li><li><p>练习</p><p>3-1. 找出外键列</p><p>3-2. 去除笛卡尔积</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 找出区域在&#x27;Asia&#x27;的所有的员工信息</span><br><span class="line">mysql&gt; select e.first_name,r.name from s_emp e,s_dept d,s_region r</span><br><span class="line">       where r.name=&#x27;Asia&#x27; and r.id = d.region_id and e.dept_id=d.id;</span><br><span class="line">               </span><br><span class="line">-- 缺点 - 如果表的数量一旦增多,发现哪些表和哪些之间是否有直接的关系.我们体验不会太好</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>查看学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况</p><p><em><strong>student,course,teacher,sc</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select s.sname,c.cname,t.tname,_sc.score from student s,course c,teacher t,sc _sc where _sc.sid = s.id and _sc.cid = c.id and c.tid = t.id;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="join-on写法"><a href="#join-on写法" class="headerlink" title="join+on写法"></a>join+on写法</h3><blockquote><p><strong>表 join 表 on 一的一方的主键 = 多的一方的外键.</strong></p><p>on的目的不是为了进行条件筛选 - 目的去除笛卡尔积</p><p><strong>只要具有直接关系的俩张表才能够使用join进行连接</strong></p></blockquote><blockquote><ol><li><p><strong>内连接 - 默认的inner join,但是inner可以省略不写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询部门id为31的部门名称以及该部门下的员工的名字和薪水</span><br><span class="line">mysql&gt; select d.id,d.name,e.first_name,e.salary from s_emp e join s_dept d on e.dept_id = d.id where d.id=31;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 找出区域在&#x27;Asia&#x27;的所有的员工信息</span><br><span class="line">mysql&gt; select r.name,e.first_name from s_region r join s_dept d on r.id = d.region_id join s_emp e on d.id = e.dept_id where r.name=&#x27;Asia&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 李老师的授课情况信息,包括教的学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况</span><br><span class="line">mysql&gt; select t.tname,s.sname,c.cname,_sc.score from student s join sc _sc on s.id = _sc.sid join course c on c.id = _sc.cid join teacher t on t.id = c.tid where t.tname like &#x27;李%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看顾客的id,姓名以及该顾客拥有的订单信息[订单所有列]</span><br><span class="line">mysql&gt; select c.id,c.name,o.* from s_customer c join s_ord o on c.id = o.customer_id;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有区域,以及这个区域上的部门信息</span><br><span class="line">mysql&gt; select r.name,d.* from s_region r join s_dept d on d.region_id = r.id; </span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h2><blockquote><ol><li><p>内连接 - inner join</p><p><strong>查看顾客的id,姓名以及该顾客拥有的订单id</strong> - 拥有订单的客户才能够被查询出来 - inner join</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;</span><br><span class="line">-- 总共查询得到16条数据</span><br><span class="line"></span><br><span class="line">-- inner join - 结果中少掉了207和215俩个客户 - 因为查看订单表s_ord,发现这俩个人就没有订单信息</span><br><span class="line">-- inner join - 内连接的写法,A表 join B表 - 如果A表中的记录在B表中不存在.那么关联查询之后.这个在B表中不存在的A表中的</span><br><span class="line">-- 这个记录也同样不会被关联查询出来.</span><br><span class="line">mysql&gt; select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;</span><br><span class="line">+-----+----------------------------+-----+</span><br><span class="line">| id  | name                       | oid |</span><br><span class="line">+-----+----------------------------+-----+</span><br><span class="line">| 201 | Unisports                  |  97 |</span><br><span class="line">| 202 | OJ Atheletics              |  98 |</span><br><span class="line">| 203 | Delhi Sports               |  99 |</span><br><span class="line">| 204 | Womansport                 | 100 |</span><br><span class="line">| 205 | Kam&#x27;s Sporting Goods       | 101 |</span><br><span class="line">| 206 | Sportique                  | 102 |</span><br><span class="line">| 208 | Muench Sports              | 103 |</span><br><span class="line">| 208 | Muench Sports              | 104 |</span><br><span class="line">| 209 | Beisbol Si!                | 105 |</span><br><span class="line">| 210 | Futbol Sonora              | 106 |</span><br><span class="line">| 211 | Kuhn&#x27;s Sports              | 107 |</span><br><span class="line">| 212 | Hamada Sport               | 108 |</span><br><span class="line">| 213 | Big John&#x27;s Sports Emporium | 109 |</span><br><span class="line">| 214 | Ojibway Retail             | 110 |</span><br><span class="line">| 204 | Womansport                 | 111 |</span><br><span class="line">| 210 | Futbol Sonora              | 112 |</span><br><span class="line">+-----+----------------------------+-----+</span><br><span class="line">16 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>分析</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select c.id,c.name from s_customer c;</span><br><span class="line">+-----+----------------------------+</span><br><span class="line">| id  | name                       |</span><br><span class="line">+-----+----------------------------+</span><br><span class="line">| 201 | Unisports                  |</span><br><span class="line">| 202 | OJ Atheletics              |</span><br><span class="line">| 203 | Delhi Sports               |</span><br><span class="line">| 204 | Womansport                 |</span><br><span class="line">| 205 | Kam&#x27;s Sporting Goods       |</span><br><span class="line">| 206 | Sportique                  |</span><br><span class="line">| 207 | Sweet Rock Sports          |</span><br><span class="line">| 208 | Muench Sports              |</span><br><span class="line">| 209 | Beisbol Si!                |</span><br><span class="line">| 210 | Futbol Sonora              |</span><br><span class="line">| 211 | Kuhn&#x27;s Sports              |</span><br><span class="line">| 212 | Hamada Sport               |</span><br><span class="line">| 213 | Big John&#x27;s Sports Emporium |</span><br><span class="line">| 214 | Ojibway Retail             |</span><br><span class="line">| 215 | Sporta Russia              |</span><br><span class="line">+-----+----------------------------+</span><br><span class="line">15 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select o.id,o.customer_id from s_ord o;</span><br><span class="line">+-----+-------------+</span><br><span class="line">| id  | customer_id |</span><br><span class="line">+-----+-------------+</span><br><span class="line">|  97 |         201 |</span><br><span class="line">|  98 |         202 |</span><br><span class="line">|  99 |         203 |</span><br><span class="line">| 100 |         204 |</span><br><span class="line">| 101 |         205 |</span><br><span class="line">| 102 |         206 |</span><br><span class="line">| 103 |         208 |</span><br><span class="line">| 104 |         208 |</span><br><span class="line">| 105 |         209 |</span><br><span class="line">| 106 |         210 |</span><br><span class="line">| 107 |         211 |</span><br><span class="line">| 108 |         212 |</span><br><span class="line">| 109 |         213 |</span><br><span class="line">| 110 |         214 |</span><br><span class="line">| 111 |         204 |</span><br><span class="line">| 112 |         210 |</span><br><span class="line">+-----+-------------+</span><br><span class="line">16 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>左连接 - left join</p><p><strong>A表  join B表 - 以left join左边的表为基准表.右边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来.</strong></p><p>如果这个客户没有订单信息,那么也要将这个客户的信息查询出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select c.id,c.name,o.id oid from s_customer c left join s_ord o on c.id = o.customer_id;</span><br><span class="line"></span><br><span class="line">+-----+----------------------------+------+</span><br><span class="line">| id  | name                       | oid  |</span><br><span class="line">+-----+----------------------------+------+</span><br><span class="line">| 201 | Unisports                  |   97 |</span><br><span class="line">| 202 | OJ Atheletics              |   98 |</span><br><span class="line">| 203 | Delhi Sports               |   99 |</span><br><span class="line">| 204 | Womansport                 |  100 |</span><br><span class="line">| 205 | Kam&#x27;s Sporting Goods       |  101 |</span><br><span class="line">| 206 | Sportique                  |  102 |</span><br><span class="line">| 208 | Muench Sports              |  103 |</span><br><span class="line">| 208 | Muench Sports              |  104 |</span><br><span class="line">| 209 | Beisbol Si!                |  105 |</span><br><span class="line">| 210 | Futbol Sonora              |  106 |</span><br><span class="line">| 211 | Kuhn&#x27;s Sports              |  107 |</span><br><span class="line">| 212 | Hamada Sport               |  108 |</span><br><span class="line">| 213 | Big John&#x27;s Sports Emporium |  109 |</span><br><span class="line">| 214 | Ojibway Retail             |  110 |</span><br><span class="line">| 204 | Womansport                 |  111 |</span><br><span class="line">| 210 | Futbol Sonora              |  112 |</span><br><span class="line">| 207 | Sweet Rock Sports          | NULL |</span><br><span class="line">| 215 | Sporta Russia              | NULL |</span><br><span class="line">+-----+----------------------------+------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>右连接 - right join</p><p><strong>A表  join B表 - 以right join右边的表为基准表.左边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,o.id oid from s_ord o right join s_customer c on c.id = o.customer_id;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>自关联 - 自己关联自己</p><p>– 员工s_emp表中的manager_id - 上司的id -&gt; 绑定的就是s_emp表中的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,first_name,manager_id from s_emp;</span><br><span class="line">+----+------------+------------+</span><br><span class="line">| id | first_name | manager_id |</span><br><span class="line">+----+------------+------------+</span><br><span class="line">|  1 | Car_men    |       NULL |</span><br><span class="line">|  2 | LaDoris    |          1 |</span><br><span class="line">|  3 | Midori     |          1 |</span><br><span class="line">|  4 | Ma_rk      |          1 |</span><br><span class="line">|  5 | Audry      |          1 |</span><br><span class="line">|  6 | Molly      |          2 |</span><br><span class="line">|  7 | Roberta    |          2 |</span><br><span class="line">|  8 | Ben        |          2 |</span><br><span class="line">|  9 | Antoinette |          2 |</span><br><span class="line">| 10 | Marta      |          2 |</span><br><span class="line">| 11 | Colin      |          3 |</span><br><span class="line">| 12 | Henry      |          3 |</span><br><span class="line">| 13 | Yasmin     |          3 |</span><br><span class="line">| 14 | Mai        |          3 |</span><br><span class="line">| 15 | Andre      |          3 |</span><br><span class="line">| 16 | Elena      |          6 |</span><br><span class="line">| 17 | George     |          6 |</span><br><span class="line">| 18 | Akira      |          7 |</span><br><span class="line">| 19 | Vikram     |          7 |</span><br><span class="line">| 20 | Chad       |          8 |</span><br><span class="line">| 21 | Alexander  |          8 |</span><br><span class="line">| 22 | Eddie      |          9 |</span><br><span class="line">| 23 | Radha      |          9 |</span><br><span class="line">| 24 | Bela       |         10 |</span><br><span class="line">| 25 | Sylvie     |         10 |</span><br><span class="line">+----+------------+------------+</span><br><span class="line">25 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>练习</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工的名字,以及这个员工的上司的名字 - 一个上司拥有多个下属的.</span><br><span class="line">-- 效果:这个员工没有上司,也要能够查询出来.</span><br><span class="line">mysql&gt; select e1.first_name 员工名字,e2.first_name 上司 from s_emp e1 left join s_emp e2 on e2.id = e1.manager_id</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><blockquote><p>SELECT 语句</p><p>WHERE 语句</p><p>GROUP BY 语句</p><p>[HAVING 组函数判断]</p><p>ORDER BY语句</p></blockquote><h3 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h3><blockquote><ol><li><p><strong>count函数 - 统计个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 统计s_emp的员工的个数</span><br><span class="line">mysql&gt; select count(*) from s_emp;</span><br><span class="line"></span><br><span class="line">-- 除了可以写*,那么还可以推荐写id</span><br><span class="line">mysql&gt; select count(e.id) from s_emp e;</span><br><span class="line"></span><br><span class="line">-- 重复的数据也算1个</span><br><span class="line">mysql&gt; select count(title) from s_emp;</span><br><span class="line"></span><br><span class="line">-- 统计职称,重复的数据,只要统计一次</span><br><span class="line">mysql&gt; select count(distinct title) from s_emp;</span><br><span class="line"></span><br><span class="line">-- 如果遇到null值,忽略null值的统计</span><br><span class="line">mysql&gt; select count(commission_pct) from s_emp;</span><br></pre></td></tr></table></figure></li><li><p><strong>avg,sum,min,max - 忽略null值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 统计学生的得分情况</span><br><span class="line">mysql&gt;select avg(score),sum(score),min(score),max(score) from sc;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><blockquote><ol><li><p>统计各个部门编号,以及这个部门的员工的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_id,count(*) from s_emp group by dept_id;</span><br></pre></td></tr></table></figure></li><li><p>统计部门人数大于等于3的部门的编号以及人数信息</p><p><code>条件是分组之后得到的,所以不能使用where语句,where语句是出现在group by分组之前的.一定是用having语句来进行判断</code></p><p><code>having后面一定只能跟组函数的判断</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_id,count(*) from s_emp group by dept_id having count(*)&gt;=3;</span><br></pre></td></tr></table></figure></li><li><p>统计部门[41,42,43]人数大于等于4的部门的编号以及人数信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=4;</span><br></pre></td></tr></table></figure></li><li><p>统计部门[41,42,43]人数大于等于3的部门的编号以及人数信息,并且根据部门编号降序排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=3 order by 1 desc;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="分组练习"><a href="#分组练习" class="headerlink" title="分组练习"></a>分组练习</h4><blockquote><ol start="0"><li><p>经常分组统计 - 分组+统计.也是可以只进行分组的动作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 统计每个职称的人数 - 分组+统计了</span><br><span class="line">mysql&gt; select title,count(id) from s_emp group by title;</span><br><span class="line">      </span><br><span class="line">-- 只是分组 - 除了可以使用distinct来去重.那么我们也可以直接使用分组进行去重.</span><br><span class="line">mysql&gt; select title from s_emp group by title;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol><li><p>统计部门的名称,编号以及该部门上的员工的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.id,d.name,count(e.id) from s_emp e join s_dept d on e.dept_id = d.id</span><br><span class="line">       group by d.id,d.name;</span><br><span class="line">       </span><br><span class="line">-- 注意点,写group by 容易发生错误的地方.</span><br><span class="line"></span><br><span class="line">-- mysql5.7以后对group by的写法要求变得高了.推荐.</span><br><span class="line">-- 如果select后面除了存在组函数以外,还存在其他列.那么group by后面的列一定要和select后面的列高度保持一致.</span><br><span class="line">-- 1. select 列1,列2,组函数 from 表 group by 列1,列2</span><br><span class="line"></span><br><span class="line">-- 但是如果select后面只有组函数</span><br><span class="line">select count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id;</span><br></pre></td></tr></table></figure></li><li><p>统计每个客户的订单数量[超过1的统计出来],没有订单的客户也要能够统计出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select c.id,c.name,count(o.id) from s_customer c left join s_ord o on c.id = o.customer_id group by c.id,c.name having count(o.id)&gt;1;</span><br></pre></td></tr></table></figure></li><li><p>统计每个区域的部门的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select r.id,r.name,count(d.id) from s_region r join s_dept d on r.id = d.region_id group by r.id,r.name;</span><br></pre></td></tr></table></figure></li><li><p>统计每个区域上的员工的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select r.name,r.id,count(e.id) from s_region r join s_dept d on r.id = d.region_id join s_emp e</span><br><span class="line">on e.dept_id = d.id group by r.name,r.id;</span><br></pre></td></tr></table></figure></li><li><p>统计每个学生的课程的总分,平均分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select v.sid,sum(v.score),avg(v.score) from sc v group by v.sid;</span><br><span class="line"></span><br><span class="line">-- 统计每个学生的id,姓名以及他的课程的总分,平均分</span><br><span class="line">mysql&gt; select s.id,s.sname,sum(v.score),avg(v.score) from student s left join sc v on s.id = v.sid</span><br><span class="line">group by s.id,s.sname;</span><br></pre></td></tr></table></figure></li><li><p>统计每个老师授课的课程的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select t.id,t.tname,count(c.id) from teacher t join course c on t.id = c.tid group by t.id,t.tname;</span><br></pre></td></tr></table></figure></li><li><p>统计每个课程的最低分,最高分,平均分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select c.id,c.cname,min(v.score),max(v.score),avg(v.score) from course c </span><br><span class="line">join sc v on c.id = v.cid group by c.id,c.cname;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="8"><li><p>统计李老师的学生数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select t.id,t.tname,count(v.sid) from teacher t </span><br><span class="line">join course c on t.id = c.tid</span><br><span class="line">join sc v on v.cid = c.id where t.tname like &#x27;李%&#x27;</span><br><span class="line">group by t.id,t.tname;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="子查询-最难的"><a href="#子查询-最难的" class="headerlink" title="子查询 - 最难的"></a>子查询 - 最难的</h2><blockquote><p><strong>子查询是效率不如关联查询</strong>.但是子查询更加灵活.能用关联查询解决的查询,肯定也是可以通过子查询去解决.</p><p>但是子查询可以解决关联查询解决的查询.使用原则优先使用关联查询.</p><p>注意点:子查询必须要使用()括号</p><p>三个维度</p><ol><li><strong>子查询作为外部查询的列.</strong></li><li>子查询作为外部查询的where语句中</li><li>子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询.</li></ol></blockquote><p>###子查询作为外部查询的where语句中</p><blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id;</span><br><span class="line"></span><br><span class="line">-- 分解 - 找出&#x27;Ben&#x27;的部门id</span><br><span class="line">mysql&gt; select dept_id from s_emp where first_name=&#x27;Ben&#x27;;//43</span><br><span class="line"></span><br><span class="line">-- 找出43部门的所有的员工,但是不包含Ben</span><br><span class="line">mysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=43;</span><br><span class="line"></span><br><span class="line">-- 整合到一块儿</span><br><span class="line">mysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=(select dept_id from s_emp where first_name=&#x27;Ben&#x27;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="子查询作为外部查询的列"><a href="#子查询作为外部查询的列" class="headerlink" title="子查询作为外部查询的列"></a>子查询作为外部查询的列</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查询客户的id,客户的姓名,以及该客户的订单个数</span><br><span class="line">mysql&gt; select c.id,c.name,(select count(o.customer_id) from s_ord o where c.id=o.customer_id) 订单数量</span><br><span class="line">from s_customer c;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询部门的id,部门的名称,以及这个部门上的员工的个数</span><br><span class="line">mysql&gt; select d.id,d.name,(select count(e.id) from s_emp e where e.dept_id = d.id) 员工数 from s_dept d;</span><br></pre></td></tr></table></figure></blockquote><p>###子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询.</p><blockquote><p>使用场景最多的子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 用子查询来实现 - 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id</span><br><span class="line"></span><br><span class="line">-- (select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;)结果必须返回单个值</span><br><span class="line">mysql&gt; select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;) from s_emp e;</span><br><span class="line">和下面的这个效果是一样的</span><br><span class="line">mysql&gt; select e.first_name,e.dept_id from s_emp e;</span><br><span class="line"></span><br><span class="line">-- 修改</span><br><span class="line">-- 思路 e.first_name,子查询e.dept_id - 判断成立 - 有值,否则为null</span><br><span class="line">-- e.dept_id是否和&#x27;Ben&#x27;是一个部门的.</span><br><span class="line">select e.first_name,</span><br><span class="line">(select e.dept_id from s_emp e1 </span><br><span class="line"> where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) did</span><br><span class="line">from s_emp e;</span><br><span class="line"></span><br><span class="line">-- 把上面的查询的结果作为&quot;虚拟表&quot; - 别名 - core_</span><br><span class="line">select * from (</span><br><span class="line">select e.first_name,</span><br><span class="line">  (select e.dept_id from s_emp e1 </span><br><span class="line">   where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) did</span><br><span class="line"> from s_emp e</span><br><span class="line">) core_ where core_.did is not null and core_.first_name&lt;&gt;&#x27;Ben&#x27;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="exists和not-exists用法"><a href="#exists和not-exists用法" class="headerlink" title="exists和not exists用法"></a>exists和not exists用法</h2><blockquote><ol><li><p>exists - 是否存在.只要存在,那么就返回true - 顺利被查询出来</p></li><li><p>not exists - 不存在  如果是false,反而会被顺利查询出来</p></li><li><p>案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- exists(子查询 - 如果有结果,返回true,否则返回false)</span><br><span class="line">mysql&gt;select first_name from s_emp where exists(select 1 from s_emp where 1=1);</span><br><span class="line">   </span><br><span class="line">mysql&gt;select first_name from s_emp where not exists(select 1 from s_emp where 1=2);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="练习-salary是不重复的"><a href="#练习-salary是不重复的" class="headerlink" title="练习 - salary是不重复的"></a>练习 - salary是不重复的</h3><blockquote><ol><li> <strong>查询和’Ben’在同一个部门的员工first_name,dept_id</strong></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select e.first_name,e.dept_id from s_emp e where exists(</span><br><span class="line">select 1 from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e1.dept_id=e.dept_id</span><br><span class="line">) and e.first_name&lt;&gt;&#x27;Ben&#x27;;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li><p>找出各个部门工资排名前二的员工</p><p>“e-我”这个部门中,如果还有人工资比我高.那么这个数量不能超过1个.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where exists(</span><br><span class="line">  select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary</span><br><span class="line">  having count(*)&lt;=1</span><br><span class="line">) order by 1;</span><br></pre></td></tr></table></figure><p>not exists来实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不存在&#x27;我e&#x27;这个部门中,有人的工资比我高.并且这个数量超过1个.</span><br><span class="line">mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where not exists(</span><br><span class="line">  select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary</span><br><span class="line">  having count(*)&gt;1</span><br><span class="line">) order by 1;</span><br></pre></td></tr></table></figure></li><li><p>找出各个部门中工资最高的 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where not exists(</span><br><span class="line">  select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary</span><br><span class="line">  having count(*)&gt;0</span><br><span class="line">) order by 1;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="mysql-单行函数-了解即可"><a href="#mysql-单行函数-了解即可" class="headerlink" title="mysql 单行函数 - 了解即可"></a>mysql 单行函数 - 了解即可</h1><blockquote><p>第一个作业 - 字符串函数+数字函数+日期函数[能有多少] - mysql_function.md</p></blockquote><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><blockquote><ol><li><p>instr(str,substr) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0)</p><p>mysql下标索引从1开始的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select instr(&#x27;ppopo&#x27;,&#x27;o&#x27;);//3,找不到则返回0</span><br></pre></td></tr></table></figure></li><li><p>lpad(str,len,padstr) - 用字符串padstr填补str左端直到字串长度为len并返回 </p></li><li><p>rpad(str,len,padstr) - 用字符串padstr填补str右端直到字串长度为len并返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select rpad(&#x27;abc&#x27;,6,&#x27;do&#x27;);//abcdod</span><br><span class="line"></span><br><span class="line">mysql&gt;select rpad(&#x27;吴亦凡&#x27;,10,&#x27;*&#x27;);//</span><br><span class="line"></span><br><span class="line">-- oracle数据库rpad函数 - 遇到汉字,一个汉字是占3个长度吴亦凡*</span><br></pre></td></tr></table></figure></li><li><p>left(str,len) - 返回字符串str的左端len个字符 </p></li><li><p>right(str,len) - 返回字符串str的右端len个字符 </p></li><li><p>substring(str,pos,len) - 返回字符串str的位置pos起len个字符  </p></li><li><p>substring(str,pos) - 返回字符串str的位置pos起后面的子串 </p></li><li><p>ltrim(str) - 返回删除了左空格的字符串str  </p></li><li><p>rtrim(str)  - 返回删除了右空格的字符串str  </p></li><li><p>space(n) - 返回由n个空格字符组成的一个字符串  </p></li><li><p><em><strong>replace(str,from_str,to_str)  - 用字符串to_str替换字符串str中的子串from_str并返回</strong></em> </p></li><li><p>reverse(str) - 颠倒字符串str的字符顺序并返回</p></li><li><p>insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select insert(&#x27;Carmen&#x27;,2,5,&#x27;*****&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>lower(str) - 返回小写的字符串str  </p></li><li><p>upper(str) - 返回大写的字符串str</p></li><li><p><strong>char_length(str) -  不管汉字还是数字或者是字母都算是一个字符。</strong></p></li><li><p><strong>length(str);//汉字占3个,其他占1个.</strong></p></li></ol></blockquote><h3 id="列中的应用"><a href="#列中的应用" class="headerlink" title="列中的应用"></a>列中的应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-- 将first_name列的数据全部反转</span><br><span class="line">mysql&gt; select first_name,reverse(first_name) from s_emp;</span><br><span class="line"></span><br><span class="line">-- 这些函数是允许嵌套使用的</span><br><span class="line">mysql&gt; select first_name,upper(reverse(first_name)) from s_emp;</span><br><span class="line"></span><br><span class="line">-- 练习 - 模拟银行账户的输出方式-考虑该列是中文的情况.</span><br><span class="line">-- 查询效果</span><br><span class="line">-- Car_men   C******</span><br><span class="line">-- 吴亦凡     吴**</span><br><span class="line">-- Mark      M**</span><br><span class="line"></span><br><span class="line">-- concat函数 - 字符串的拼接</span><br><span class="line">mysql&gt; select first_name,concat(substring(first_name,1,1),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 显示账户 from s_emp;</span><br><span class="line"></span><br><span class="line">-- replace函数</span><br><span class="line">-- replace(str,oldStr,newStr);</span><br><span class="line">mysql&gt; select first_name,replace(first_name,substring(first_name,2),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp;</span><br><span class="line"></span><br><span class="line">-- 直接使用rpad函数</span><br><span class="line">-- rpad(str,拼接之后总的长度,appendStr);</span><br><span class="line">mysql&gt;select first_name,rpad(substring(first_name,1,1),char_length(first_name),&#x27;*&#x27;) 账户 from s_emp;</span><br><span class="line"></span><br><span class="line">-- 使用insert函数</span><br><span class="line">-- insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串</span><br><span class="line"></span><br><span class="line">-- insert函数的基本使用</span><br><span class="line">mysql&gt; select insert(&#x27;abcde&#x27;,2,3,&#x27;*&#x27;);//a*e</span><br><span class="line"></span><br><span class="line">mysql&gt; select first_name,insert(first_name,2,char_length(first_name)-1,rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&gt;剖析一下 - s_customer表phone列最后一个&#x27;-&#x27;后面的phone的数字.</span><br><span class="line"></span><br><span class="line">&gt;mysql&gt; select phone,reverse(phone) from s_customer;</span><br><span class="line">&gt;+----------------+----------------+</span><br><span class="line">&gt;| phone          | reverse(phone) |</span><br><span class="line">&gt;+----------------+----------------+</span><br><span class="line">&gt;| 55-2066101     | 1016602-55     |</span><br><span class="line">&gt;| 81-20101       | 10102-18       |</span><br><span class="line">&gt;| 91-10351       | 15301-19       |</span><br><span class="line">&gt;| 1-206-104-0103 | 3010-401-602-1 |</span><br><span class="line">&gt;| 852-3692888    | 8882963-258    |</span><br><span class="line">&gt;| 33-2257201     | 1027522-33     |</span><br><span class="line">&gt;| 234-6036201    | 1026306-432    |</span><br><span class="line">&gt;| 49-527454      | 454725-94      |</span><br><span class="line">&gt;| 809-352689     | 986253-908     |</span><br><span class="line">&gt;| 52-404562      | 265404-25      |</span><br><span class="line">&gt;| 42-111292      | 292111-24      |</span><br><span class="line">&gt;| 20-1209211     | 1129021-02     |</span><br><span class="line">&gt;| 1-415-555-6281 | 1826-555-514-1 |</span><br><span class="line">&gt;| 1-716-555-7171 | 1717-555-617-1 |</span><br><span class="line">&gt;| 7-3892456      | 6542983-7      |</span><br><span class="line">&gt;+----------------+----------------+</span><br><span class="line"></span><br><span class="line">&gt;instr(str,substr);//从左到右查找substr在str中第一次出现的位置</span><br><span class="line"></span><br><span class="line">&gt;mysql&gt; select instr(reverse(phone),&#x27;-&#x27;) from s_customer;</span><br><span class="line"></span><br><span class="line">&gt;-- 取出&#x27;-&#x27;左边的元素</span><br><span class="line">&gt;left(str,len) - 返回字符串str的左端len个字符</span><br><span class="line"></span><br><span class="line">&gt;mysql&gt; select phone,left(reverse(phone),instr(reverse(phone),&#x27;-&#x27;)-1) from s_customer;</span><br><span class="line"></span><br><span class="line">&gt;+----------------+--------------------------------------------------+</span><br><span class="line">&gt;| phone          | left(reverse(phone),instr(reverse(phone),&#x27;-&#x27;)-1) |</span><br><span class="line">&gt;+----------------+--------------------------------------------------+</span><br><span class="line">&gt;| 55-2066101     | 1016602                                          |</span><br><span class="line">&gt;| 81-20101       | 10102                                            |</span><br><span class="line">&gt;| 91-10351       | 15301                                            |</span><br><span class="line">&gt;| 1-206-104-0103 | 3010                                             |</span><br><span class="line">&gt;| 852-3692888    | 8882963                                          |</span><br><span class="line">&gt;| 33-2257201     | 1027522                                          |</span><br><span class="line">&gt;| 234-6036201    | 1026306                                          |</span><br><span class="line">&gt;| 49-527454      | 454725                                           |</span><br><span class="line">&gt;| 809-352689     | 986253                                           |</span><br><span class="line">&gt;| 52-404562      | 265404                                           |</span><br><span class="line">&gt;| 42-111292      | 292111                                           |</span><br><span class="line">&gt;| 20-1209211     | 1129021                                          |</span><br><span class="line">&gt;| 1-415-555-6281 | 1826                                             |</span><br><span class="line">&gt;| 1-716-555-7171 | 1717                                             |</span><br><span class="line">&gt;| 7-3892456      | 6542983                                          |</span><br><span class="line">&gt;+----------------+--------------------------------------------------+</span><br><span class="line"></span><br><span class="line">&gt;-- 继续反转</span><br><span class="line">&gt;mysql&gt; select phone,reverse(left(reverse(phone),instr(reverse(phone),&#x27;-&#x27;)-1)) from s_customer;</span><br></pre></td></tr></table></figure></blockquote><h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><blockquote><ol><li><p>abs(n) - 求绝对值</p></li><li><p>mod(n,m) - 取模运算,返回n被m除的余数(同%操作符)</p></li><li><p><strong>floor(n) - 返回不大于n的最大整数值</strong> - 向下取整  </p></li><li><p><strong>ceiling(n) - 返回不小于n的最小整数值</strong>  - 向上取整 </p></li><li><p>round(n[,d]) - 返回n的四舍五入值,保留d位小数(d的默认值为0)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select round(3.5);</span><br><span class="line"></span><br><span class="line">mysql&gt;select round(3.456,2);//3.46</span><br></pre></td></tr></table></figure></li><li><p>pow(x,y) - 返回值x的y次幂  </p></li><li><p>sqrt(n) - 返回非负数n的平方根</p></li><li><p>pi() - 返回圆周率  </p></li><li><p>rand() - 返回在范围**[0到1.0)**内的随机浮点值</p></li><li><p><strong>truncate(n,d) - 保留数字n的d位小数并返回  - 直接截取</strong></p></li></ol></blockquote><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><blockquote><ol><li><p>求1~3之间的随机整数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select floor(rand()*3+1);</span><br><span class="line">mysql&gt; select truncate(rand()*3+1,0);</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>计算年薪 - 保留小数点2位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,truncate(salary*12*(1+coalesce(commission_pct,0)/100),2) 年薪 from s_emp;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><blockquote><p>查询当前系统的日期 - <strong>select now();</strong></p><ol><li><p>dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准)  </p></li><li><p>weekday(date) - 返回日期date是星期几(0=星期一,1=星期二,……6= 星期天)</p></li><li><p><strong>year(date) - 返回date的年份(范围在1000到9999)</strong>    </p></li><li><p><strong>month(date)  - 返回date中的月份数值</strong>   </p></li><li><p><strong>dayofmonth(date)</strong> - 返回date是一月中的第几日(在1到31范围内)   </p></li><li><p><strong>hour(time) - 返回time的小时数(范围是0到23)</strong>  </p></li><li><p><strong>minute(time) - 返回time的分钟数(范围是0到59)</strong> </p></li><li><p><strong>second(time) - 返回time的秒数(范围是0到59)</strong> </p></li><li><p>period_add(p,n) - 增加n个月到时期p并返回(p的格式yymm或yyyymm) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select period_add(&#x27;202108&#x27;,3);</span><br><span class="line"></span><br><span class="line">-- 需求把s_emp表中的start_date往后延1个月</span><br><span class="line">mysql&gt; select start_date,period_add(date_format(start_date,&#x27;%Y%m&#x27;),1) from s_emp;</span><br></pre></td></tr></table></figure><p>注意:p可以是字符串,一定要满足一定的格式,或者可以直接使用date类型.</p></li><li><p>period_diff(p1,p2) - 返回在时期p1和p2之间月数(p1和p2的格式yymm或yyyymm)  p1-p2</p></li><li><p>curdate() - 以’yyyy-mm-dd’或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) </p></li><li><p>curtime() - 以’hh:mm:ss’或hhmmss格式返回当前时间值(根据返回值所处上下文是字符串或数字)</p></li><li><p>now() - 以’yyyy-mm-dd hh:mm:ss’或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字)     </p></li><li><p>last_day(date) - date日期所在月的最后一天是什么时候</p></li><li><p>datediff(d1,d2) - 两个日期d1,d2之间相差的天数</p></li><li><p>timestampdiff(type,d1,d2) - type - year,month,day…</p></li></ol><p>mysql中,虽然日期date_format函数来转成字符串类型的,mysql内部为了简化我们的写法,有的时候有的函数.</p><p>只要你传入的字符串满足一定的格式,那么它就会自动被转成日期函数.</p></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. date_add(date,interval n type)</span><br><span class="line">2. date_sub(date,interval n type)</span><br><span class="line">type:</span><br><span class="line">year</span><br><span class="line">month</span><br><span class="line">day</span><br><span class="line">hour</span><br><span class="line">minute</span><br><span class="line">second</span><br></pre></td></tr></table></figure><h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><blockquote><p><strong>date_format(date,format)</strong>   - 把日期转换成指定模板的字符串.</p><p> 根据format字符串格式化date值<br>　(在format字符串中可用标志符:<br>　%m 月名字(january……december)<br>　%w 星期名字(sunday……saturday)<br>　%d 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）<br>　<strong>%Y 年, 数字, 4 位<br>　%y 年, 数字, 2 位</strong><br>　%a 缩写的星期名字(sun……sat)<br>　<strong>%d 月份中的天数, 数字(00……31)<br>　%e 月份中的天数, 数字(0……31)</strong><br>　<strong>%m 月, 数字(01……12)<br>　%c 月, 数字(1……12)</strong><br>　%b 缩写的月份名字(jan……dec)<br>　%j 一年中的天数(001……366)<br>　<strong>%H 24时制小时(00……23)</strong><br>　%k 小时(0……23)<br>　%h 12时小时(01……12)<br>　<strong>%i 小时(01……12)</strong><br>　%l 小时(1……12)<br>　<strong>%i 分钟, 数字(00……59)</strong><br>　%r 时间,12 小时(hh:mm:ss [ap]m)<br>　%t 时间,24 小时(hh:mm:ss)<br>　<strong>%s 秒(00……59)</strong><br>　%p am或pm<br>　%w 一个星期中的天数(0=sunday ……6=saturday ）   </p></blockquote><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d %H:%i:%s&#x27;) from s_emp;</span><br></pre></td></tr></table></figure><h3 id="日期练习"><a href="#日期练习" class="headerlink" title="日期练习"></a>日期练习</h3><blockquote><ol><li><p>找出员工的工作月数 - 和当前的日比较的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select first_name,start_date,timestampdiff(month,start_date,now()) 月份 from s_emp;</span><br></pre></td></tr></table></figure></li><li><p>查询员工的工作天数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,start_date,timestampdiff(day,start_date,now()) 天数 from s_emp;</span><br><span class="line"></span><br><span class="line">mysql&gt; select first_name,start_date,abs(datediff(start_date,now())) 天数 from s_emp;</span><br></pre></td></tr></table></figure></li><li><p>计算一年前,当前,一年后的日期</p><blockquote><ol><li>date_add(date,interval n type)</li><li>date_sub(date,interval n type)</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select date_sub(now(),interval 1 year) 一年前,now() 当前,date_add(now(),interval 1 year) 一年后;</span><br><span class="line"></span><br><span class="line">mysql&gt; select date_add(now(),interval -12 month) 一年前,now() 当前,date_add(now(),interval 12 month) 一年后;</span><br></pre></td></tr></table></figure></li><li><p>当前日期前6个月的最后一天</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select last_day(date_sub(now(),interval 6 month));</span><br></pre></td></tr></table></figure></li><li><p>把员工的入职日期格式化为年/月/日</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d&#x27;) from s_emp;</span><br><span class="line"></span><br><span class="line">-- 1990年05月03日</span><br><span class="line">mysql&gt; select start_date,date_format(start_date,&#x27;%Y年%m月%d日&#x27;) from s_emp;</span><br></pre></td></tr></table></figure></li><li><p>找出5月份入职的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select first_name,start_date from s_emp where month(start_date)=5;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h1><h2 id="日期转字符串"><a href="#日期转字符串" class="headerlink" title="日期转字符串"></a>日期转字符串</h2><blockquote><p>数据查询出来之后显示用的.</p><p><strong>date_format(date,模板);</strong></p></blockquote><h2 id="字符串转日期"><a href="#字符串转日期" class="headerlink" title="字符串转日期"></a>字符串转日期</h2><blockquote><p>插入数据的时候,需要将日期列的字符串转换成日期类型,才能够插入到date类型列.</p><ol><li><p><strong>mysql中只要你的字符串满足默认支持的格式.那么就会默认转成date类型.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- date列</span><br><span class="line">insert into test_date values(3,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);//ok &#x27;2019-09-08&#x27;</span><br><span class="line">insert into test_date values(4,&#x27;xx&#x27;,&#x27;2019/10/08&#x27;);//ok &#x27;2019/10/08&#x27;</span><br><span class="line">insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);//ok &#x27;20191105&#x27;</span><br><span class="line">insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);//ok</span><br><span class="line"></span><br><span class="line">假设如果指定的是一个非法的字符串模板</span><br><span class="line">mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;05/11/2023&#x27;);</span><br><span class="line">ERROR 1292 (22007): Incorrect date value: &#x27;05/11/2023&#x27; for column &#x27;d1&#x27; at row 1</span><br></pre></td></tr></table></figure></li><li><p>解决一个非法模板的字符串 - mysql不能把这个形式的字符串自动转换成date/datetime类型</p><p><strong>str_to_date(str,pattern)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str的格式也必须要和pattern是匹配 - 实现str-date类型的转换</span><br><span class="line">           </span><br><span class="line">mysql&gt; <span class="function">insert into test_date <span class="title">values</span><span class="params">(<span class="number">6</span>,<span class="string">&#x27;xx&#x27;</span>,str_to_date(<span class="string">&#x27;05/11/2023&#x27;</span>,<span class="string">&#x27;%d/%m/%Y&#x27;</span>)</span>)</span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="date和datetime"><a href="#date和datetime" class="headerlink" title="date和datetime"></a>date和datetime</h1><blockquote><p>date - 年月日</p><p>datetime - 年月日时分秒</p></blockquote><blockquote><p>mysql中列如果是一个日期,常用的俩个类型分别是date和datetime</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">drop table test_date;</span><br><span class="line"></span><br><span class="line">create table test_date(</span><br><span class="line">  id int(7),</span><br><span class="line">  name varchar(20),</span><br><span class="line">  d1 date</span><br><span class="line">);</span><br><span class="line">-- 插入数据</span><br><span class="line">insert into test_date values(1,&#x27;admin&#x27;,now());</span><br><span class="line"></span><br><span class="line">-- 插入指定的日期到表中</span><br><span class="line">mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);</span><br><span class="line"></span><br><span class="line">-- 列是date,但是插入数据包含时分秒的</span><br><span class="line">mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询出来的d1列的内容默认显示的日期的格式%Y-%m-%d</span><br><span class="line">mysql&gt; select * from test_date;</span><br><span class="line">+------+-------+------------+</span><br><span class="line">| id   | name  | d1         |</span><br><span class="line">+------+-------+------------+</span><br><span class="line">|    1 | admin | 2021-08-17 |</span><br><span class="line">+------+-------+------------+</span><br><span class="line"></span><br><span class="line">drop table test_datetime;</span><br><span class="line"></span><br><span class="line">create table test_datetime(</span><br><span class="line">  id int(7),</span><br><span class="line">  name varchar(20),</span><br><span class="line">  d1 datetime</span><br><span class="line">);</span><br><span class="line">insert into test_datetime values(1,&#x27;tom&#x27;,now());</span><br><span class="line"></span><br><span class="line">-- 效果,如果列设置成了datetime,查询出来的模板是-%Y-%m-%d %H:%i:%s</span><br><span class="line">mysql&gt; select * from test_datetime;</span><br><span class="line">+------+------+---------------------+</span><br><span class="line">| id   | name | d1                  |</span><br><span class="line">+------+------+---------------------+</span><br><span class="line">|    1 | tom  | 2021-08-17 10:12:18 |</span><br><span class="line">+------+------+---------------------+</span><br><span class="line"></span><br><span class="line">-- 插入一个指定的日期 - 仅仅包含年月日</span><br><span class="line">mysql&gt; insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);</span><br><span class="line"></span><br><span class="line">-- 时分秒是自动归0</span><br><span class="line"> 5 | xx   | 2019-09-08 00:00:00 </span><br><span class="line"> </span><br><span class="line">mysql&gt;insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019/09/08 13:12:18&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 5 | xx   | 2019-09-08 13:12:18</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>数组排序</title>
    <link href="http://example.com/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-10T09:54:17.000Z</published>
    <updated>2022-01-10T02:16:58.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><p><strong>简介:重点掌握冒泡,选择,快速排序</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>相邻的俩个进行俩俩比较.</p><p>每一轮比较完 - 确定一个最值</p><p><strong>9 3</strong> 1 7 5 2 1 </p><p>3 <strong>9 1</strong> 7 5 2 1</p><p>3 1 <strong>9 7</strong> 5 2 1</p><p>3 1 7 <strong>9 5</strong> 2 1</p><p>3 1 7 5 <strong>9 2</strong> 1</p><p>3 1 7 5 2 <strong>9 1</strong></p><p>3 1 7 5 2 1 <strong>9</strong></p><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/bubble.gif">      </p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>9 3</strong> 1 7 5 2 6</p><p>arr[0] -&gt; 依次和 后面所有的元素进行比较</p><p><strong>3</strong> 9 <strong>1</strong> 7 5 2 6</p><p><strong>1</strong> 9 3 7 5 2 6</p><p>确定最值</p><p>arr[1] -&gt; 依次和后面的所有的元素进行比较</p><p><strong>1</strong> <strong>2</strong> 9 7 5 3 6</p><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/select.gif"> </p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>简介:<em><strong>最简单的</strong></em></p><p>将数组中剩余的值(从数组中第2个位置开始)依次直接插入到前面,<strong>保证前面的序列仍然是一个有序的序列</strong></p><p>{3,1,2,5,4,6}</p><p>{<em><strong>3</strong></em>,1,2,5,4,6}</p><p>{<em><strong>1,3</strong></em>,2,5,4,6}</p><p>{<em><strong>1,2,3</strong></em>,5,4,6}</p><p>…</p><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/insert.gif">  </p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/fast.gif"> </p><p>算法思想:</p><p><strong>分治思想</strong>:比大小,再分区</p><ol><li>从数组中取出一个数,作为<strong>基准数</strong></li><li>分区:将比这个数[基准数]大或者等于的数全部放在它的右边,小于它的数全部放在它的左边</li><li>再对左右分区间重复第二步骤,直到各分区只有一个数</li></ol><p>实现思路:</p><p>挖坑填数</p><ol><li><strong>将基准数挖出形成第一个坑</strong></li><li><strong>由后向前找比它小的数,找到后挖出此数填到前一个坑中</strong></li><li><strong>由前向后找比它大或等于的数,找到后也挖出此数填到前一个坑中</strong></li><li><strong>再重复执行2,3两步骤.例如对5391672408</strong></li></ol><table><thead><tr><th>元素</th><th>5</th><th>3</th><th>9</th><th>1</th><th>6</th><th>7</th><th>2</th><th>4</th><th>0</th><th>8</th></tr></thead><tbody><tr><td>坑位</td><td>坑1</td><td></td><td>坑3</td><td></td><td>坑5</td><td>坑7</td><td>坑6</td><td>坑4</td><td>坑2</td><td></td></tr><tr><td></td><td>0</td><td>3</td><td>4</td><td>1</td><td>2</td><td>基准数5</td><td>7</td><td>6</td><td>9</td><td>8</td></tr><tr><td>坑位</td><td></td><td></td><td></td><td></td><td></td><td>pos</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>元素</th><th>5[基准数]</th><th>3</th><th>9</th><th>1</th><th>6</th><th>7</th><th>2</th><th>4</th><th>0</th><th>8</th></tr></thead><tbody><tr><td>坑位</td><td>坑1</td><td></td><td>坑3</td><td></td><td>坑5</td><td>坑7</td><td>坑6</td><td>坑4</td><td>坑2</td><td></td></tr><tr><td></td><td>0</td><td>3</td><td>4</td><td>1</td><td>2</td><td>基准数5</td><td>7</td><td>6</td><td>9</td><td>8</td></tr><tr><td>坑位</td><td></td><td></td><td></td><td></td><td></td><td>第一次重合的位置</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一轮以数组中的第一个元素5为基准数 - 经过一轮循环走完 - 以5位置为基准,左边的都是比5小的值,右边的都是大于或者等于5的数字 - <strong>关键就是找到重合的位置!!!(分区 - 递归调用)</strong></p><p>int[] arr = {5,3,9,1,6,7,2,4,0,8};</p><p>t</p><h2 id="其他排序"><a href="#其他排序" class="headerlink" title="其他排序"></a>其他排序</h2><ul><li>希尔排序</li><li>堆排序</li><li>归并排序6t</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day16</title>
    <link href="http://example.com/2021/08/01/day16/"/>
    <id>http://example.com/2021/08/01/day16/</id>
    <published>2021-08-01T11:02:10.000Z</published>
    <updated>2022-01-07T09:04:19.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h1><blockquote><ol><li><p><strong>反射式编程</strong>（英语：reflective programming）或<strong>反射</strong>（英语：reflection)或者<strong>内省</strong></p></li><li><p>是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。[<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-Forman_p8-1">1]</a>用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p><p>“通俗讲” - 通过反射技术在程序的运行过程中,来获取类/接口的信息[修饰符,类的名称,父类],属性的信息[修饰符,数据类型,属性名],方法的信息[修饰符,数据类型,名称]等.</p><p><strong>在运行的时候才知道我操作的是哪个类</strong></p></li><li><p>掌握目标:</p><p>3-1. <strong>通过反射技术来动态获取属性的信息</strong>以及<strong>操作属性</strong>[反射的技术来对属性的值进行设置和获取]</p><p>3-2. 通过<strong>反射技术来动态调用类中的构造方法</strong>以及<strong>获取构造方法的信息</strong>[修饰符,方法名,参数列表]</p><p>3-3. 通过反射技术来动态获取类里面的<strong>方法的信息</strong>[修饰符,数据类型,方法名以及方法参数列表]以及反射<strong>调用方法</strong></p></li><li><p>api包 - java.lang.reflect</p></li><li><p>反射优势 - “很流氓” - 破坏封装性.</p></li><li><p><strong>学好反射和设计模式 - 帮助我们未来来读懂一些框架源码的.所有的框架的底层都是基于反射技术来实现的.</strong></p></li></ol></blockquote><h1 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class<T></T></h1><blockquote><ol><li><p>class实例 - 一个类无论被实例化多少次,那么它在JVM中的class实例永远只有1个.</p></li><li><p>它是学习反射技术的必备的类 - 提供了很多api来完成掌握目标中的动作.</p></li><li><p><strong>所有被类加载器加载到内存中的类都是属于Class的对象</strong> - Class类是用来描述类的类[用来描述类的元信息]</p><p><strong>我们的类在Class面前,就是一个Class的对象而已</strong></p></li></ol></blockquote><h2 id="反射相关api"><a href="#反射相关api" class="headerlink" title="反射相关api"></a>反射相关api</h2><blockquote><ol><li><p><strong>Field getDeclaredField(String name);//根据属性的名称来得到Field对象</strong></p></li><li><p><strong>Field[] getDeclaredFields();//获取类里面所有的[包括私有的]声明的属性对应的Field数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只能获取到非私有的</span><br><span class="line"><span class="number">1.</span> <span class="function">Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="number">2.</span> Field[] getFields();</span><br></pre></td></tr></table></figure></li><li><p>String getName();//获取类的全限定名</p></li><li><p>String getSimpleName();//获取类的简称</p></li><li><p><strong>T newInstance();//调用空参构造</strong></p></li><li><p><strong>Constructor<T>    getDeclaredConstructor(Class&lt;?&gt;…  parameterTypes);</T></strong></p><p><strong>根据指定的参数类型来得到指定的构造对应的实例Constructor对象.</strong></p><p>如果什么参数都不传入,拿到的就是空参构造对应的Constructor对应的实例.</p></li><li><p><strong>Constructor&lt;?&gt;[]    getDeclaredConstructors();</strong></p><p><strong>直接获取类中的所有的构造,每个构造对应一个Constructor.</strong></p></li><li><p><strong>Method    getDeclaredMethod(String methodName,Class&lt;?&gt;…  parameterTypes);</strong></p></li><li><p><strong>Method][]    getDeclaredMethods();</strong></p></li></ol></blockquote><h2 id="获取类的Class实例的方式"><a href="#获取类的Class实例的方式" class="headerlink" title="获取类的Class实例的方式"></a>获取类的Class实例的方式</h2><blockquote><ol><li><p>类名.class</p></li><li><p>调用java.lang.Object类提供的方法Class&lt;?&gt; getClass();</p></li><li><p>框架底层喜欢的使用一种,更加灵活</p><p>Class类中提供的static Class&lt;?&gt; forName(“类的全限定名”);//需要抓取一个非运行时异常java.lang.ClassNotFoundException类型找不到异常</p></li><li><p>基本类型.class</p></li></ol></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: java.lang.Class&lt;T&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 10:26 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类的class实例的方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个类在JVM中的class实例永远只有1个 - 无论构建了多少个对象</span></span><br><span class="line">        <span class="comment">//1. 类名.class</span></span><br><span class="line">        Class&lt;?&gt; c1 = Point.class;</span><br><span class="line">        Class&lt;?&gt; c2 = Point.class;</span><br><span class="line">        System.out.println(c1);<span class="comment">//class tech.aistar.day16.Point</span></span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c3 = String.class;</span><br><span class="line">        System.out.println(c3);<span class="comment">//class java.lang.String</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对象.getClass();</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">        Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c4 = p1.getClass();<span class="comment">//对象的类型</span></span><br><span class="line">        Class&lt;?&gt; c5 = p2.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型判断    对象 instanceof 类</span></span><br><span class="line">        System.out.println(c4);<span class="comment">//class tech.aistar.day16.Point</span></span><br><span class="line">        System.out.println(c4 == c5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. Class类中提供的static Class&lt;?&gt; forName(&quot;类的全限定名&quot;);</span></span><br><span class="line">        <span class="comment">//TODO... 为甚鼓励使用这种 ???</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c6 = Class.forName(<span class="string">&quot;tech.aistar.day16.Point&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;c6:&quot;</span>+c6);<span class="comment">//c6:class tech.aistar.day16.Point</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 基本类型.class</span></span><br><span class="line">        Class&lt;?&gt; c7 = <span class="keyword">int</span>.class;</span><br><span class="line">        System.out.println(c7);<span class="comment">//int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Field字段实例"><a href="#Field字段实例" class="headerlink" title="Field字段实例"></a>Field字段实例</h1><blockquote><p>java.lang.reflect.Field</p></blockquote><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><blockquote><ol><li><p>int getModifiers();<br>返回由该 Field对象表示的字段的Java语言修饰符，作为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的 - 0</span></span><br><span class="line"><span class="comment">//public  -1</span></span><br><span class="line"><span class="comment">//private - 2</span></span><br><span class="line"><span class="comment">//protected - 4</span></span><br></pre></td></tr></table></figure></li><li><p>Class&lt;?&gt; getType();//返回属性的数据类型</p></li><li><p>String getName();//属性的名称</p></li><li><p>void set(Object obj,Object value);//通过属性对应的Field对象来告知JVM,应该把value设置到哪个obj对象上去.</p></li><li><p>void setAccessible(boolean on);//反射操作私有属性,必须要设置为true,否则会抛出-java.lang.IllegalAccessException</p></li><li><p>Object get(Object obj);//返回obj中属性字段的对应的属性值.</p></li></ol></blockquote><h1 id="Constructor构造实例"><a href="#Constructor构造实例" class="headerlink" title="Constructor构造实例"></a>Constructor构造实例</h1><h2 id="调用空参构造"><a href="#调用空参构造" class="headerlink" title="调用空参构造"></a>调用空参构造</h2><blockquote><ol><li><p>直接调用java.lang.Class<T>提供的方法T newsIntance();</T></p></li><li><p>java.lang.reflect.Constructor提供了方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">Constructor&lt;?&gt; c1 </span>= c.getDeclaredConstructor();</span><br><span class="line">Point p2 = (Point) c1.newInstance();<span class="comment">//可变长列表的方法</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="调用带参构造"><a href="#调用带参构造" class="headerlink" title="调用带参构造"></a>调用带参构造</h2><blockquote><ol><li><p>java.lang.reflect.Constructor - 提供的方法</p><p>public T newInstance(Object … initargs)</p></li></ol></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>int getModifiers();//获取修饰符对应的数字</p></li><li><p>String getName();//构造方法的名称 - [类的全限定名]</p></li><li><p><strong>void setAccessible(boolean on);//如果设置true,直接调用私有的的构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射可以破坏单例</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h1><blockquote><p>java.lang.reflect</p><ol><li><p>传入一个修饰符对应的数字,来返回修饰的具体的中文的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; PUBLIC) != <span class="number">0</span>)        sb.append(<span class="string">&quot;public &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; PROTECTED) != <span class="number">0</span>)     sb.append(<span class="string">&quot;protected &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; PRIVATE) != <span class="number">0</span>)       sb.append(<span class="string">&quot;private &quot;</span>);</span><br><span class="line">         </span><br><span class="line">  <span class="comment">/* Canonical order */</span></span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; ABSTRACT) != <span class="number">0</span>)      sb.append(<span class="string">&quot;abstract &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; STATIC) != <span class="number">0</span>)        sb.append(<span class="string">&quot;static &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; FINAL) != <span class="number">0</span>)         sb.append(<span class="string">&quot;final &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; TRANSIENT) != <span class="number">0</span>)     sb.append(<span class="string">&quot;transient &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; VOLATILE) != <span class="number">0</span>)      sb.append(<span class="string">&quot;volatile &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; SYNCHRONIZED) != <span class="number">0</span>)  sb.append(<span class="string">&quot;synchronized &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; NATIVE) != <span class="number">0</span>)        sb.append(<span class="string">&quot;native &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; STRICT) != <span class="number">0</span>)        sb.append(<span class="string">&quot;strictfp &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; INTERFACE) != <span class="number">0</span>)     sb.append(<span class="string">&quot;interface &quot;</span>);</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span> ((len = sb.length()) &gt; <span class="number">0</span>)    <span class="comment">/* trim trailing space */</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString().substring(<span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="反射可以破坏单例"><a href="#反射可以破坏单例" class="headerlink" title="反射可以破坏单例"></a>反射可以破坏单例</h2><blockquote><p>反射破坏不了枚举单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.design.singleton.version03.Singleton03;</span><br><span class="line"><span class="keyword">import</span> tech.aistar.design.singleton.version04.Singleton04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射可以破坏单例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 2:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectPoSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取单例的Class实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(<span class="string">&quot;tech.aistar.design.singleton.version03.Singleton03&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 获取空参构造对应的Constructor实例</span></span><br><span class="line">            Constructor&lt;?&gt; c1 = c.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">//3. 调用私有的空参构造</span></span><br><span class="line">            c1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 调用</span></span><br><span class="line">            Singleton03 s1 = (Singleton03) c1.newInstance();</span><br><span class="line">            <span class="comment">//反射连续调用俩次私有的空参构造</span></span><br><span class="line">            Singleton03 s2 = (Singleton03) c1.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="为何破坏不了枚举类型单例"><a href="#为何破坏不了枚举类型单例" class="headerlink" title="为何破坏不了枚举类型单例"></a>为何破坏不了枚举类型单例</h2><h2 id="分析-NoSuchMethodException"><a href="#分析-NoSuchMethodException" class="headerlink" title="分析-NoSuchMethodException"></a>分析-NoSuchMethodException</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记载类,初始化静态属性,调用空参构造 </span></span><br><span class="line">Class&lt;?&gt; c5 = Class.forName(<span class="string">&quot;tech.aistar.design.singleton.version05.Singleton05&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; cc = c5.getDeclaredConstructor();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">控制台效果</span><br><span class="line">比较繁琐的操作的事情,费时费力的事情</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在一个空参构造的方法让我们去调用</span></span><br><span class="line">java.lang.NoSuchMethodException: tech.aistar.design.singleton.version05.Singleton05.&lt;init&gt;()</span><br><span class="line">at java.lang.Class.getConstructor0(Class.java:<span class="number">3082</span>)</span><br><span class="line">at java.lang.Class.getDeclaredConstructor(Class.java:<span class="number">2178</span>)</span><br><span class="line">at tech.aistar.day16.ReflectPoSingleton.main(ReflectPoSingleton.java:<span class="number">36</span>)</span><br></pre></td></tr></table></figure><p>控制台</p><p>hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">  INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">确认jdk-bin-jad.exe - 没有下载 - http:<span class="comment">//varaneckas.com/jad/</span></span><br><span class="line">javac hello</span><br><span class="line">jad -s java hello</span><br><span class="line">反编译之后出来之后 hello(String.class,<span class="keyword">int</span>.class)</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br></pre></td></tr></table></figure><h2 id="分析-IllegalArgumentException"><a href="#分析-IllegalArgumentException" class="headerlink" title="分析 - IllegalArgumentException"></a>分析 - IllegalArgumentException</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载这个类</span></span><br><span class="line">Class&lt;?&gt; c5 = Class.forName(<span class="string">&quot;tech.aistar.design.singleton.version05.Singleton05&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">//java.lang.NoSuchMethodException - 抛出一个不存在这个方法</span></span><br><span class="line"></span><br><span class="line">cc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: </span></span><br><span class="line"><span class="comment">// Cannot reflectively create enum objects</span></span><br><span class="line">Singleton05 s05 = (Singleton05) cc.newInstance();</span><br></pre></td></tr></table></figure><p><code>原因剖析newInstance方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//判断是否为枚举类型,如果是枚举类型直接抛出了这个异常了.</span></span><br><span class="line">  <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>结论 - 不允许我们用反射的技术来构建枚举类型的实例,底层会进行类型的判断,发现如果是枚举类型对应的class实例,直接抛出异常</code></p></blockquote><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><p>一个对象的中的所有String类型的成员变量所对应的字符串内容中的”b”改为”a”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name = <span class="string">&quot;tbm&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String s1 = <span class="string">&quot;adminb&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射技术 - 所有字段拿出来 - Field数组中 </span></span><br><span class="line"><span class="comment">//获取到Field的类型,判断是不是String类型</span></span><br><span class="line"><span class="comment">//如果是String-&quot;b&quot;改为&quot;a&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="反射工厂"><a href="#反射工厂" class="headerlink" title="反射工厂"></a>反射工厂</h1><blockquote><p>回忆工厂设计模式[GOF]</p><ol><li>简单工厂方法,多方法工厂,静态方法工厂 - 本质上不属于GOF</li><li>工厂方法设计模式以及抽象工厂[专注于产品族] - 属于GOF</li><li>反射工厂 - 工厂类中利用反射技术来构建某个类的/接口的具体的实例.</li></ol></blockquote><h2 id="补充Properties"><a href="#补充Properties" class="headerlink" title="补充Properties"></a>补充Properties</h2><blockquote><ol><li><p>属于集合框架的类 - 属于Map[I]</p></li><li><p><strong>java.util.Properties extends java.util.Hashtable</strong>[哈希表,多线程安全的]</p></li><li><p>作用:通过io流把本地的.properties文件读取到内存中,然后映射到Properties对象</p><p><strong>Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射.</strong></p><p>File - 本地磁盘的文件在java内存中的映射的那个对象.</p></li><li><p>存储数据的格式然后是一个键值对的形式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key=value - key也是不要重复的.</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">tom</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>根据key来获取value的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="6"><li><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16.prop;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 读取Properties文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 8:41 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ReadPropDemo</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 定义一个Properties属性</span></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">   </span><br><span class="line">    ReadPropDemo()&#123;</span><br><span class="line">        <span class="comment">//可以在构造方法 - 初始化的</span></span><br><span class="line">        <span class="comment">//Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射.</span></span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//读取属性文件</span></span><br><span class="line">        <span class="comment">//InputStream in = new FileInputStream(&quot;src/tech/aistar/day16/prop.bean.properties&quot;);</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">//固定的语法 - 死记住</span></span><br><span class="line">        <span class="comment">//获取属性文件字节输入流</span></span><br><span class="line">        InputStream in = Thread.currentThread()</span><br><span class="line">                                .getContextClassLoader()</span><br><span class="line">                                .getResourceAsStream(<span class="string">&quot;tech/aistar/day16/prop/bean.properties&quot;</span>);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射.</span></span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确认properties不为null</span></span><br><span class="line">        <span class="keyword">return</span> properties == <span class="keyword">null</span>?<span class="keyword">null</span>:properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="6"><li><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16.prop;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 8:47 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadPropDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String value = ReadPropDemo.INSTANCE.getValue(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="反射工厂demo"><a href="#反射工厂demo" class="headerlink" title="反射工厂demo"></a>反射工厂demo</h2><blockquote><ol><li><p>简单工厂的缺点 - 如果有新的产品的加入,需要修改工厂类的 - 违背了软件开发的设计原则 - “开闭原则”</p><p>优点 - 够简单</p></li><li><p>工厂方法设计模式 - 优点:一个工厂类只负责生产一个产品,如果有新的产品的加入.不需要修改工厂类,只需要增加一个工厂类</p><p>缺点 - 项目中会存在很多的工厂类.</p></li><li><p>抽象工厂 - 负责创建一个产品族.</p></li><li><p><strong>反射工厂既能够保证在新增一个产品的时候,能够遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类.</strong></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射工厂 - 反射工厂既能够保证在新增一个产品的时候,能够遵守&quot;开闭原则&quot;,</span></span><br><span class="line"><span class="comment"> *                      又能够保证始终仅仅只有一个工厂类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             Properties + 反射 + 泛型方法/泛型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 9:13 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFactory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//面向接口编程</span></span><br><span class="line">    <span class="comment">//泛型方法 - 静态方法&lt;T&gt;,同时也要设置泛型类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T <span class="title">getInstance</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果传入进来的是type - 是某个类的全限定名,比如</span></span><br><span class="line">        <span class="comment">//tech.aistar.design.factory.reflect.TeacherDaoImpl</span></span><br><span class="line">        <span class="comment">//获取class实例的方式</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(type);</span><br><span class="line">            <span class="comment">//反射调用空参构造</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Point p = (Point) c.newInstance();</span></span><br><span class="line">                t = (T) c.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><blockquote><p>java.lang.reflect.Method</p></blockquote><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>int getModifiers();<br>返回由该 method对象表示的字段的Java语言修饰符，作为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的 - 0</span></span><br><span class="line"><span class="comment">//public  -1</span></span><br><span class="line"><span class="comment">//private - 2</span></span><br><span class="line"><span class="comment">//protected - 4</span></span><br></pre></td></tr></table></figure></li><li><p>Class&lt;?&gt; getReturnType();//返回方法的返回类型</p></li><li><p>String getName();//方法的名称</p></li><li><p>Class&lt;?&gt;[] getParameterTypes();//返回方法的参数列表.</p></li><li><p>Object invoke(Object obj,Object… args);//反射调用方法</p></li><li><p>void setAccessible(boolean on);//调用私有方法需要调用之前来设置可见性 - true</p></li></ol></blockquote><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><blockquote><p>java.lang.reflect.Array - <code>Array</code>类提供静态方法来动态创建和访问Java数组 - <strong>反射技术操作java数组</strong></p><p>面试题 - <strong>Arrays和Array的区别!</strong></p><p>java.util.Arrays - 数组工具类.</p></blockquote><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><blockquote><ol><li><p>static int getLength(Object array)<br>返回指定数组对象的长度，如 int 。</p></li><li><p>static Object get(Object array, int index)<br>返回指定数组对象中的索引组件的值。</p></li><li><p>static Object newInstance(Class&lt;?&gt; componentType, int length)<br>创建具有指定组件类型和长度的新数组。</p></li><li><p>static void set(Object array, int index, Object value)<br>将指定数组对象的索引组件的值设置为指定的新值。</p></li></ol></blockquote><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射操作java数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 1:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr1 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;java&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;db&quot;</span>,<span class="string">&quot;web&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用一个方法,来遍历上面俩个不同元素类型数组</span></span><br><span class="line">        <span class="comment">//反射技术来遍历数组</span></span><br><span class="line">        printArr(arr1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====华丽丽的分割线====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printArr(arr2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===反射动态创建数组===&quot;</span>);</span><br><span class="line">        <span class="comment">//对任何元素类型的数组,都可以进行扩容操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 确定新的数组的长度 - 原来数组的长度+扩容长度[反射创建新的数组]</span></span><br><span class="line">        <span class="comment">//2. 读取原来数组中的每个下标的数据[反射读取]一一复制到新的数组中[反射设置值]</span></span><br><span class="line">        <span class="comment">//3. 返回类型确定[扩容之后的] - Object</span></span><br><span class="line">        Integer[] temp = (Integer[]) extendsArr(arr1);</span><br><span class="line">        printArr(temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">        String[] strTemp = (String[]) extendsArr(arr2);</span><br><span class="line">        printArr(strTemp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组的扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">extendsArr</span><span class="params">(Object arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建数组必不可少的俩个条件.a. 数组的元素类型  b.数组的长度</span></span><br><span class="line">        <span class="comment">//获取旧数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = Array.getLength(arr);</span><br><span class="line">        <span class="comment">//确定新的数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> newLen = len*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取原来数组的组件的类型 - 数组的元素类型</span></span><br><span class="line">        Class&lt;?&gt; type = arr.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 反射创建新的数组了</span></span><br><span class="line">        Object newArr = Array.newInstance(type,newLen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 把arr旧数组中的元素拷贝新的数组中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//根据下标获取值</span></span><br><span class="line">            Object o = Array.get(arr,i);</span><br><span class="line">            <span class="comment">//把o设置到newArr数组的下标i处</span></span><br><span class="line">            Array.set(newArr,i,o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射访问</span></span><br><span class="line">    <span class="comment">//Integer[] String[] - 数组 - extends Object</span></span><br><span class="line">    <span class="comment">//并不是extends Object[]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(Object arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = Array.getLength(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历这个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//反射的技术通过下标去取元素</span></span><br><span class="line">            Object obj = Array.get(arr,i);</span><br><span class="line"></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><blockquote><p>只要了解即可.jdk5.0开始引入了注解的机制.</p><p>现在框架的配置,框架的使用 - 1. 基于xml的配置方式 2. 基于注解的配置/开发方式 - 简洁</p><p>学习注解的目的是为了以后能够知道我们框架的使用中遇到注解,知道这个注解背后是个大概什么底层即可.</p></blockquote><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><blockquote><ul><li><p>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p></li><li><p>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</p></li><li><p>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</p><p>@SuppressWarnings(“all”) - 抑制所有的警告</p></li><li><p>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</p></li></ul></blockquote><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote><ol><li><p>使用@interface来修饰注解,自定义的注解默认都会继承java.lang.Annotation</p></li><li><p><strong>@Target - 指定你这个注解可以在什么地方被使用</strong></p><p>哪些地方 - 类,方法,参数,接口,局部变量上,属性,构造</p><p>值可以设置成枚举类型java.lang.annotation.ElementType中的枚举常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Retention(RetentionPolicy.RUNTIME)</p><p>可以在程序的运行过程中,通过反射的技术来得到注解的信息.</p></li><li><p><strong>注解中只有方法的概念,没有的属性的概念</strong></p></li></ol></blockquote><h2 id="反射获取注解的值"><a href="#反射获取注解的值" class="headerlink" title="反射获取注解的值"></a>反射获取注解的值</h2><blockquote><p><strong>有办法来判断类或者方法是否加入了注解</strong></p><p><strong>有办法通过反射技术来获取类/方法上加入注解的属性值</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射获取注解的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 2:39 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断某个类或者某个方法上是否有注解</span></span><br><span class="line">        <span class="comment">//有注解 - 标志 - 对这个有注解的类该干嘛干嘛...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注解还配置了属性值 - 需要取出属性值,然后再进行进一步的处理...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//类</span></span><br><span class="line">        Class&lt;?&gt; c = UseMyAnno.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 判断类上是否加入了MyAnno注解</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = c.isAnnotationPresent(MyAnno.class);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(c.getSimpleName()+<span class="string">&quot;加入了注解!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取注解的属性值 - 前提是有</span></span><br><span class="line">            MyAnno myAnno = c.getAnnotation(MyAnno.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取属性值</span></span><br><span class="line">            String[] arr = myAnno.value();</span><br><span class="line"></span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(c.getSimpleName()+<span class="string">&quot;上没有加入注解!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====方法上的注解的信息 - 反射技术===&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(m.isAnnotationPresent(MyAnno.class))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;方法上有注解!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                MyAnno myAnno = m.getAnnotation(MyAnno.class);</span><br><span class="line"></span><br><span class="line">                String[] arr = myAnno.value();</span><br><span class="line">                System.out.println(Arrays.toString(arr));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;方法上没有注解...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mybatis注解开发方法"><a href="#mybatis注解开发方法" class="headerlink" title="mybatis注解开发方法"></a>mybatis注解开发方法</h2><blockquote><p>mybatis底层使用到的是jdbc技术 - 和数据库打交道的技术</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jdbc步骤很繁琐,步骤比较多~</span><br><span class="line">打开</span><br><span class="line">Connection con = DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">String sql=<span class="string">&quot;delete from user&quot;</span>;</span><br><span class="line">PreparedStatement pstmt = con.prepareStatement(sql);</span><br><span class="line"> ResultSet rs = pstmt.executeQuery();</span><br><span class="line">关闭</span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure><blockquote><p>mybatis就是会对jdbc的代码进行一个封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>尝试走一遍mybatis作者的路线</code></p><p><code>自定义一个注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Select&#123;</span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注解本身是不会完成任何的业务逻辑的.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">通过反射的技术-&gt;select * from user</span><br><span class="line">  </span><br><span class="line">工具类&#123;</span><br><span class="line">  Connection con = DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    String sql=<span class="string">&quot;反射技术获取的&quot;</span>;</span><br><span class="line">    PreparedStatement pstmt = con.prepareStatement(sql);</span><br><span class="line">     ResultSet rs = pstmt.executeQuery();</span><br><span class="line">    关闭</span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第一阶段corejava总结"><a href="#第一阶段corejava总结" class="headerlink" title="第一阶段corejava总结"></a>第一阶段corejava总结</h1><blockquote><ol><li>JVM内存模型+<strong>GC算法</strong> - 面试必问</li><li><strong>静态代理和动态代理 - 设计模式</strong></li></ol></blockquote><h2 id="体系回顾"><a href="#体系回顾" class="headerlink" title="体系回顾"></a>体系回顾</h2><blockquote><ol><li><strong>part01-基础语法-数组的排重/排序算法/递归算[阶乘,杨辉,斐波那契数列]</strong></li><li><strong>part02</strong><ul><li><strong>封装,继承,多态</strong></li><li><strong>四种访问修饰符</strong></li><li><strong>static关键字,final,abstract修饰符</strong></li><li><strong>String,StringBuffer,StringBuilder</strong></li><li><strong>包装类型Integer - [IntegerCache缓冲区,-128~127]</strong></li><li><strong>设计模式 - 单例[双重锁检测]+工厂+模板+装饰器</strong></li><li><strong>Object - equals&amp;hashcode,clone,toString,wait,notify,notifyAll,finalize,getClass()</strong></li><li><strong>Date&amp;Calendar&amp;SimpleDateFormat&amp;BigInteger - 常用的内置的api</strong></li></ul></li><li><strong>part03 - 集合框架</strong><ul><li><strong>ArrayList&amp;LinkedList&amp;Vector</strong></li><li><strong>HashSet&amp;TreeSet</strong></li><li><strong>HashMap&amp;Properties</strong></li></ul></li><li><strong>多线程体系</strong></li><li><strong>反射+注解</strong></li></ol></blockquote><h1 id="第二阶段的知识点"><a href="#第二阶段的知识点" class="headerlink" title="第二阶段的知识点"></a>第二阶段的知识点</h1><blockquote><p><strong>周一之前 - mysql环境装好</strong></p></blockquote><blockquote><p>围绕数据库</p></blockquote><blockquote><ol><li>mysql学习 - 关系型数据</li><li>jdbc学习 - java和db进行交互的技术</li><li>myabtis框架学习 - 持久层技术,对jdbc的封装</li></ol></blockquote><blockquote><p> <em><strong>相关知识点 - mybatis-plus框架,redis - 非关系型数据</strong></em></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day15</title>
    <link href="http://example.com/2021/07/29/day15/"/>
    <id>http://example.com/2021/07/29/day15/</id>
    <published>2021-07-29T10:02:10.000Z</published>
    <updated>2022-01-07T09:05:45.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><blockquote><p>一个程序至少一个进程，一个进程至少一个线程。<code>线程不能单独执行运行的,它一定是运行在进程的内部的</code></p></blockquote><blockquote><ul><li><p>进程[正在执行中的应用程序]：是并发执行的<strong>程序在执行过程中分配和管理资源的基本单位</strong>，是一个动态概念，</p></li><li><p><em><strong>竞争计算机系统资源的基本单位</strong></em>。 - “多任务操作系统” - “多个进程在**”同时”**在运行” - CPU分配资源 - <strong>“分时分片”</strong></p><p><code>处理器[cpu]调度的基本单位</code></p></li><li><p>线程：<strong>是进程的一个执行单元</strong>，是进程内部调度实体。<strong>比进程更小的独立运行的基本单位</strong>。<strong>线程也被称为轻量级进程</strong>。</p><p><code>一个进程可以拥有多个线程的同一个进程内部的多个线程是可以共享进程资源的.</code></p></li></ul></blockquote><h2 id="比如启动Java程序"><a href="#比如启动Java程序" class="headerlink" title="比如启动Java程序"></a>比如启动Java程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 启动Java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言]</span><br><span class="line">   开启一个JVM进程 - jvm.exe[windows中的可执行文件.C语言写的程序直接编译成了.exe可执行文件]</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 当JVM进程启动之后,同时开启俩个线程 - 分别是main主线程以及一个GC线程[后台守护线程]</span><br><span class="line">   守护线程 - 如果后台只剩下守护线程在执行的时候,那么进程就会结束.</span><br><span class="line">   进程的结束不需要等到守护线程全部执行完才会结束.</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span> main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束</span><br><span class="line">   GC线程负责进行垃圾对象的回收</span><br></pre></td></tr></table></figure><h1 id="创建线程的传统的方式"><a href="#创建线程的传统的方式" class="headerlink" title="创建线程的传统的方式"></a>创建线程的传统的方式</h1><blockquote><ol><li><p>写一个类去继承java.lang.Thread类 - 重写里面的run方法</p></li><li><p>写一个类去实现java.lang.Runnable接口 - 重写里面的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要用到java.lang.Thread类中的构造方法</span><br><span class="line">Thread(Runnable r);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Thread和Runnable区别"><a href="#Thread和Runnable区别" class="headerlink" title="Thread和Runnable区别"></a>Thread和Runnable区别</h2><blockquote><ol><li><p>第一种方式extends Thread方式 - 共享代码,不共享资源</p><blockquote><p>只有将资源设置成静态的 - 也是进行一个资源的共享的</p></blockquote></li><li><p>第二种方式implements Runnable接口 - 共享代码,共享资源</p></li><li><p>第三种方式Callable接口</p><p>推荐配合Future+线程池一起使用</p></li></ol></blockquote><h2 id="Callable和Runnable接口的区别"><a href="#Callable和Runnable接口的区别" class="headerlink" title="Callable和Runnable接口的区别"></a>Callable和Runnable接口的区别</h2><blockquote><ol><li>Callable可以通过Future来得到异步计算的结果 - 拿到线程执行之后的结果.</li><li>Callable调用的是call方法,Runnable调用的是run方法.</li><li>call方法是可以抛出一个异常列表的,但是run方法是不允许抛出异常列表的</li></ol></blockquote><h3 id="Callable-FutureTask"><a href="#Callable-FutureTask" class="headerlink" title="Callable+FutureTask"></a>Callable+FutureTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 拿到线程执行之后的结果</span></span><br><span class="line"><span class="comment"> *             Callable+FutureTask -&gt; 线程执行的结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 8:40 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main-begin...&quot;</span>);</span><br><span class="line">        Callable&lt;Integer&gt; c = <span class="keyword">new</span> C1();</span><br><span class="line">        <span class="comment">//FutureTask - 异步任务</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(c);</span><br><span class="line">        <span class="comment">//利用异步任务来构建Thread对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        t.start();<span class="comment">//启动线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程已经启动了...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//拿线程计算的结果</span></span><br><span class="line">            <span class="comment">//get()方法一定是要等到线程执行结束之后 - 才会停止</span></span><br><span class="line">            System.out.println(<span class="string">&quot;result:&quot;</span>+task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main-end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            total+=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//故意模拟一个比较费时费力的任务</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> total;<span class="comment">//5050</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Callable-Future-线程池"><a href="#Callable-Future-线程池" class="headerlink" title="Callable+Future+线程池"></a>Callable+Future+线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: Callable+Future&lt;T&gt; + 缓存线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 8:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallablePoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建一个可缓存的线程池对象</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向这个缓存池中提交任务</span></span><br><span class="line">        <span class="comment">//第一个任务 - 负责计算1~100</span></span><br><span class="line">        Future&lt;Integer&gt; future1 = executorService.submit(<span class="keyword">new</span> C2());<span class="comment">// 准备启动一个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再向这个缓存池中提交一个任务</span></span><br><span class="line">        <span class="comment">//第二个任务 - 负责计算1~10</span></span><br><span class="line">        Future&lt;Integer&gt; future2 = executorService.submit(<span class="keyword">new</span> CC());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务的数量和线程的数量一定一样吗???</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有个效果 -&gt; 俩个线程 - 同时执行这俩个异步任务</span></span><br><span class="line">        <span class="comment">//pool-1-thread-1-正在计算1~100</span></span><br><span class="line">        <span class="comment">//pool-1-thread-2正在计算1~10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要将俩个线程执行的结果进行一个相加的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get()方法肯定是会等到线程执行完之后.才会继续走</span></span><br><span class="line">            Integer result1 = future1.get();</span><br><span class="line">            Integer result2 = future2.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果俩个线程get()方法不走完,那么main线程也是不会继续执行的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开始整合...&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = result1 + result2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//main线程</span></span><br><span class="line">            <span class="comment">//5050+55 = 5105</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(future1.get()+future2.get());</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-正在计算1~100&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            total += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在计算1~10&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            total+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的类和线程非安全的类"><a href="#线程安全的类和线程非安全的类" class="headerlink" title="线程安全的类和线程非安全的类"></a>线程安全的类和线程非安全的类</h2><blockquote><p>StringBuilder - 线程非安全的字符串类,StringBuffer - 线程安全的字符串类</p><p>ArrayList - 线程非安全的集合,Vector - 线程安全的集合</p><p>HashMap - 线程非安全的集合,Hashtable - 线程安全的集合</p><p><strong>以上线程安全的类 - api方法使用到了synchronized方法进行了修饰 - 在某个时刻,只能由一个线程去访问,其他线程都是出于等待状态</strong></p></blockquote><h2 id="Thread提供的常用方法"><a href="#Thread提供的常用方法" class="headerlink" title="Thread提供的常用方法"></a>Thread提供的常用方法</h2><blockquote><ol><li>static Thread currentThread();//返回当前正在执行的线程的引用对象</li><li>String getName();//返回线程的名称</li><li>void start();//启动线程,本质当t1.start()方法的时候底层会让JVM去启动线程,我们的程序是没有资格和能力去真正的把一个线程给启动起来的.  CPU调度JVM进程-调用t1线程.</li><li>void setName(String name);//给线程设置名称</li><li>void setPriority(int n);//设置线程的优先级,数字[1~10].注意点:数字越大,优先级越高.但是并不是优先级越高的线程就一定会优先执行.只是希望它先执行.最终还是要cpu的.</li><li>void setDaemon(boolean on);//设置成true,这个线程成为了一个后台守护线程了.</li></ol></blockquote><h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><blockquote><ol><li>Java语言的关键字，</li><li><strong>可用来给对象和方法或者代码块加锁</strong></li><li>当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候，<strong>同一时刻最多只有一个线程执行这段代码</strong> </li><li>当两个并发线程访问同一个<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1object/22817693">对象object</a>中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li><li>非公平锁</li><li>如果同步代码块中出现了异常,那么仍然还是会自动释放锁资源的</li></ol></blockquote><h2 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2><blockquote><p>在java中,<strong>每个对象有且仅有一个同步锁</strong>,并且同步锁是依赖于对象存在的.当我们调用对象的synchronized修饰的同步方法时候,就是获取了该对象的同步锁.</p></blockquote><blockquote><ol><li>修饰普通方法 - <strong>对象锁</strong> - 不同的对象拥有独立的”一把锁”,每个对象的”锁”是不冲突的 - “自助餐”</li><li>**修饰静态方法 - “类锁” - **作用于这个类下的所有的对象 - 这个类实例化出来的所有的对象竞争的是”同一把锁” - 类锁 - “一个桌子上”</li><li>修饰代码块synchronized(this) - 对象锁</li><li>修饰代码块(XXX.class) - <strong>“类锁”</strong></li></ol></blockquote><h2 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h2><blockquote><ol><li><p>原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所谓的原子性代表一个操作或者多个操作,要么执行全部并且执行的过程中不能被任何因素打断.要么就不执行.</span><br><span class="line">比如i++,i+=<span class="number">2</span>,i=i+<span class="number">1</span>;这些操作都不是原子操作[读取,计算,赋值].这三个步骤不是原子性 - 三个步骤中的任何一个步骤在执行的过程.</span><br><span class="line">其他都可能去打断它.</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;<span class="comment">//原子操作</span></span><br><span class="line">特殊的 - 了解即可</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">3.0d</span>或者<span class="keyword">long</span> x1 = <span class="number">20L</span> - 不具备原子性的.</span><br></pre></td></tr></table></figure></li><li><p>可见性</p><p><code>原因:遇到synchronized之后,清空本地工作内存,重新从主存去拷贝最新的值</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是可见的  </span><br></pre></td></tr></table></figure></li><li><p>有序性</p><blockquote><p>在同一个时刻,只能由一个线程进入.</p></blockquote></li><li><p>可重入性</p><blockquote><p>当一个线程申请到锁资源并且执行完毕之后[释放],仍然还有机会再去继续申请曾经申请过的锁资源.</p></blockquote></li></ol></blockquote><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><blockquote><p>JMM就是<strong>Java内存模型(java memory model - 不是JVM内存模型</strong></p><p>Java内存模型规定<strong>所有的变量都存储在主内存</strong>中，包括实例变量[类中的非静态属性]，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行</strong>。<strong>线程不能直接读写主内存中的变量</strong>。</p><p>不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。</p><p><img src="/2021/07/29/day15/jmm.jpeg"> </p></blockquote><p><img src="/2021/07/29/day15/jmm2.png">    </p><h2 id="描述i-过程-多线程安全问题"><a href="#描述i-过程-多线程安全问题" class="headerlink" title="描述i++过程 - 多线程安全问题"></a>描述i++过程 - 多线程安全问题</h2><blockquote><p>前提:</p><ol><li><p>线程是不能够操作对主存中的数据进行直接的操作的,必须是在本地的工作内存中去完成的.完成之后,刷回主存的</p></li><li><p><strong>线程之间是隔离的</strong>.每个线程去执行方法的时候,都会在本地开辟一块区域[栈帧 - 线程栈],每个线程在本地工作内存中</p><p>对资源的修改,那么这个资源的信息,状态对其他线程都是不可见的.</p></li></ol></blockquote><p><code>add方法没有使用synchronized进行修饰的流程</code></p><p><code>脏数据</code> - 本地工作内存中的变量的数据和主存中的变量的数据的值已经不一样,违背了”JMM中的缓存一致性”的原则.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">i++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断</span><br><span class="line">①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=<span class="number">0</span>)      =&gt; T1</span><br><span class="line">  `T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=<span class="number">0</span>)`   =&gt; T0</span><br><span class="line">          `T0线程直接进行了计算,赋值,重新刷回到主存[i=<span class="number">1</span>]`   =&gt; T0</span><br><span class="line">    `T0线程刷回i到主存之后,此时主存的i=<span class="number">1</span>,T0线程让出cpu执行权` </span><br><span class="line">②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i   =&gt; T1</span><br><span class="line">  `T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本`</span><br><span class="line">  `所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是<span class="number">0</span>]`</span><br><span class="line">  `T1线程i = i + <span class="number">1</span>,刷回到主存[i=<span class="number">1</span>]`</span><br><span class="line">  `因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`</span><br><span class="line">③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存]  =&gt; T1</span><br><span class="line">  [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中</span><br><span class="line">   获取变量的副本,重复执行①②③)</span><br><span class="line">  </span><br><span class="line">隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的</span><br><span class="line">   </span><br><span class="line">看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了<span class="number">1</span>次的结果.</span><br></pre></td></tr></table></figure><h3 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h3><blockquote><p>使用synchronized对i++所在的方法进行修饰.</p><p>当某个对象调用add方法,得到锁资源的时候,会先<strong>清空</strong>本地工作内存.清空的目的是为了让后面的操作重新从主存中拷贝最新的值.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻,只能由一个线程[获得锁资源的]进去执行</li><li>[<strong>读取,计算,赋值</strong>] - 三个步骤中.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞.</li><li>当正在执行的线程释放锁资源之前,它会将本地工作内存中的改变刷回到主存.</li></ol></blockquote><h2 id="什么时候工作内存中的改变会同步到主存中"><a href="#什么时候工作内存中的改变会同步到主存中" class="headerlink" title="什么时候工作内存中的改变会同步到主存中"></a>什么时候工作内存中的改变会同步到主存中</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><blockquote><ol><li>当前的单线程执行方法结束的时候</li></ol></blockquote><p>###多线程</p><blockquote><ol><li>线程释放锁资源的时候</li><li>线程切换</li></ol></blockquote><h1 id="分析可见性代码"><a href="#分析可见性代码" class="headerlink" title="分析可见性代码"></a>分析可见性代码</h1><h2 id="先写再读"><a href="#先写再读" class="headerlink" title="先写再读"></a>先写再读</h2><blockquote><p>读线程为什么可以终止循环.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果先写后读</span></span><br><span class="line">t1.start(); <span class="comment">//x=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的睡一秒,已经足够让我们的写线程把x=5的最终结果刷回到主存了呀</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t2.start();<span class="comment">//发现x变成了5</span></span><br></pre></td></tr></table></figure></blockquote><p><img src="/2021/07/29/day15/write.png"> </p><h2 id="先读再写"><a href="#先读再写" class="headerlink" title="先读再写"></a>先读再写</h2><blockquote><p>多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是不可见的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果先读后写</span></span><br><span class="line">t2.start();<span class="comment">//读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1.start();<span class="comment">//写</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/29/day15/read.png"> </p><h2 id="synchronized深入"><a href="#synchronized深入" class="headerlink" title="synchronized深入"></a>synchronized深入</h2><blockquote><p>特点 - 对象重新获得锁资源的时候,会先清空本地工作内存.强制从主存中去拷贝已经更新的变量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">先读再写,仅仅是在循环体中添加了一行代码 </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readX</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//写线程过了许久之后,x=5的改变刷回到主存</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//但是读线程在执行循环 - 循环体中出现了同步代码块 - 遇到synchronized</span></span><br><span class="line">  <span class="comment">//一旦遇到synchronized - 尝试去获取锁资源 - 会清空本地工作内存[把x清空掉了]</span></span><br><span class="line">  <span class="comment">//继续循环又会使用到x,由于本地工作内存已经清空了呀,所以读线程只能到主存中去强制再去拷贝一份x的变量到本地工作内存</span></span><br><span class="line">  <span class="comment">//拿到的肯定是写线程已经更新之后的那个值x=5</span></span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println();<span class="comment">//增加的代码 - read线程跳出了循环 - 发现了新的x,重新拷贝最新的x</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----stopped---&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>原因</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println()这个println方法的内部底层是 - 同步代码块 - <span class="function"><span class="keyword">synchronized</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">    trouble = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="如何保证可见性-解决方案"><a href="#如何保证可见性-解决方案" class="headerlink" title="如何保证可见性 - 解决方案"></a>如何保证可见性 - 解决方案</h2><blockquote><ol><li><p>使用synchronized来保证可见性</p></li><li><p>使用<strong>volatile来修饰实例变量</strong></p><p>作用1:强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去.</p><p>作用2:禁止指令重排的 - 单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">指令重排 - JVM指令优化之后</span><br><span class="line">①给对象分配空间</span><br><span class="line">②空间地址立即给s,s保存到栈</span><br><span class="line">③对象的初始化</span><br><span class="line">                 </span><br><span class="line"><span class="keyword">volatile</span> Student s = <span class="keyword">new</span> Student();<span class="comment">//禁止指令重排</span></span><br><span class="line">①给对象分配空间</span><br><span class="line">③对象的初始化</span><br><span class="line">②空间地址立即给s,s保存到栈</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h1><blockquote><ol><li><p>保证可见性</p></li><li><p>volatile是不会造成阻塞的</p></li><li><p>禁止指令重排</p></li><li><p>不能保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//i对于俩个线程而言都是可见的.主存中一旦改变了.另外一个线程肯定就能够&quot;看到&quot; - 自己会强制再去重新拷贝 //一份到本地缓存中</span></span><br><span class="line">               </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  add();</span><br><span class="line">&#125;</span><br><span class="line">               </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">               </span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">               </span><br><span class="line"><span class="comment">//诱导 - </span></span><br><span class="line"><span class="comment">//强制让程序遵守&quot;缓存一致性&quot;协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去.</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//最终的i出来的结果&lt;200000 -&gt; 不能保证原子性</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//t1执行到最后一步,在自己的工作内存中已经计算结束了 ,i已经自增完毕,i=1&lt;---其他线程介入了----------&gt;但是还没有来得及刷回到主</span></span><br><span class="line">存.</span><br><span class="line">  t0线程直接计算完,i=<span class="number">1</span>,刷回到主存,结束</span><br><span class="line">                                        但是t1已经对i操作已经结束了,t1的内部已经不会再去操作i</span><br><span class="line">  只剩下最后一个动作-&gt;i=<span class="number">1</span>也会刷回到主存中</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h1><blockquote><ol><li><p>volatile只能作用于变量，而synchronized可以作用于变量、方法和代码块</p></li><li><p>多线程访问volatile不会发生阻塞，而synchronized关键字可能发生阻塞。</p></li><li><p><strong>volatile能够保证数据的可见性</strong>，就是在多个线程之间是可见的，<strong>不能保证原子性</strong>，而synchronized关键字都可以保证。</p></li><li><p>volatile关键字主要解决的是多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性。</p></li><li><p>volatile是可以禁止jvm指令重排的,但是synchronized是不能的.</p></li></ol></blockquote><h1 id="synchronized的底层原理"><a href="#synchronized的底层原理" class="headerlink" title="synchronized的底层原理"></a>synchronized的底层原理</h1><blockquote><p>了解即可</p></blockquote><blockquote><p><strong>每一个锁都对应一个monitor对象</strong>，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。</p></blockquote><p><img src="/2021/07/29/day15/monitor.png"> </p><h1 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h1><blockquote><p>线程是存在于进程内部的.一个进程内部可以拥有多个线程的.</p></blockquote><blockquote><ol><li><p>地址空间：同一进程的线程共享本进程的地址空间，而<strong>进程之间则是独立的地址空间。</strong></p><p><strong>进程与进程之间是独立的.</strong> <strong>同一个进程内部的多个线程是可以共享进程资源的.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如:没有国[进程]就没有家[线程]</span><br><span class="line">  </span><br><span class="line">   家[进程] - 拥有多个家庭成员的[线程]</span><br></pre></td></tr></table></figure></li><li><p>资源拥有：同一进程内的<strong>线程共享本进程的资源</strong>，但是<strong>进程之间的资源是独立的。</strong></p></li><li><p>一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>。<strong>所以多进程要比多线程健壮。</strong></p></li><li><p><strong>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时</strong>，<strong>使用线程要好于进程</strong>。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</p><p>-<em><strong>进程重量级的单位</strong>(创建,切换,销毁 - 费时)</em></p><p>*-**线程轻量级的单位(*<em>创建,切换,销毁 - 比较高)</em></p></li><li><p><strong>线程是处理器调度的基本单位，但是进程不是。</strong></p><p><strong>程序在执行过程中分配和管理资源的基本单位</strong> - 系统是把资源[内存]分给给进程,这个进程内部的线程才会去共享进程得到的这些资源.</p></li><li><p><strong>两者均可并发执行。</strong>   </p></li></ol><p><strong>一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程</strong>资源分配给进程，同一进程中所有线程共享该进程的所有资源。</p></blockquote><h1 id="线程状态-线程生命周期"><a href="#线程状态-线程生命周期" class="headerlink" title="线程状态 - 线程生命周期"></a>线程状态 - 线程生命周期</h1><p><img src="/2021/07/29/day15/thread_status.png"> </p><blockquote><p><strong>简介:线程的生命周期.</strong></p><ol><li><p>New：<strong>新建状态</strong>/<strong>瞬态</strong>，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread()</p></li><li><p>Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，<strong>只是说明此线程已经做好了准备，随时等待cpu调度执行</strong>，并不是说执行了t.start()此线程立即就会执行</p></li><li><p>Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</p></li><li><p>Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态</p></li><li><p>Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期</p></li></ol></blockquote><blockquote><p>（1）就绪状态是进入到运行状态的唯一入口<br>（2）线程想要进入到运行状态执行，首先必须处于就绪状态中<br>（3）根据阻塞产生的原因，阻塞状态又可以分为三种：<br>    【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态<br>    【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态<br>    【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入.</p></blockquote><h1 id="作业-synchronized"><a href="#作业-synchronized" class="headerlink" title="作业-synchronized"></a>作业-synchronized</h1><blockquote><p>Account(id,accno,balance=100) - “临界资源” - “多个线程需要竞争的共享 - 多个线程需要操作的同一个对象”</p><p>写一个线程类 - 同步方法[取钱-10] - 一定是只能在某个时刻只能由一个线程进去执行</p></blockquote><blockquote><p>创建俩个线程对象 - 老公和老婆 -&gt; 调用同步取钱的方法</p><ol><li><p>无论哪个线程在执行 - 100 - 90 - 80 - …. 0</p></li><li><p>效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">老公正在取钱....余额为:<span class="number">90</span></span><br><span class="line">老公正在取钱....余额为:<span class="number">80</span></span><br><span class="line">老公正在取钱....余额为:<span class="number">70</span></span><br><span class="line">老婆正在取钱....余额为:<span class="number">60</span></span><br><span class="line">老公正在取钱....余额为:<span class="number">50</span></span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">   <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><blockquote><p>GC - 运行在后台的 - 负责回收垃圾对象的.</p><p>核心:线程结束的时候不需要关心后台的守护线程是否也运行结束.线程是不会等后台的守护线程全部运行结束才结束.</p><p>当后台只有守护线程在执行的时候,就可以认为线程可以结束了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 后台的守护线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 9:03 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将打印数字的线程 - 设置成后台守护线程</span></span><br><span class="line">        <span class="comment">//如果后台只剩下守护线程在执行 - 可以结束了.</span></span><br><span class="line">        <span class="comment">//不需要等待所有的守护线程运行结束才结束.</span></span><br><span class="line">        t2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果t1和t2都不是守护线程 - main线程一定是等待俩个线程全部执行完之后,才会结束</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">65</span>; i &lt;=<span class="number">90</span> ; i++) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Lock-同步代码"><a href="#Lock-同步代码" class="headerlink" title="Lock - 同步代码"></a>Lock - 同步代码</h1><p>简介:它是一个接口,下面有很多实现类,<em><strong>笔试题lock和synchronized的区别!</strong></em></p><ul><li>lock是接口,synchronized它是一个关键字</li><li><strong>lock锁是一个显示</strong>锁(手动申请锁,手动释放锁),synchronized隐式锁(自动申请/释放锁)</li><li>lock手动申请锁**(对象锁)**</li><li><strong>lock是锁代码块</strong></li><li>lock出现异常的时候,是不会主动释放资源的.</li></ul><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: Lock同步代码 - 同步代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             申请的是对象锁 - 相同的对象才会去竞争一把锁.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             如果出现了异常 - 是不会主动释放锁的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 1:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockHelloDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建lock对象 - 接口</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//begin..</span></span><br><span class="line">            <span class="comment">//多个线程就会去竞争&quot;锁资源&quot;</span></span><br><span class="line">            lock.lock();<span class="comment">//手动申请&quot;锁资源&quot; - 显示锁</span></span><br><span class="line">            <span class="comment">//在某个时刻只能由一个线程进入去执行...</span></span><br><span class="line">            <span class="comment">//同步代码开始</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//sleep如果出现同步代码中,它并不会释放锁资源,只会让出cpu时间片段</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line">            <span class="comment">//end...</span></span><br><span class="line">            <span class="comment">//同步代码结束</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//手动释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockHelloDemo hello = <span class="keyword">new</span> LockHelloDemo();</span><br><span class="line">        <span class="comment">//1. 创建第一个线程对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            hello.add();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            hello.add();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面试题-synchronized和Lock有什么区别？"><a href="#面试题-synchronized和Lock有什么区别？" class="headerlink" title="面试题-synchronized和Lock有什么区别？"></a>面试题-synchronized和Lock有什么区别？</h1><blockquote><p>synchronized和lock都是属于独占锁.</p></blockquote><blockquote><ul><li><p>实现层面不一样。synchronized 是 Java 关键字，JVM层面 实现加锁和释放锁；Lock 是一个接口，在代码层面实现加锁和释放锁</p></li><li><p>是否自动释放锁。synchronized 在线程代码执行完或出现异常时自动释放锁；Lock 不会自动释放锁，需要再 finally {} 代码块显式地中释放锁</p></li><li><p>是否一直等待。<strong>synchronized 会导致线程拿不到锁一直等待</strong>；<strong>Lock 可以设置尝试获取锁或者获取锁失败一定时间超时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock接口中提供的方法</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;<span class="comment">//手动上锁</span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;<span class="comment">//如果获取锁失败 - 直接返回false,如果获取锁成功,返回true</span></span><br><span class="line"> <span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>;<span class="comment">//如果在尝试获取锁的过程中等待超过了time,那么就会导致获取锁失败</span></span><br></pre></td></tr></table></figure></li><li><p>获取锁成功是否可知。synchronized 无法得知是否获取锁成功；Lock 可以通过 tryLock 获得加锁是否成功</p></li><li><p>功能复杂性。synchronized 加锁可重入、不可中断、非公平；Lock 可重入、可中断、可公平和不公平、细分读写锁<strong>提高效率</strong></p><blockquote><p>读锁 - java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock - 共享锁 - 允许多个线程去读.</p><p>写锁 - java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock - 互斥锁 - 一次只能由一个线程去写.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不可中断<span class="keyword">synchronized</span>  - A线程竞争到锁资源 - 顺利进入同步代码块执行 - 只要A资源不释放这个锁资源.B线程只能在外面等待.</span><br><span class="line">      </span><br><span class="line">可中断Lock -&gt; A线程顺利执行同步代码,B线程如果tryLock方法话,那么B线程不断尝试获取锁资源.如果设置了超时等待时间.B线程等太久.已经超过了设置的时间.B线程将不会再傻乎乎继续等待下去[可中断],B线程就有可能去干别的事情了.</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>乐观锁,<strong>悲观锁[synchronized]</strong> - 数据库的时候</p><p>互斥锁 - synchronized和lock</p><p>读写锁</p><p><strong>锁升级</strong> </p><p><strong>锁粗化</strong></p><p>偏向锁</p><p>分布式锁</p></blockquote><h2 id="线程的通信-重点"><a href="#线程的通信-重点" class="headerlink" title="线程的通信 - 重点"></a>线程的通信 - 重点</h2><blockquote><p>同程公司笔试题 - 循环打印abc <strong>ABC</strong> 123 abc  ABC 123</p><p>打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程</p><ol><li><p>保证必须按照上面的顺序进行输出 - synchronized - wait和notify/notifyAll不能解决原因是<code>notify随机唤醒,notifyAll唤醒所有</code></p></li><li><p>使用Lock中的同步队列 - 解决方案 - <strong>唤醒指定的等待队列上的某个线程.</strong></p><p>Lock接口中提供的构建等待队列的方法 -  Condition newCondition();</p><p>Contion提供的关于线程通信的俩个方法 - 出现在同步代码内部 - lock()-&gt;unlock()内部</p><blockquote><ol><li>void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的</li><li>void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒</li></ol></blockquote></li><li><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.lock;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 同程公司笔试题 - 循环打印abc ABC 123 abc  ABC 123</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用Lock中的同步队列 - 解决方案 - **唤醒指定的等待队列上的某个线程.**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 2:29 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTongxinDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//有几个线程,就构建几个队列</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//打印小写字母的</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="comment">//打印大写字母的</span></span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="comment">//打印数字的</span></span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//定义了一个标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//count = 0,打印小写字母的执行</span></span><br><span class="line">    <span class="comment">//count = 1,打印大写字母的执行</span></span><br><span class="line">    <span class="comment">//count = 2,打印数字的执行</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//1. void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的</span></span><br><span class="line">    <span class="comment">//2. void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLower</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    <span class="comment">//一开始,第一次count=0,说明打印小写字母的线程正常执行</span></span><br><span class="line">                    c1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">                c2.signal();<span class="comment">//唤醒打印大写字母的线程</span></span><br><span class="line">      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        c2.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count=<span class="number">2</span>;</span><br><span class="line">                c3.signal();</span><br><span class="line">      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">2</span>)&#123;</span><br><span class="line">                    c3.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="number">123</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                c1.signal();</span><br><span class="line">      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTongxinDemo demo = <span class="keyword">new</span> LockTongxinDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printLower();</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printUpper();</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printNum();</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="面试题-常用方法区别"><a href="#面试题-常用方法区别" class="headerlink" title="面试题 - 常用方法区别"></a>面试题 - 常用方法区别</h1><blockquote><p><strong>wait方法和sleep方法的区别?</strong></p><p>a. wait方法一定是出现在synchronized同步代码内部的.[sleep是可以放在同步/不同步的代码内部的]</p><p>b. <strong>wait方法,执行这个方法的线程就会释放锁,释放cpu.但是sleep是不会释放锁的.只是释放了cpu</strong> - 核心的区别</p><p>c. sleep - 线程会自动进入到阻塞状态[其他阻塞状态],一旦睡眠时间结束.会自动从阻塞状态恢复到可就绪态 - 等到cpu到来 - 运行态.</p><p>​    wait - 线程会自动进入到等待阻塞状态,自己不会主动”醒过来”,必须是其他线程调用notify或者notifyAll,进入到锁定状态[再次尝试                去获取锁]</p></blockquote><blockquote><ol><li>sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</li></ol></blockquote><blockquote><ol start="2"><li>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</li></ol></blockquote><blockquote><ol start="3"><li>wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</li></ol></blockquote><blockquote><ol start="4"><li><p>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line">         </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> * join：一种特殊的wait[等待]，当前运行线程[mother]调用另一个线程[son]的join方法，</span></span><br><span class="line"><span class="comment"> * 当前线程[mother]进入阻塞状态直到另一个线程[son]运行结束等待该线程终止。</span></span><br><span class="line"><span class="comment"> * 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 9:21 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mother = <span class="keyword">new</span> Mother();</span><br><span class="line">        mother.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈正在做饭...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈发现酱油了...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈让熊孩子打酱油...&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//应该是希望儿子的线程介入进来了吧...</span></span><br><span class="line">        Thread son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.start();<span class="comment">//启动儿子线程</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//希望妈妈的线程先暂停一下,然后等儿子的线程跑完,妈妈的线程才继续跑.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            son.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//期望的是这条语句一定是出现在最后的...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈可以继续做饭了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;熊孩子接到任务...屁颠颠打酱油去了...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;熊孩子还有&quot;</span>+i+<span class="string">&quot;分钟就回来了...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;熊孩子把酱油打回来了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h1><blockquote><p><strong>wait</strong>：<strong>Object类的方法(notify()、notifyAll())，</strong>必须放<strong>在循环体</strong>和<strong>同步代码块中</strong>，执行该<strong>方法的线程会释放锁</strong>，</p><p>进入<strong>线程等待池中</strong>等待被再次唤醒(<strong>notify随机唤醒，notifyAll全部唤醒</strong>，线程结束自动唤醒)即放入锁池中竞争同步锁</p></blockquote><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><blockquote><p>单个生产者和单个消费者 </p><p>生产者线程 - 负责生产产品-box[把产品放入到box]</p><p>消费者线程 - 负责消费产品-box[从box中去获取产品]</p><p>通信的流程</p><ol><li><p>俩条线程并发执行 - 调用的是不同的方法</p></li><li><p>假设消费者线程先执行 - 直接从box中去获取产品.但是此时此刻box中尚无产品.</p><p>消费者线程就需要调用<strong>wait方法 - 自己会释放锁资源</strong>,消费者线程进入到线程等待池[意味着当前的线程会进入到等待阻塞的状态]</p><p>-getter方法</p></li><li><p>假设生产者线程 - setter方法</p><p>先执行了.发现box中没有产品的,顺利放入一个产品到box中的.但是放完之后.生产者还是会继续执行.继续执行的时候又会调用</p><p>setter方法.这个时候,不能允许生产者线程连续再放 - 就得调用<strong>生产者线程的wait方法</strong>,同时还需要唤醒消费者线程过来消费.</p></li><li><p>消费者线程一旦消费成功,它还是会继续执行自己的getter方法.发现box中没有了.回到第2个步骤</p></li></ol></blockquote><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 线程之间的通信 - 生产者和消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 效果是:必须是生产者线程先进去执行.</span></span><br><span class="line"><span class="comment"> *       放1个</span></span><br><span class="line"><span class="comment"> *       取1个</span></span><br><span class="line"><span class="comment"> *       放2个</span></span><br><span class="line"><span class="comment"> *       取2个</span></span><br><span class="line"><span class="comment"> *       放3个</span></span><br><span class="line"><span class="comment"> *       取3个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       一次性放,一次性取.</span></span><br><span class="line"><span class="comment"> *       不能连续出现俩次放/取.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 9:55 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTongXinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//典型的不共享代码,但是共享资源.</span></span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        Thread product = <span class="keyword">new</span> ProductThread(box);</span><br><span class="line">        Thread customer = <span class="keyword">new</span> CustomerThread(box);</span><br><span class="line"></span><br><span class="line">        product.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        customer.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        product.start();</span><br><span class="line"></span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个临界资源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> content;<span class="comment">//产品</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设的是是要调用getter方法 - 消费了 - box中没有东西了.</span></span><br><span class="line">    <span class="comment">//如果box中有东西 - 刚生产完,flag为true</span></span><br><span class="line">    <span class="comment">//如果box中没有东西 - 刚消费完 - flag为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;<span class="comment">//标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者线程去调用的</span></span><br><span class="line">    <span class="comment">//线程通信的方法wait,notify,notifyAll方法必须存在于循环体的同步方法中.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//box中是有东西的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//一旦调用wait方法之后,线程会释放锁.并且会自动进入到线程等待池中</span></span><br><span class="line">            <span class="comment">//进入到一个阻塞的状态.</span></span><br><span class="line">            <span class="comment">//它自己是不会主动被唤醒的.必须由其他线程调用notify或者notifyAll才能够</span></span><br><span class="line">            <span class="comment">//notify - 随机唤醒线程等待池中的一个线程</span></span><br><span class="line">            <span class="comment">//notifyAll - 唤醒所有的等待的线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();<span class="comment">//为了防止生产者线程连续执行..</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者顺利去执行.</span></span><br><span class="line">        <span class="comment">//设置flag</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知一下消费者来消费.消费者很有可能已经处于等待阻塞的状态.</span></span><br><span class="line">        notifyAll();<span class="comment">//唤醒全部等待阻塞的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程去调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//1. 保证消费者第一次执行,肯定会进来</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();<span class="comment">//释放锁,自己是不会主动&quot;醒过来的&quot;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;<span class="comment">//消费完了...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒一下生产者</span></span><br><span class="line">        notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义生产者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//产品</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductThread</span><span class="params">(Box box)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不断去生产</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;放&quot;</span>+(++i)+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">            box.setContent(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个消费者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerThread</span><span class="params">(Box box)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;取&quot;</span>+box.getContent()+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁-笔试题"><a href="#死锁-笔试题" class="headerlink" title="死锁 - 笔试题"></a>死锁 - 笔试题</h1><p><em><strong>“哲学家吃饭的问题”</strong></em></p><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程.</p><h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p><strong>1</strong>）<strong>互斥条件：</strong>指进程对所分配到的资源进行排它性使用，<strong>即在一段时间内某资源只由一个进程占用</strong>。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p><p><strong>2</strong>）<strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又<strong>提出了新的资源请求</strong>，而<strong>该资源已被其它进程占有</strong>，此<strong>时请求进程阻塞</strong>，但又对<strong>自己已获得的其它资源保持不放</strong>。</p><p><strong>3</strong>）<strong>不剥夺条件：</strong>指进程已获得的资源，<strong>在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</strong></p><p><strong>4</strong>）<strong>环路等待条件：</strong>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p><p><em><strong>只要打破四个条件的一个,就可以防止死锁.</strong></em></p><p><em><strong>死锁是不可避免,但是需要写程序的破坏四个条件中的一个.</strong></em></p><p><em><strong>静态域容易产生死锁.</strong></em></p><h1 id="四种常见的线程池-必考"><a href="#四种常见的线程池-必考" class="headerlink" title="四种常见的线程池 - 必考"></a>四种常见的线程池 - 必考</h1><p>线程池的返回值ExecutorService简介</p><p>ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：<strong>控制线程数量</strong>和<strong>重用线程</strong></p><ul><li>Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</li><li>Executors.newFixedThreadPool(int n)：创建一个<strong>可重用</strong>固定个数的线程池，以共享的无界队列方式来运行这些线程。</li><li>Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</li><li>Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><ol><li><p>Lock和Condition - 生产者和消费者的demo</p></li><li><p>编写俩个线程,一个线程用来计算2<del>100000之间的素数的个数.第二个线程用来计算1000000</del>200000之间的素数的个数</p><p>将俩个线程计算的结果相加.</p></li></ol></blockquote><h1 id="面试题-请你谈谈java-util-concurrent下的api的认识"><a href="#面试题-请你谈谈java-util-concurrent下的api的认识" class="headerlink" title="面试题 - 请你谈谈java.util.concurrent下的api的认识!"></a>面试题 - 请你谈谈java.util.concurrent下的api的认识!</h1><blockquote><p>主题 - 围绕线程池去问题了.</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day14</title>
    <link href="http://example.com/2021/07/28/day14/"/>
    <id>http://example.com/2021/07/28/day14/</id>
    <published>2021-07-28T10:02:10.000Z</published>
    <updated>2022-01-07T09:03:22.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型Generic"><a href="#泛型Generic" class="headerlink" title="泛型Generic"></a>泛型Generic</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ol><li>Java在1.5之后加入了泛型的概念。泛型，即“<strong>参数化类型</strong>”。</li><li>泛型的本质是为了参数化类型(<em><strong>将类型参数化传递</strong></em>)（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，<strong>操作的数据类型被指定为一个参数</strong>，</li><li>这种参数类型可以用在类、接口和方法中，分别被称为<strong>泛型类、泛型接口、泛型方法</strong>。</li><li>泛型只能是对象类型,比如User,Student,内置对象类型比如String,Integer[一定是包装类型]</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk5.0之前</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();<span class="comment">//集合中可以添加任意类型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk5.0开始~jdk7.0之前</span></span><br><span class="line"><span class="comment">//类型安全的集合框架</span></span><br><span class="line">List&lt;Integer&gt; list - <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//在编译期间确定了集合中添加的数据的类型,只能是Integer类型.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk7.0开始</span></span><br><span class="line"><span class="comment">//结论:泛型只有编译期间的概念,在运行期间将会被擦除.</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="泛型符号"><a href="#泛型符号" class="headerlink" title="泛型符号"></a>泛型符号</h2><blockquote><ol><li>E 元素</li><li>K,V - 键值对</li><li>N - 数字</li><li>T - 类型</li><li><strong>? - 通配符</strong></li></ol></blockquote><h2 id="为何要有泛型呢"><a href="#为何要有泛型呢" class="headerlink" title="为何要有泛型呢"></a>为何要有泛型呢</h2><blockquote><p>对别一下没有泛型,会导致什么结果.</p><blockquote><ol><li>加入了泛型之后,可以保证代码的<strong>健壮性</strong></li><li>加入了泛型之后,取值的时候,不需要进行强制类型的转换</li><li>加入了泛型之后,代码会变得更加简洁</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型的好处</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 9:05 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//jdk5.0之前</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();<span class="comment">//集合中可以添加任意类型的数据</span></span><br><span class="line">        list.add(<span class="number">10</span>);<span class="comment">//10-&gt;java.lang.Integer</span></span><br><span class="line">        list.add(<span class="string">&quot;ok&quot;</span>);<span class="comment">//字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有泛型的时候,获取集合中的元素 - 统计的返回类型都是Object类型</span></span><br><span class="line">        <span class="comment">//需要进行强制类型的转换.转换的过程中有可能会抛出java.lang.ClassCastException类型转换失败异常</span></span><br><span class="line">        <span class="comment">//在类型转换之前,建议先进行类型的判断,使用instanceof关键字</span></span><br><span class="line">        String ok = (String) list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdk7.0开始</span></span><br><span class="line">        <span class="comment">//一旦指定了泛型,add方法中的E成了String类型,返回类型也是String类型</span></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strList.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据下标获取 - 不需要进行类型的强制转换了.自动能够识别出返回类型就是你指定的那个泛型.</span></span><br><span class="line">        String result = strList.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="泛型只有编译期间的概念-在运行期间将会被擦除"><a href="#泛型只有编译期间的概念-在运行期间将会被擦除" class="headerlink" title="泛型只有编译期间的概念,在运行期间将会被擦除."></a>泛型只有编译期间的概念,在运行期间将会被擦除.</h2><blockquote><p>结论:泛型是没有多态的</p></blockquote><blockquote><ol><li><p>泛型只有编译期间的概念 - 泛型仅仅是在编译期间是有效的</p><p>在编译期间一旦确定了泛型,那么在编译期间就只能向这个容器中添加对应类型的数据.</p><p>否则编译报错.</p></li><li><p>运行期间将会被擦除 - 泛型是不存在运行时类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> tech.aistar.day05.User;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型只有编译期间的概念,在运行期间将会被擦除.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 9:16 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericRuntimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多态的语法 - 多态的应用</span></span><br><span class="line">        <span class="comment">//面向父类编程/面向接口编程</span></span><br><span class="line">        <span class="comment">//编译时类型 对象名 = new 运行时类型();</span></span><br><span class="line">        <span class="comment">//父类      对象   = new 子类();</span></span><br><span class="line">        <span class="comment">//接口      对象   = new 实现类();</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//java.lang.Integer extends java.lang.Number</span></span><br><span class="line">        <span class="comment">//java.lang.Long extends java.lang.Number</span></span><br><span class="line">        Number n1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        Number n2 = <span class="keyword">new</span> Long(<span class="number">20L</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//jdk5.0~jdk7.0之前</span></span><br><span class="line">        List&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//思考 - 编译是错误的</span></span><br><span class="line">        <span class="comment">//结论:泛型是没有多态的</span></span><br><span class="line">        <span class="comment">//原因:泛型只有编译期间的概念,在运行期间将会被擦除.</span></span><br><span class="line">        <span class="comment">//List&lt;Number&gt; numberList = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        List&lt;Long&gt; list02 = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//获取对象的运行时类型</span></span><br><span class="line">        <span class="comment">//忘记了 - java.lang.Object中的toString方法 getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode());</span></span><br><span class="line">        <span class="comment">//Class实例 - 别名:对象的运行时类型</span></span><br><span class="line">        Class&lt;?&gt; c1 = list01.getClass();</span><br><span class="line">        Class&lt;?&gt; c2 = list02.getClass();</span><br><span class="line">        System.out.println(c1 == c2);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//结论:获取运行时类型始终都是ArrayList,和&lt;Integer&gt;和&lt;Long&gt;是无关的</span></span><br><span class="line">        <span class="comment">//所以泛型仅仅是在编译期间有效,但是在运行期间是无效的[将会被擦除,将会失效]</span></span><br><span class="line">        System.out.println(c1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">        System.out.println(c2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//结论:一个类无论被实例化多少次,它在JVM中的Class对象/实例永远只有1个</span></span><br><span class="line"><span class="comment">//        User user1 = new User();</span></span><br><span class="line"><span class="comment">//        System.out.println(user1.getClass());//class tech.aistar.day05.User</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        User user2 = new User();</span></span><br><span class="line"><span class="comment">//        System.out.println(user2.getClass());//class tech.aistar.day05.User</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(user1.getClass() == user2.getClass());//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><blockquote><ol><li><p>**? extends T - 只能是T类型或者T类型的子类 **- 指定类型的上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 问号的通配符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 9:45 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildCardDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只能添加添加null</span></span><br><span class="line"><span class="comment">//        List&lt;?&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        //list.add(10);//error</span></span><br><span class="line"><span class="comment">//        //list.add(&quot;ok&quot;);//error</span></span><br><span class="line"><span class="comment">//        list.add(null);//ok</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        intList.add(<span class="number">10</span>);</span><br><span class="line">        intList.add(<span class="number">20</span>);</span><br><span class="line">        intList.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        longList.add(<span class="number">100L</span>);</span><br><span class="line">        longList.add(<span class="number">200L</span>);</span><br><span class="line">        longList.add(<span class="number">300L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//能否定义一个方法,能够打印上面俩个集合</span></span><br><span class="line">        printList(intList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printList(longList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型是不存在多态的.</span></span><br><span class="line">    <span class="comment">//假设认为是List&lt;Number&gt; list = new ArrayList&lt;Long&gt;();//error</span></span><br><span class="line">    <span class="comment">//Integer和Long都是extends Number</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//? extends T - 只能是T类型或者T类型的子类 - 指定类型的上限</span></span><br><span class="line">    <span class="comment">//? super T - 只能是T类型或者T类型的父类 - 指定类型的下限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;? extends Number&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//推荐使用集合的迭代器</span></span><br><span class="line">        <span class="comment">//获取集合的迭代器对象</span></span><br><span class="line">        Iterator&lt;? extends Number&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            <span class="comment">//Integer,Long -&gt; extends-&gt;Number-&gt;多态的语法</span></span><br><span class="line">            Number result = iter.next();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>? super T - 只能是T类型或者T类型的父类</strong> - 指定类型的下限</p></li></ol></blockquote><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><blockquote><p>定义类的时候,给定一个泛型,真正使用的时候,再确定具体的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 10:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> T type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClassDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将类型参数化传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClassDemo</span><span class="params">(T type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将类型参数化传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(T type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试泛型类</span></span><br><span class="line">        GenericClassDemo&lt;String&gt; c1 = <span class="keyword">new</span> GenericClassDemo&lt;&gt;(<span class="string">&quot;python&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.setType(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String result = c1.getType();</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===华丽丽的分割线===&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GenericClassDemo&lt;Integer&gt; c2 = <span class="keyword">new</span> GenericClassDemo&lt;&gt;();</span><br><span class="line">        c2.setType(<span class="number">10</span>);</span><br><span class="line">        System.out.println(c2.getType());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><blockquote><p>如果泛型加在类上面,对整个类内部的泛型的地方都会有影响</p><p><strong>可能某个类中就那么几个方法需要使用到泛型</strong>,没有必要定义泛型类,只需要<strong>定义泛型方法</strong>即可.</p><p><strong>如果若干个很多个方法都使用到了泛型,有必要定义一个泛型类.</strong></p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 10:17 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法 - 无返回类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01...&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法 - 带返回类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">test02</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;e:&quot;</span>+e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;N&gt; <span class="function">N <span class="title">test03</span><span class="params">(N n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;n:&quot;</span>+n);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethodDemo m = <span class="keyword">new</span> GenericMethodDemo();</span><br><span class="line">        <span class="comment">//如何确定到方法的参数T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM根据传入的方法的实参 - 拿到这个实参的类型 -&gt; 方法的参数T</span></span><br><span class="line">        m.test01(<span class="number">10</span>);<span class="comment">//Integer</span></span><br><span class="line"></span><br><span class="line">        m.test01(<span class="string">&quot;ok&quot;</span>);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用带有返回类型</span></span><br><span class="line">        String ok = m.test02(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        Integer t = m.test02(<span class="number">100</span>);</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">        <span class="comment">//泛型是类型安全的</span></span><br><span class="line">        Integer s = GenericMethodDemo.test03(<span class="number">12</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="泛型应用"><a href="#泛型应用" class="headerlink" title="泛型应用"></a>泛型应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream/ObjectOuputStream - 操作对象类型的字节文件输入流和对象类型的文件字节输出流</span><br><span class="line">  </span><br><span class="line">Object in.readObject()/out.writeObject(Object obj);</span><br><span class="line"></span><br><span class="line">Jdk没有对readObject方法进行优化,每次调用完之后,进行强制类型的转换操作的.</span><br><span class="line">  </span><br><span class="line">思考 - 无论是保存/读取User对象或者Book对象 - 用一个方法去实现</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day13.Book;</span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: IO流的工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 10:59 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法可以保存任意对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeList</span><span class="params">(List&lt;T&gt; list,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            out.writeObject(list);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法可以读取文件中的任意对象</span></span><br><span class="line">    <span class="comment">//语法如果定义成了一个泛型类,并且是静态方法的话,那么必须要把这个静态方法也设置成泛型方法</span></span><br><span class="line">    <span class="comment">//如果是定义成了一个泛型类,但是是普通方法的话,那么这个普通方法是不需要设置成泛型方法的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">readList</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            list = (List&lt;T&gt;) in.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUtilTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book b1 = <span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="number">100.0d</span>);</span><br><span class="line">        Book b2 = <span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">100.0d</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        books.add(b1);</span><br><span class="line">        books.add(b2);</span><br><span class="line">        String path = <span class="string">&quot;src/tech/aistar/util/content.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="comment">//IOUtil.writeList(books,path);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读</span></span><br><span class="line"><span class="comment">//        List&lt;Book&gt; list = IOUtil.readList(path);</span></span><br><span class="line"><span class="comment">//        if(null!=list &amp;&amp; list.size()&gt;0)&#123;</span></span><br><span class="line"><span class="comment">//            for (Book book : list) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(book);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Product p1 = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;macbook&quot;</span>);</span><br><span class="line">        Product p2 = <span class="keyword">new</span> Product(<span class="number">2</span>,<span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Product&gt; products = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        products.add(p1);</span><br><span class="line">        products.add(p2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//IOUtil.writeList(products,path);</span></span><br><span class="line"></span><br><span class="line">        List&lt;Product&gt; ps = IOUtil.readList(path);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=ps &amp;&amp; ps.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Product p : ps) &#123;</span><br><span class="line">                System.out.println(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型类的继承"><a href="#泛型类的继承" class="headerlink" title="泛型类的继承"></a>泛型类的继承</h1><blockquote><ol><li>子类不指定具体的类型</li><li>子类指定具体的类型</li></ol></blockquote><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型类的继承</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:34 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericExtendsDemo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sup</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类继承父类的时候,没有指定具体的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Sup</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类继承父类的时候,指定了具体的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub01</span>&lt;<span class="title">Product</span>&gt; <span class="keyword">extends</span> <span class="title">Sup</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型的具体应用"><a href="#泛型的具体应用" class="headerlink" title="泛型的具体应用"></a>泛型的具体应用</h1><blockquote><p>了解一下即可</p><p>场景:在接口的制定中.很多接口具有相同的或者类似的功能.比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dao层接口 - data access object - 数据访问对象层 - 数据持久层</span></span><br><span class="line"><span class="comment">//这一层专门和数据库[crud增删改查操作][文件_IO流操作]打交道</span></span><br><span class="line"><span class="comment">//教师的业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">  <span class="comment">//保存教师</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Teacher teacher)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line">   <span class="comment">// 保存学生</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再去写俩个具体的实现类分别是TeacherDaoImpl.java以及StudentDaoImpl.java</span></span><br><span class="line"><span class="comment">//这俩个实现类中 - 具体的代码,现阶段知识点 - 把单个java对象保存到文件中[IO流技术].</span></span><br><span class="line"><span class="comment">//未来 - 肯定是要把java对象保存到db中 - 持久化的操作[java内存中的对象保存到DB中]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关于dao层 - java如何操作数据库 - 原生技术jdbc,dao层框架 - Hibernate框架以及mybatis框架</span></span><br><span class="line"><span class="comment">//比如现在选取的是所谓的Hibernate框架</span></span><br></pre></td></tr></table></figure><p><code>Hibernate框架来把java的内存对象保存到DB中</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">session.save(user);<span class="comment">//具体的调用的是这个框架中的保存方法</span></span><br><span class="line">session.getTransaction().commit();<span class="comment">//提交一个事务</span></span><br></pre></td></tr></table></figure></blockquote><p><code>TeacherDaoImpl.java</code>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoImpl</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Teacher teacher)</span></span>&#123;</span><br><span class="line">    session.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">    session.save(teacher);<span class="comment">//具体的调用的是这个框架中的保存方法</span></span><br><span class="line">    session.getTransaction().commit();<span class="comment">//提交一个事务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StudentDaoImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    session.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">    session.save(student);<span class="comment">//具体的调用的是这个框架中的保存方法</span></span><br><span class="line">    session.getTransaction().commit();<span class="comment">//提交一个事务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>发现在未来使用框架的时候,会发现很多步骤都是重复的.可能就涉及到具体的对象那一行的代码才会不一样而已</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.save(具体的java对象);</span><br></pre></td></tr></table></figure><p><code>考虑抽象出一个顶级的业务接口出来-IBaseDao&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 顶级的业务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:50 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//顶级的业务接口中应该存储的就是各个子接口中共性的方法</span></span><br><span class="line">    <span class="comment">//这些方法都有共同点 - 大部分的代码是一样的,仅仅是操作的对象不一样而已.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>制定顶级的接口的实现类BaseDaoImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 顶级接口的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        session.beginTransaction();//开启一个事务</span></span><br><span class="line"><span class="comment">//        session.save(t);//具体的调用的是这个框架中的保存方法</span></span><br><span class="line"><span class="comment">//        session.getTransaction().commit();//提交一个事务</span></span><br><span class="line"></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IStudentDao.java继承了顶级的业务接口</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 具体的业务接口去继承这个顶级的业务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taoKe</span><span class="params">()</span></span>;<span class="comment">//子接口中特有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ITeacherDao.java</code>继承了顶级的业务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">Teacher</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buKe</span><span class="params">()</span></span>;<span class="comment">//子接口中特有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>俩个具体的实现类 - 需要继承顶级的BaseDaoImpl.java - save方法已经实现好了.同时还需要各自实现自己的接口</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 具体的学生接口的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:55 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//泛型继承 - 指定了泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">Student</span>&gt;  <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taoKe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;逃课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 9:02 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">Teacher</span>&gt; <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buKe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;补课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>单元测试</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Student;</span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:56 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        IStudentDao studentDao = <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">        studentDao.save(s);</span><br><span class="line"></span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="number">1</span>,<span class="string">&quot;仓考试&quot;</span>);</span><br><span class="line">        ITeacherDao teacherDao = <span class="keyword">new</span> TeacherDaoImpl();</span><br><span class="line">        teacherDao.save(teacher);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><blockquote><p>枚举常量 - 类型安全的常量 - 公共的静态的常量[final]属性 - 不可变的</p></blockquote><blockquote><p>jdk5.0开始提供的,以前的作用就是用<strong>来替代常量接口的</strong></p><p>回忆常量接口 - 管理和维护项目中所有的常量的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConsts</span></span>&#123;</span><br><span class="line">  <span class="comment">//最全的写法 - 接口中只能出现公开的静态的常量属性</span></span><br><span class="line">  <span class="comment">//public static final int Car = 1;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//精简的写法</span></span><br><span class="line">  <span class="comment">//public int CAR = 1;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最精简的写法</span></span><br><span class="line">  <span class="keyword">int</span> CAR = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><blockquote><p>使用enum关键字来定义一个枚举类型的</p><p>switch()中的参数类型可以是byte,short,int,char,<strong>enum</strong>,String,Byte,Short,Integer</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote><ol><li><p>枚举常量,多个枚举常量,使用,隔开.最后一个枚举常量不需要使用逗号了.</p><p>如果最后一个枚举常量下面还有代码的话,那么需要使用分号隔开</p></li><li><p>允许存在构造 - 访问修饰符不能是公开的,protected</p></li><li><p>枚举类型是不能够被实例化的</p></li><li><p>枚举类型中可以提供普通属性</p></li><li><p><strong>每个枚举类型默认都会自动继承java.lang.Enum&lt;E extends Enum<E>&gt;</E></strong></p></li><li><p>枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法</p></li><li><p>枚举类型不支持再去extends另外一个枚举类型</p></li><li><p>枚举类型不支持再去手动extends另外一个类</p></li></ol></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>如果某些属性具有固定的一些标识,就可以考虑定义成枚举类型.</p><p>比如:User实体类中维护了一个性别属性Gender[性别的枚举类型]</p><p>比如:Order实体类也会存在固定的状态 - 未付款,已付款.已下单未付款.取消订单等…</p></blockquote><h2 id="字符串-gt-枚举常量"><a href="#字符串-gt-枚举常量" class="headerlink" title="字符串-&gt;枚举常量"></a>字符串-&gt;枚举常量</h2><blockquote><p>比如一个注册页面</p><table><thead><tr><th>用户名</th><th>tom</th></tr></thead><tbody><tr><td>性别</td><td>单选按钮 男  单选按钮 女</td></tr><tr><td></td><td>确定按钮</td></tr></tbody></table><p>未来.当点击确定按钮,后台接受到M,F - 后台接受到的数据都是字符串数据.</p><p>我们是不能够直接将这个字符串数据设置到实体类中的枚举常量属性上的.</p><p>每个自定义的枚举类型Gender.java默认都会继承java.lang.Enum&lt;E extends Enum<E>&gt;</E></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                String name)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.enums;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: String-&gt;枚举类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 10:10 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String gender = <span class="string">&quot;F&quot;</span>;<span class="comment">//接受到页面传过来的数据 - 都是字符串类型</span></span><br><span class="line">        <span class="comment">//字符串类型是不能够直接设置给实体类的那个枚举常量属性上的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(FString.class);</span></span><br><span class="line">       <span class="comment">// System.out.println(Integer.class);</span></span><br><span class="line">        <span class="comment">//Class&lt;?&gt; c = String.class;</span></span><br><span class="line">        <span class="comment">//System.out.println(c);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串转换成枚举常量类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意 - 字符串的值一定是和枚举常量的名称是保持一致的.</span></span><br><span class="line">        <span class="comment">//否则 - java.lang.IllegalArgumentException:</span></span><br><span class="line">        <span class="comment">//      No enum constant tech.aistar.day14.enums.Gender.S</span></span><br><span class="line">        Gender g = Enum.valueOf(Gender.class,gender);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>,g);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><blockquote><p>它是effective java作者极力推荐的写法 - 枚举实例 - 1. 枚举类型天生就是线程安全的.2. 可以防止序列化或者反射来破坏这种单例的.</p><p>单例 - 保证在整个应用程序中,某个类的具体的实例永远只有1个.</p><p>什么时候需要把类做成单例的 - 这个类是一个重量级的类[类的创建和销毁的成本比较高.]</p></blockquote><h2 id="枚举常量是类型安全的常量"><a href="#枚举常量是类型安全的常量" class="headerlink" title="枚举常量是类型安全的常量???"></a>枚举常量是类型安全的常量???</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span></span>&#123;</span><br><span class="line">  F,M</span><br><span class="line">&#125;</span><br><span class="line">因为使用枚举常量 - 第一步肯定是先加载枚举类型Gender - JVM通过类加载器[java.lang.ClassLoader]来加载枚举类型</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//使用到了synchronized关键字</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//.... 加载类,接口,枚举类型到JVM内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">很多线程都在调用Gender.M - &gt; 都想尝试加载Gender枚举类型到JVM内存.但是由于loadClass加载的那块代码使用到了<span class="keyword">synchronized</span>[锁]</span><br><span class="line">只能由一个线程进去执行,并且只会执行一次.</span><br><span class="line">  </span><br><span class="line">由于每个枚举常量F 本质 就是 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Gender F = <span class="keyword">new</span> Gender();<span class="comment">//使用到了static关键字</span></span><br><span class="line"><span class="comment">//意味着当枚举类型一旦被加载了,枚举常量立即就会被分配空间以及初始化,并且机会只有一次.所以在整个内存中F常量也就只会存在一份.</span></span><br><span class="line"><span class="comment">//无论在哪里被调用.无论被多少给线程调用 - 大家拿到的都是同一个/同一份那个枚举常量.</span></span><br></pre></td></tr></table></figure><h3 id="具体的代码的实现"><a href="#具体的代码的实现" class="headerlink" title="具体的代码的实现"></a>具体的代码的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 枚举单例实现方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 10:45 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton04</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部的枚举类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">        <span class="comment">//枚举常量的实例</span></span><br><span class="line">        INSTANCE;<span class="comment">//public static final SingletonEnum INSTANCE = new SingletonEnum();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//final修饰的变量要赋值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton04 instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举类型提供一个空参构造 - 枚举类型是不能new的</span></span><br><span class="line">        SingletonEnum()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton04();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提供一个普通方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外部类肯定是要提供一个方法,返回自己的一个唯一实例的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingle04</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举单例写法"><a href="#枚举单例写法" class="headerlink" title="枚举单例写法"></a>枚举单例写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 枚举单例 - 最精简的写法 - 多线程安全的写法 - 饿汉模式</span></span><br><span class="line"><span class="comment">  只有最外层的是枚举类型 - 序列化这个枚举类型的单例,才能阻止序列化破坏单例的模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 11:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public static final Singleton05 INSTANCE = new Singleton05();</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton05()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比较繁琐的操作的事情,费时费力的事情&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>对比饿汉模式的写法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 初始化一个变量,该变量就是该类的唯一实例[对象]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有化构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较费时费力的代码,可能需要更多的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton01...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公开的静态的方法来返回这个类的唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举单例阻止序列化的破坏"><a href="#枚举单例阻止序列化的破坏" class="headerlink" title="枚举单例阻止序列化的破坏"></a>枚举单例阻止序列化的破坏</h3><blockquote><ol><li>序列化单例对象s1</li><li>反序列化封装到单例对象s3</li><li>s1 == s3 ;// 仍然为true</li></ol></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.enums.Gender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 枚举单例 - 最精简的写法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 11:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public static final Singleton05 INSTANCE = new Singleton05();</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton05()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比较繁琐的操作的事情,费时费力的事情&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton05</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton05 s1 = Singleton05.getInstance();</span><br><span class="line"></span><br><span class="line">        Singleton05 s2 = Singleton05.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/tech/aistar/design/ss.txt&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">//对单例进行序列化操作</span></span><br><span class="line">            out.writeObject(s1);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/tech/aistar/design/ss.txt&quot;</span>)))&#123;</span><br><span class="line"></span><br><span class="line">            Singleton05 s3 = (Singleton05) in.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1 == s3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="枚举细节-抽象方法"><a href="#枚举细节-抽象方法" class="headerlink" title="枚举细节 - 抽象方法"></a>枚举细节 - 抽象方法</h2><blockquote><p>枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.enums;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 季节的枚举类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 1:43 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.SUMMER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.AUTUMN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.WINTER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.SPRING;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sign;</span><br><span class="line"></span><br><span class="line">    Season()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Season(String sign) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sign = sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个抽象方法 - 但是要求所有的枚举常量都要重写这个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Season <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSeason</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season s = Season.SPRING;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;-&quot;</span>+s.getSign());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//让程序睡一秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            s = s.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day13</title>
    <link href="http://example.com/2021/07/27/day13/"/>
    <id>http://example.com/2021/07/27/day13/</id>
    <published>2021-07-27T10:02:10.000Z</published>
    <updated>2022-01-07T09:02:59.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><blockquote><p>java.io.File[C] - File包含文件或者文件夹[目录directory]</p><p>作用:它是用来操作File本身的<strong>元</strong>信息的[比如支持File的创建,删除,获取File的名称,获取File的路径等信息]</p><p>它并不支持文件里面的内容的读写操作[文件内中的内容的读写操作是交给IO流去实现]</p><p>支持本地File以及远程File的操作的.</p><p>File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射.</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><blockquote><p>File(String path);//利用一个路径来构建一个File实例.这个路径可以是文件的路径,也可以是文件夹的路径</p><p>路径分成相对路径和绝对路径.</p><p>绝对路径 - windows操作系统是以盘符号开头的路径,Linux/mac以/开头的路径</p><p>相对路径 - 不是以盘符或者/开头的路径</p></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>boolean createNewFile();//创建一个文件,该方法是要抓取异常的.</p></li><li><p>String getAbsolutePath();//获取该File的绝对路径</p></li><li><p>String getName();//获取File的名称</p></li><li><p>String getParent();//获取该File的父目录的绝对路径</p></li><li><p>boolean exists();//判断File是否存在</p></li><li><p>boolean delete();//删除文件或者文件夹</p><p>6-1. 文件是否可以直接被删除的</p><p>6-2. 如果是空目录 - 直接删除的</p><p>6-2. <strong>如果是非空目录 - 将会删除失败 - 递归算法来实现的.</strong></p></li><li><p>boolean mkdir();//创建单层次的目录,一次只能创建一个目录</p></li><li><p>boolean mkdirs();//既可以创建单层次的目录,又可以同时创建多个不存在的目录.</p></li><li><p>boolean isFile();//判断File实例是否为文件的实例</p></li><li><p>boolean isDirectory();//判断file实例是否为文件夹的实例</p></li><li><p>String[] list();//返回的是File的名称,返回的是传入的路径下的第一层的内容.</p></li><li><p><strong>File[] listFiles();//返回的第一层的File实例</strong></p></li><li><p>File[] listFiles(FilenameFilter filter);//找到指定后缀/前缀/满足条件的这么一个File实例</p></li></ol></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li><p>传入一个目录,输出这个目录下的所有的内容.</p><p>如果是文件 - 直接输出名称</p><p>如果是文件夹 - 输出绝对路径</p></li></ol></blockquote><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><blockquote><p>删除一个非空目录</p></blockquote><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><blockquote><p>流是一种抽象概念，它代表了数据的<strong>无结构化传递</strong>。<strong>按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]<strong>进行</strong>有序的</strong>输入输出，<strong>数据被当成无结构的字节序或字符序列</strong>。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output)</p></blockquote><p><img src="/2021/07/27/day13/io01.jpeg"> </p><p><code>流想象成是数据传输的那个管道</code></p><p><code>磁盘中数据加载/读入到内存中 - 输入</code></p><p><img src="/2021/07/27/day13/io02.png"> </p><p><code>java内存中数据写出去到磁盘中 - 输出</code></p><p><img src="/2021/07/27/day13/io03.png">  </p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><blockquote><ol><li><p>按照流的方向 - 输入流和输出流</p></li><li><p>按照流的读取的单位不同 - 字节流[按照单个字节单个字节进行读写,文本文件或者二进制文件]和字符流[单个字符进行读写,只能操作文本字符文件]</p></li><li><p>按照流的功能 - 节点流[基础流]和拓展流[过滤流或者包装流] - 采用了”装饰器设计模式思想”</p><p>**节点流才具备真正操作文件的能力.**拓展流只是让流的功能更加强大而已,拓展流脱离了节点流的话,那么是不允许的.</p><p>拓展流的使用必须要建立在节点流的基础之上.</p></li></ol></blockquote><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><blockquote><ol><li>java.io.InputStream[C] - 字节输入流的顶级的抽象的父类<ul><li>java.io.FileInputStream[C] - 文件字节输入流 - 操作文件的读操作. - <strong>典型的节点流</strong></li><li>java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - <strong>典型的包装流</strong></li><li>java.io.FilterInputStream[C] - 过滤流<ul><li>java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流</li><li>java.io.DataInputStream[C] - 操作基本数据类型的字节输入流</li></ul></li></ul></li></ol></blockquote><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><blockquote><p>java.io.OutputStream[C] - 字节输出流的顶级的抽象的父类</p><ul><li>java.io.<strong>FileOutputStream[C]</strong> - 文件字节输出流 - 操作文件的写操作. - <strong>典型的节点流</strong></li><li>java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - <strong>典型的包装流</strong></li><li>java.io.FilterOutputStream[C] - 过滤流<ul><li>java.io.<strong>BufferedOutputStream[C]</strong> - 带缓存功能的流 - 缓冲流</li><li>java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流</li></ul></li></ul></blockquote><h1 id="InputStream常用方法"><a href="#InputStream常用方法" class="headerlink" title="InputStream常用方法"></a>InputStream常用方法</h1><blockquote><ol><li>void close();//关闭流,流本身就是一个对象[占内存 - 昂贵的资源]</li><li>abstract  int read();//单个字节单个字节的读取,如果读不到,返回-1</li><li><strong>int read(byte[] b);//从输入流读取一些字节数，并将它们存储到缓冲区 b</strong> 。</li></ol></blockquote><h1 id="OutputStream常用方法"><a href="#OutputStream常用方法" class="headerlink" title="OutputStream常用方法"></a>OutputStream常用方法</h1><blockquote><ol><li>void close();//关闭</li><li>abstract void write(int b);将指定的字节写入此输出流。</li><li><strong>void write(byte[] b, int off, int len);</strong></li></ol></blockquote><h1 id="IO流的编程步骤"><a href="#IO流的编程步骤" class="headerlink" title="IO流的编程步骤"></a>IO流的编程步骤</h1><blockquote><ol><li>确定流 - 选什么流</li><li>确定源头和目标</li><li>循环读取,循环写出 - while</li><li>关闭流</li></ol></blockquote><h1 id="缓冲流BufferedInputStream"><a href="#缓冲流BufferedInputStream" class="headerlink" title="缓冲流BufferedInputStream"></a>缓冲流BufferedInputStream</h1><blockquote><p>在它出来之前,可以可以单个字节单个字节进行读写操作 - 弊端:java程序和磁盘的IO交互比较频繁,性能就会低下.</p><p>采取了自定义的数组的方式.从磁盘文件中读取一定数量的字节先放入到缓冲数组中.然后再从缓冲数组中一次性写出到磁盘中.</p><p>减少了java程序和磁盘的IO交互 - 性能提高.</p></blockquote><blockquote><p>JDK中发现了这点,提供了缓冲流BufferedInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;<span class="comment">//默认的容量8kb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];<span class="comment">//内置的缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(in);</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];<span class="comment">//初始化内置的缓冲区数组 - 大小是8kb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>底层利用了”装饰器”思想.这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力.</p><p>构建带缓冲功能的流,必须要以节点流作为支撑</p></blockquote><blockquote><p><code>构架一个带缓冲功能的能够读取文件的字节输入流</code></p><p>BufferedInputStream in = new BufferedInputStream(new FileInputStream(“路径”));</p><p>BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(“路径”));</p></blockquote><h2 id="缓冲数组"><a href="#缓冲数组" class="headerlink" title="缓冲数组"></a>缓冲数组</h2><blockquote><p>BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么?</p></blockquote><blockquote><p><strong>内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 缓冲流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/5 2:18 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//jvm加载磁盘上的数据到内置的byte[]中</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/tech/aistar/day13/fast.gif&quot;</span>));</span><br><span class="line">            out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/tech/aistar/day13/fast_副本.gif&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自定义一个byte[]</span></span><br><span class="line">            <span class="comment">//真正的读</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                len = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span>(len==-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                out.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读过程"><a href="#读过程" class="headerlink" title="读过程"></a>读过程</h2><blockquote><ol><li>当初始化好缓冲流之后,jvm会立即读取磁盘中的数据到内置的缓冲数组中</li><li>当程序中循环读取到的时候 len = in.read(buf); = 程序是直接从内置的缓冲区[内置的缓冲数组中]</li><li>一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区.</li></ol></blockquote><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><blockquote><p>jdk7.0提供的写法</p><p>作用 - 把流的关闭交给JVM</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象的声明<span class="number">1</span>;资源对象的声明<span class="number">2</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(..)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 语法糖 - JVM去关闭流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/5 2:39 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAutoCloseDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自动关闭这些资源</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/tech/aistar/day13/fast.gif&quot;</span>));</span><br><span class="line">            BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/tech/aistar/day13/fasts.gif&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">//自定义一个byte[]</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                len = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span>(len==-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                out.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ObjectInputStream-ObjectOutputStream"><a href="#ObjectInputStream-ObjectOutputStream" class="headerlink" title="ObjectInputStream/ObjectOutputStream"></a>ObjectInputStream/ObjectOutputStream</h1><blockquote><p>操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑</p><p><code>构建一个能够读写对象类型的文件字节输入流/输出流</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;path&quot;</span>))</span><br></pre></td></tr></table></figure></blockquote><p><code>构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;path&quot;</span>)));</span><br></pre></td></tr></table></figure><p>利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响.</p><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><blockquote><p>也叫做 - 数据的持久化的过程. - 把内存中的java对象存储到磁盘的文件的过程.</p><p>注意点:</p><ol><li><p>如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口</p><p>如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常</p></li><li><p>保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口</p></li></ol><p>关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取.</p></blockquote><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有的属性比较敏感,比如员工的工资</span></span><br><span class="line"><span class="comment">//如果不希望持久化某个属性值 - 不希望这个属性的数据被写到磁盘中</span></span><br><span class="line"><span class="comment">//瞬态关键字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">double</span> price;</span><br></pre></td></tr></table></figure><h2 id="对象的反序列化"><a href="#对象的反序列化" class="headerlink" title="对象的反序列化"></a>对象的反序列化</h2><blockquote><p>java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上].</p></blockquote><h1 id="CURD操作①"><a href="#CURD操作①" class="headerlink" title="CURD操作①"></a>CURD操作①</h1><blockquote><p>实体类 - 接口 - 实现类 - 单元测试</p></blockquote><blockquote><p>操作文件中的数据</p><ul><li>tech.aistar.day13.prj<ul><li>entity - Phone.java[id,name,price]</li><li>dao - data access object [IPhoneDao.java]数据对象访问 - 数据持久层 - 和文件进行打交道的一层 - 接口<ul><li>impl - 接口的实现类PhoneDaoImpl.java</li></ul></li><li>test - 单元测试</li></ul></li></ul></blockquote><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><blockquote><p>文件夹的拷贝②</p></blockquote><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><blockquote><p>它和字节流的区别是读取的单位是不同的 .字节流是按照单个字节进行读写操作.</p><p>字符流是按照单个字符的单位进行读写操作.字符流专门用来处理的文本字符文件的.字节流是用来处理文本文件或者二进制文件的.</p></blockquote><h2 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h2><blockquote><p>java.io.Reader[C] - 顶级的字符输入流 - 抽象类</p><ul><li><p>BufferedReader[C] - 带缓冲功能的字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(in, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提供的方法</span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span></span>;<span class="comment">//每次读取文本文件的一整行的数据,如果读取不到[到达文件的末尾了],返回false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的.</strong></p></li></ul></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符输入流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 1:40 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderHelloDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 确定流</span></span><br><span class="line">        <span class="comment">//2. 确定源头</span></span><br><span class="line">        <span class="comment">//3. 循环读取</span></span><br><span class="line">        <span class="comment">//4. 关闭流 - 可以采取语法糖 - JVM去自行关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//demo - 用来读取文本文件,然后将内容输出到控制台上去</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;src/tech/aistar/day13/Book.java&quot;</span>)))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一行一行进行读取</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环读取</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                line = in.readLine();<span class="comment">//读取一整行的数据,若读取不到,则返回false</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//循环退出的条件</span></span><br><span class="line">                <span class="keyword">if</span>(line == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h2><blockquote><p>java.io.Writer[C] - 顶级的字符输出流 - 抽象类</p><ul><li><p>PrintWriter[C] - 自带缓存功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter(Writer out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数是是否自动刷新缓存</span></span><br><span class="line"><span class="comment">//缓存里面的数据什么时候会被同步到磁盘上</span></span><br><span class="line"><span class="comment">//1. 缓存中的数据满的时候 - 会自动刷新</span></span><br><span class="line"><span class="comment">//2. 缓存中的数据还不足以撑满这个缓存 - close或者flush - 强制刷新缓存</span></span><br><span class="line">PrintWriter(Writer out, <span class="keyword">boolean</span> autoFlush);</span><br></pre></td></tr></table></figure></li><li><p><strong>FileWriter[C] -字符流中的节点流 - 具备真正的字符文件的读写操作的.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法:</span><br><span class="line"><span class="number">1.</span> FileWriter(String path);<span class="comment">//写到哪里去,目标的绝对/相对路径</span></span><br><span class="line"><span class="number">2.</span> FileWriter(String path,<span class="keyword">boolean</span> append);<span class="comment">//第二个参数代表的是是否追加写入.如果append设置成true.支持分批次的写</span></span><br><span class="line">   和分批次的读 - 都是字符串</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符输出流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 1:57 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterHelloDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建一个自动刷新,但是能够实现追加写入的功能.</span></span><br><span class="line">        <span class="comment">//第一个true - 代表的是是否追加写入 - true</span></span><br><span class="line">        <span class="comment">//第二个true - 是否自动刷新缓存,设置成true之后,那么就不需要在程序代码中手动刷新,不需要再去写out.flush();</span></span><br><span class="line">        <span class="comment">//            推荐 - 1. 构建一个自动刷新的输出流 2. 程序代码的之后还是推荐手动刷新out.flush()3. 依然需要关闭流 - jvm</span></span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out =</span><br><span class="line">                    <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;src/tech/aistar/day13/writer.txt&quot;</span>,<span class="keyword">true</span>),<span class="keyword">true</span>))&#123;</span><br><span class="line">            <span class="comment">//因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存.</span></span><br><span class="line">            <span class="comment">//有可能有部分学生的计算机,它没有达到强制刷新缓存的效果</span></span><br><span class="line">            <span class="comment">//场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//print方法以及println方法</span></span><br><span class="line">            <span class="comment">//print方法写入之后,后面是没有加一个\n</span></span><br><span class="line">            <span class="comment">//println方法写入之后,后面是有一个\n</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把内存中的数据持久化到磁盘中的文件中.</span></span><br><span class="line">            <span class="comment">//out.print(&quot;web前端很好玩!&quot;);</span></span><br><span class="line"></span><br><span class="line">            out.println(<span class="string">&quot;c不好玩!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//推荐在结束的时候,手动刷新一下缓存</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建一个不自动刷新,但是能够实现追加写入的功能.</span></span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;src/tech/aistar/day13/writer.txt&quot;</span>,<span class="keyword">true</span>)))&#123;</span><br><span class="line">            <span class="comment">//因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存.</span></span><br><span class="line">            <span class="comment">//有可能有部分学生的计算机,它没有达到强制刷新缓存的效果</span></span><br><span class="line">            <span class="comment">//场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//print方法以及println方法</span></span><br><span class="line">            <span class="comment">//print方法写入之后,后面是没有加一个\n</span></span><br><span class="line">            <span class="comment">//println方法写入之后,后面是有一个\n</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把内存中的数据持久化到磁盘中的文件中.</span></span><br><span class="line">            <span class="comment">//out.print(&quot;web前端很好玩!&quot;);</span></span><br><span class="line"></span><br><span class="line">            out.println(<span class="string">&quot;c不好玩!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//推荐在结束的时候,手动刷新一下缓存</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建的是一个不自动刷新,不追加写入的字符输出流</span></span><br><span class="line">        <span class="comment">//每次都会覆盖原来的文件,并且在第一次写入的时候,会自动创建这个文件的.</span></span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;src/tech/aistar/day13/writer.txt&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">//因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存.</span></span><br><span class="line">            <span class="comment">//有可能有部分学生的计算机,它没有达到强制刷新缓存的效果</span></span><br><span class="line">            <span class="comment">//场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//print方法以及println方法</span></span><br><span class="line">            <span class="comment">//print方法写入之后,后面是没有加一个\n</span></span><br><span class="line">            <span class="comment">//println方法写入之后,后面是有一个\n</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把内存中的数据持久化到磁盘中的文件中.</span></span><br><span class="line">            out.print(<span class="string">&quot;python很好玩!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//推荐在结束的时候,手动刷新一下缓存</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符流来实现文件的拷贝操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 2:37 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopyReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        copyFile(<span class="string">&quot;src/tech/aistar/day13/FileDemo.java&quot;</span>,<span class="string">&quot;src/tech/aistar/day13/FileDemo_副本.java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 原文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标文件的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src,String target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建流 - 源头和目标的确定</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(target),<span class="keyword">true</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 定义一个变量 - 用来保存每次读取到的一行数据</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 循环读取</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                line = in.readLine();<span class="comment">//读取一整行,读不到,则返回null</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//循环退出的条件</span></span><br><span class="line">                <span class="keyword">if</span>(line == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写一行出去</span></span><br><span class="line">                out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结笔试"><a href="#总结笔试" class="headerlink" title="总结笔试"></a>总结笔试</h1><blockquote><ol><li>常见的字节流和字符流</li><li>装饰器的设计模式</li><li>难一点的知识点 - <strong>同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别</strong></li><li>BufferedInputStream - 内置的缓冲数组 - 8kb</li></ol></blockquote><h1 id="补充-破坏单例"><a href="#补充-破坏单例" class="headerlink" title="补充 - 破坏单例"></a>补充 - 破坏单例</h1><blockquote><p><strong>单例设计模式 - 保证在整个应用程序中,某个类的具体的实例永远只有1个 - 多线程下也是一个 - 双重锁检测</strong></p><p>对象的序列化和反序列化可以破坏这种单例,如何破坏?</p><p><strong>解决方案: 单例的第四个版本 - 枚举类型来实现单例模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.design.singleton.version03.Singleton03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 对象的序列化和反序列化可以破坏单例的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 3:06 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton03 s1 = Singleton03.getInstance();</span><br><span class="line"></span><br><span class="line">        String path = <span class="string">&quot;src/tech/aistar/day13/singleton.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把这个对象写入到文件中</span></span><br><span class="line">        writeObject(s1,path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读</span></span><br><span class="line">        Singleton03 s2 = readObject(path);<span class="comment">//反序列化之后,并没有走构造,直接操作的内存</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象的序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Singleton03 s,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写</span></span><br><span class="line">            out.writeObject(s);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象的反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">readObject</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        Singleton03 s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读</span></span><br><span class="line">            s = (Singleton03) in.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day12</title>
    <link href="http://example.com/2021/07/26/day12/"/>
    <id>http://example.com/2021/07/26/day12/</id>
    <published>2021-07-26T10:02:10.000Z</published>
    <updated>2022-01-07T09:02:41.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h1><blockquote><ol><li>java.text.SimpleDateFormat - 日期格式处理类</li><li>线程不安全的类.</li></ol></blockquote><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><blockquote><ol><li><p>Date类型转换成String类型 - 按照指定的日期格式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pattern必须是一个有效的格式化模板,如果传入了一个非法模板</span></span><br><span class="line"><span class="comment">//那么就会抛出一个java.lang.IllegalArgumentException - 非法参数异常</span></span><br><span class="line"><span class="comment">// Illegal pattern character &#x27;q&#x27;</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(Date date)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>String类型转换成Date类型.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果构造中的pattern的格式和日期的字符串的格式不一致,那么在调用</span></span><br><span class="line"><span class="comment">//parse方法的时候就会抛出java.text.ParseException: Unparseable date: &quot;2020-09-03&quot;</span></span><br><span class="line"><span class="comment">//解析失败异常</span></span><br><span class="line"><span class="function">Date <span class="title">parse</span><span class="params">(String str)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="模板pattern"><a href="#模板pattern" class="headerlink" title="模板pattern"></a>模板pattern</h2><table><thead><tr><th>Letter</th><th>Date or Time Component</th><th>Presentation</th><th>Examples</th></tr></thead><tbody><tr><td><code>G</code></td><td>Era designator</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#text">Text</a></td><td><code>AD</code></td></tr><tr><td><code>y</code></td><td>Year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#year">Year</a></td><td><code>1996</code>; <code>96</code></td></tr><tr><td><code>Y</code></td><td>Week year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#year">Year</a></td><td><code>2009</code>; <code>09</code></td></tr><tr><td><code>M</code></td><td>Month in year (context sensitive)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#month">Month</a></td><td><code>July</code>; <code>Jul</code>; <code>07</code></td></tr><tr><td><code>L</code></td><td>Month in year (standalone form)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#month">Month</a></td><td><code>July</code>; <code>Jul</code>; <code>07</code></td></tr><tr><td><code>w</code></td><td>Week in year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>27</code></td></tr><tr><td><code>W</code></td><td>Week in month</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>2</code></td></tr><tr><td><code>D</code></td><td>Day in year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>189</code></td></tr><tr><td><code>d</code></td><td>Day in month</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>10</code></td></tr><tr><td><code>F</code></td><td>Day of week in month</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>2</code></td></tr><tr><td><code>E</code></td><td>Day name in week</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#text">Text</a></td><td><code>Tuesday</code>; <code>Tue</code></td></tr><tr><td><code>u</code></td><td>Day number of week (1 = Monday, …, 7 = Sunday)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>1</code></td></tr><tr><td><code>a</code></td><td>Am/pm marker</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#text">Text</a></td><td><code>PM</code></td></tr><tr><td><code>H</code></td><td>Hour in day (0-23)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>0</code></td></tr><tr><td><code>k</code></td><td>Hour in day (1-24)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>24</code></td></tr><tr><td><code>K</code></td><td>Hour in am/pm (0-11)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>0</code></td></tr><tr><td><code>h</code></td><td>Hour in am/pm (1-12)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>12</code></td></tr><tr><td><code>m</code></td><td>Minute in hour</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>30</code></td></tr><tr><td><code>s</code></td><td>Second in minute</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>55</code></td></tr><tr><td><code>S</code></td><td>Millisecond</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>978</code></td></tr><tr><td><code>z</code></td><td>Time zone</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#timezone">General time zone</a></td><td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td></tr><tr><td><code>Z</code></td><td>Time zone</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#rfc822timezone">RFC 822 time zone</a></td><td><code>-0800</code></td></tr><tr><td><code>X</code></td><td>Time zone</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#iso8601timezone">ISO 8601 time zone</a></td><td><code>-08</code>; <code>-0800</code>; <code>-08:00</code></td></tr></tbody></table><h2 id="日期工具类"><a href="#日期工具类" class="headerlink" title="日期工具类"></a>日期工具类</h2><blockquote><p>java.util.Date</p></blockquote><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><blockquote><p>api: java.math</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><blockquote><p><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/math/BigDecimal.html#BigDecimal-double-">BigDecimal</a></strong>(double val)</p><p>BigDecimal(String val);//处理小数精度的问题</p></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>BigDecimal add(BigDecimal augend)<br>返回 BigDecimal ，其值是 (this + augend) ，其标为 max(this.scale(), augend.scale()) 。</p></li><li><p>BigDecimal divide(BigDecimal divisor)</p><p>除法</p></li><li><p>BigDecimal multiply(BigDecimal multiplicand)</p><p>乘法</p></li><li><p>BigDecimal    subtract(BigDecimal subtrahend)</p><p>减法</p></li></ol></blockquote><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><blockquote><p>在java开发中如何处理小数精度丢失的问题</p><p>需要使用到的是<strong>BigDecimal(String val);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 处理小数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/4 9:27 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalHandlerFloatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">        BigDecimal d2 = <span class="keyword">new</span> BigDecimal(String.valueOf(<span class="number">0.2</span>));</span><br><span class="line"></span><br><span class="line">        BigDecimal result = d1.add(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BigDecimal-&gt;double/String</span></span><br><span class="line">        <span class="keyword">double</span> resultDouble = result.doubleValue();</span><br><span class="line">        System.out.println(resultDouble);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><blockquote><p>笔试题 - 递归算法求阶乘</p><p><strong>构造:BigInteger(String val);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> BigInteger.ONE;</span><br><span class="line">        BigInteger current = <span class="keyword">new</span> BigInteger(String.valueOf(n));</span><br><span class="line">        <span class="keyword">return</span> current.multiply(test(n-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h1 id="四种内部类"><a href="#四种内部类" class="headerlink" title="四种内部类"></a>四种内部类</h1><blockquote><p>看懂别人写的内部类语法即可</p></blockquote><blockquote><ol><li><p>成员内部类 - 把内部类看成是外部类的一个成员</p><p>a. 成员内部类不能再去定义静态成员</p><p>b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 对象名 = 外部类对象.new 内部类();</span><br></pre></td></tr></table></figure></li><li><p>静态内部类- 把内部类看成是外部类的一个静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 对象名 = <span class="keyword">new</span> 外部类.内部类();</span><br></pre></td></tr></table></figure><p>a. 内部是可以定义静态和非静态属性的</p><p>b. 内部的普通方法中是不允许访问外部类的非静态属性的.</p><p>c. 内部的普通方法中是允许访问外部类的静态属性的</p></li><li><p>局部内部类 - 内部类是出现在外部类的方法中.</p><p>a. 内部类是不允许使用访问修饰符,比如不能使用public</p><p>b. 不能定义静态属性的</p><p>c. 访问到外部类的静态和非静态成员的</p><p>d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new)</p></li><li><p>匿名内部类 - 必须掌握的</p><blockquote><p>好处 - 我们可以在程序中少写实现类</p><p>jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的.</p></blockquote></li></ol></blockquote><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><blockquote><p>IO流使用到了”装饰器”设计模式思想</p><p>装饰器模式（Decorator Pattern）<strong>允许向一个现有的对象添加新的功能，同时又不改变其结构</strong>。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p></blockquote><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><blockquote><p><em>Unified Modeling Language</em>- 统一建模语言</p></blockquote><blockquote><p>BA - 需求分析师</p><ol><li>powerndesigner </li><li>starUML</li></ol><p>掌握目标: 看懂箭头即可</p><p> 类与类之间由弱到强关系是:   <em><strong>*没关系 &gt;** **依赖 &gt; 关联 &gt; 聚合 &gt; 组合。*</strong></em></p></blockquote><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><blockquote><p>虚线+箭头&lt;——</p><p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//自己的功能</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//B类中的功能</span></span><br><span class="line">    b.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><blockquote><p>箭头 实线+箭头&lt;-</p></blockquote><blockquote><p>A类关联了B类 - A依赖于B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><blockquote><p>属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密.整体是可以决定局部的生命周期的.</p><p>箭头 - 实线+实心菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.uml.combination;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密.</span></span><br><span class="line"><span class="comment"> *            整体是可以决定局部的生命周期的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/4 10:34 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baby</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Eye eye;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Hand hand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eye = <span class="keyword">new</span> Eye();</span><br><span class="line">        <span class="keyword">this</span>.hand = <span class="keyword">new</span> Hand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baby b = <span class="keyword">new</span> Baby();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h2><blockquote><p>属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的</p><p>箭头 - 实线+空心菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Cpu cpu)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><blockquote><p>java.lang.Throwable - 异常和错误的顶级的类</p><p>两个分支:</p><ol><li><p>java.lang.Error - 错误 - 错误一旦发生,程序员是么有办法进行扭转的 - 不需要在代码中进行处理.</p><p>1-1. 子类<strong>VirtualMachineError</strong>虚拟机级别的错误</p><p>​         1-1-1. 子类java.lang.<strong>StackOverflowError</strong> 堆栈溢出 -  应用程序因为递归太深没有指定出口的时候.</p><p>​         1-1-2. 子类java.lang.<strong>OutOfMemoryError</strong> 内存泄漏 - [GC垃圾回收机制 - 后台自动回收垃圾对象]</p></li><li><p><strong>java.lang.Exception - 异常</strong> - 程序在运行的过程中发生了不正常的情况.</p></li></ol></blockquote><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><blockquote><p>运行时异常[RuntimeException]都是非运行时异常的子类[Exception]</p></blockquote><blockquote><ol><li><p>运行时异常 - 未检测异常</p><p><code>顶级的父类java.lang.RuntimeException</code></p><blockquote><ol><li><p>java.lang.NullPointerException - 空指针异常</p></li><li><p>java.util.InputMismatchException - 输入不匹配异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = sc.nextInt();<span class="comment">//只能获取整数.但是输入了一个字符串&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>java.lang.ArithmeticException - 分母为0</p></li><li><p>java.lang.IllegalArgumentException - 非法参数异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">构造中的模板如果传入了一个非法模板</span><br></pre></td></tr></table></figure></li><li><p>java.lang.IndexOutOfBoundsException - 下标越界异常 - 比如list.get(100);</p><p>5-1. java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常</p><p>5-2. java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常</p></li><li><p>java.util.NoSuchElementException - 不存在此元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">System.out.println(list.getFirst());<span class="comment">//获取栈顶元素,但是栈顶没有元素</span></span><br></pre></td></tr></table></figure></li><li><p>java.lang.ClassCastException - 类型转换失败异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型转换成子类类型之前,推荐先使用<span class="keyword">instanceof</span>关键字进行类型的判断</span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p>非运行时异常 - 已检测异常</p><blockquote><ol><li><p>java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配</p></li><li><p>InterruptedException - 中断异常 - Thread.sleep(1000);</p></li><li><p>java.lang.CloneNotSupportedException - 不允许被clone.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当调用对象的clone方法,但是这个对象没有去实现java.lang.Cloneable接口</span><br></pre></td></tr></table></figure></li><li><p>java.io.IOExcetion - IO流异常</p><p>4-1. java.io.EOFException - 已经读取到文件的末尾了.</p><p>4-2. java.io.FileNotFoundException - 文件找不到异常</p></li><li><p>java.sql.SQLException - SQL异常,比如程序中的sql语句要是写错了.</p></li></ol></blockquote></li></ol></blockquote><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><blockquote><ol><li><p>运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断.稍微谨慎一点.</p></li><li><p><strong>非运行时异常 - 编译期间就需要立即对其进行处理.处理的方式有俩种.一种是积极处理 - try..catch的方式</strong></p><p><strong>另外一种是消极处理.</strong></p></li></ol></blockquote><h3 id="积极处理方式"><a href="#积极处理方式" class="headerlink" title="积极处理方式"></a>积极处理方式</h3><blockquote><ol><li><p>语法一 - try….catch….catch….finally </p><p>推荐使用到的 - 因为针对每种不同的异常进行单独的日志记录,单独的异常处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//code..</span></span><br><span class="line">  <span class="comment">//code..</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e1)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e2)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//无论是否出现异常,都会执行</span></span><br><span class="line">&#125;</span><br><span class="line">注意:上方的异常类型不能是下方的异常类型的父类.</span><br></pre></td></tr></table></figure></li><li><p>语法二 - jdk7.0提供的新的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> | 异常类型<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>语法三 - 简单粗暴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常总父类)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="消极处理"><a href="#消极处理" class="headerlink" title="消极处理"></a>消极处理</h3><blockquote><p>比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了.</p><p>为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理.</p><p>原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃.</p></blockquote><blockquote><ol><li><p>直接在方法的签名[声明]上使用<strong>throws关键字+异常类型</strong>1,异常类型2</p></li><li><p>在方法体中使用<strong>throw+异常对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//System.out.println(&quot;异常的描述....&quot;);</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//throw + 运行时异常对象,不需要在方法的签名上抛出异常 - 本身运行时异常就不需要处理呀!</span></span><br><span class="line">    <span class="comment">//throw new RuntimeException(&quot;发生异常了...&quot;);</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//throw + 非运行时异常 配合 必须要在方法的签名上throws+非运行时异常类型</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;n:&quot;</span>+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>笔试题 - throws和throw有什么区别</p></blockquote><h1 id="笔试题1"><a href="#笔试题1" class="headerlink" title="笔试题1"></a>笔试题1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">  <span class="comment">//code..</span></span><br><span class="line">  <span class="keyword">return</span>;<span class="comment">//结束整个方法</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//无论是否出现异常,都会执行</span></span><br><span class="line">&#125;</span><br><span class="line">假设<span class="keyword">try</span>&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.</span><br><span class="line"><span class="number">1.</span> <span class="keyword">finally</span>中的代码执行否? - 肯定会执行</span><br><span class="line"><span class="number">2.</span> <span class="keyword">return</span>语句是在<span class="keyword">finally</span>块之前执行还是之后执行? - 之后</span><br></pre></td></tr></table></figure><h1 id="笔试题2"><a href="#笔试题2" class="headerlink" title="笔试题2"></a>笔试题2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day12.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 笔试题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/4 3:23 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(change());<span class="comment">//A&#123;age=200&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally中修改了基本数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//①</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//try可以直接和finally一起使用....</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//此处将i自增后的结果缓存起来了.并且这个缓存的结果就是作为最终返回出去的一个结果 - 对待基本数据类型.</span></span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ++i;<span class="comment">//③</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally修改了对象类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.age = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//return是在finally之后执行</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//对待对象类型 - finally中的修改对象的属性值,是对return的结果是产生了影响的.</span></span><br><span class="line">            a.age = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;A&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="笔试题3"><a href="#笔试题3" class="headerlink" title="笔试题3"></a>笔试题3</h1><blockquote><p>final和finally和finalize三者之间的区别? - 一点关系都没有</p><blockquote><ol><li><p>final </p><p>a. 修饰的局部变量一旦赋值成功,不可改变</p><p>b. 修饰的属性一旦赋值成功,不可改变</p><p>c. 修饰的类不可被继承</p><p>d. 修饰的方法不可被重写</p></li></ol></blockquote><blockquote><ol start="2"><li><p>finally</p><p>a. 一般是和try..catch搭配使用的.try块中无论是否出现异常,finally块中代码都会执行</p><p>b. finally块中一般写的是释放或者关闭资源的代码</p></li></ol></blockquote><blockquote><ol start="3"><li><p>finalize - Object类中提供的方法</p><p>a. 当GC想去回收一个垃圾对象之前,会去调用这个对象的finalize方法.是由JVM去调用.</p><p>b. 该方法未必一定会被调用得到.</p></li></ol></blockquote></blockquote><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><blockquote><p>项目中其实是专门包exception - 专门自定义自己的异常[大量的]</p><p>jdk内置的异常不够用,不符合实际的业务场景.</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><ol><li>写一个异常类继承java.lang.Exception</li><li>提供父类的5个构造方法即可</li></ol></blockquote><h2 id="思考为什么要自定义异常"><a href="#思考为什么要自定义异常" class="headerlink" title="思考为什么要自定义异常"></a>思考为什么要自定义异常</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;余额小于0&quot;</span>);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BalanceLtZeroException(<span class="string">&quot;余额小于0!&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - <strong>显示比如服务器正在维护/升级…</strong></p><p>我们应该提供一个<code>异常处理器</code> - 会监控软件程序在整个项目运行的过程中发生的一切异常.</p><p>一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面.</p><p>SpringMVC/SpringBoot - <code>异常处理器</code> - 只认识异常.</p></blockquote><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><blockquote><ol><li>重点围绕OO - 面向对象</li><li>三大特性 - 封装,继承,多态</li><li>抽象类和接口区别</li><li>四种访问修饰符的作用权限</li><li>方法的重载和方法的重写</li><li>单例 - 双重检测锁</li><li>简单工厂</li><li>static关键字的作用 - static练习</li></ol></blockquote><h1 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h1><ol start="0"><li><p>泛型</p></li><li><p><strong>IO流 - 大头</strong></p></li><li><p><strong>并发编程 - 多线程 - 大头中的大头 - 最难的最难的最难的</strong></p></li><li><p>反射技术 - 看懂框架的源码[反射技术 + 设计模式]</p></li><li><p>动态代理 - [jdk动态代理 + cglib动态代理]</p></li><li><p>枚举类型</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day11</title>
    <link href="http://example.com/2021/07/25/day11/"/>
    <id>http://example.com/2021/07/25/day11/</id>
    <published>2021-07-25T10:02:10.000Z</published>
    <updated>2022-01-07T09:02:20.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><p>就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用.</p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">api:java.util</span><br><span class="line">  </span><br><span class="line">Collection[I]</span><br><span class="line">  - List[I] - 有序可重复</span><br><span class="line">    - ArrayList[C] - 线程不安全</span><br><span class="line">    - LinkedList[C]</span><br><span class="line">    - Vector[C] - 使用方式和ArrayList一样,但是线程安全的</span><br><span class="line">  - 方法都是采用<span class="keyword">synchronized</span></span><br><span class="line">  - Set[I] - 无序不可重复</span><br><span class="line">    - HashSet[C]</span><br><span class="line">    - SortedSet[I]</span><br><span class="line">      - TreeSet[C]</span><br><span class="line">Map[I]</span><br><span class="line">  - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复.</span><br><span class="line">  - Hashtable[C]</span><br><span class="line">    - Properteis[C] - 属性文件在内存中的映射的对象</span><br></pre></td></tr></table></figure><h2 id="Collection-I"><a href="#Collection-I" class="headerlink" title="Collection[I]"></a>Collection[I]</h2><blockquote><ol><li>boolean add(E e);//向容器中添加一个元素</li><li>void clear();//清空容器</li><li>boolean contains(Object o);//判断容器中是否包含某个对象</li><li>boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true</li><li>Iterator<E>    iterator();// 获取集合对象的迭代器</E></li><li>boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个</li><li>int size();//返回集合中的数据的个数 - 集合的大小</li></ol></blockquote><h2 id="List-I"><a href="#List-I" class="headerlink" title="List[I]"></a>List[I]</h2><blockquote><p>特点 - 有序并且是可以重复的.</p><ol><li>E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1]</li><li>int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</li><li>E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素</li><li>Object[] toArray();//将集合转换成数组.</li></ol></blockquote><h1 id="ArrayList-C"><a href="#ArrayList-C" class="headerlink" title="ArrayList[C]"></a>ArrayList[C]</h1><blockquote><p>特点:有序可重复的,<strong>底层数据结构就是一个”动态增长”的数组.</strong></p><p>优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高.</p><p>缺点:增删效率会低.因为涉及到下标的移动.</p></blockquote><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就是真正的存储数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1. 初始化elementData,长度为0</span></span><br><span class="line">  <span class="comment">//2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  <span class="comment">//this.elementData = &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剖析add方法"><a href="#剖析add方法" class="headerlink" title="剖析add方法"></a>剖析add方法</h2><blockquote><p>ArrayList扩容的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">elementData[size++] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;<span class="comment">//第一次进来1</span></span><br><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//第一次minCapacity = 10</span></span><br><span class="line"> minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续ensureExplicitCapacity(minCapacity);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">modCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="comment">//第一次进来10-0&gt;0</span></span><br><span class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line"> grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grow(minCapacity)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一次</span></span><br><span class="line"><span class="comment">//oldCapacity = 0</span></span><br><span class="line"><span class="comment">//newCapacity = 0</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//第一次会进来</span></span><br><span class="line">  newCapacity = minCapacity;<span class="comment">//newCapacity = 10</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">  newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组</span></span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h2><blockquote><ol><li><p>直接输出</p></li><li><p>增强for循环 - 只读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常</span><br><span class="line">            </span><br><span class="line">实际的底层,调用迭代器对象中的next方法</span><br><span class="line">            </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//modCount是当初调用add方法,添加1个元素,modCount自增1个</span></span><br><span class="line">   <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">发现只要调用了remove方法 - modCount++</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>普通for</p></li><li><p>迭代器</p><p>因为不同的集合的底层的数据结构是不一样的.数据结构不一样,它的遍历方式不一样</p><p>为了访问/遍历不同数据结构的集合提供一种统一的遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1. 获取集合的迭代器</span></span><br><span class="line">Iterator&lt;Long&gt; iter = list.iterator();</span><br><span class="line"><span class="comment">//2. 调用hasNext方法</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;<span class="comment">//判断迭代器中是否仍有下一个元素可被迭代</span></span><br><span class="line">  Long p = iter.next();<span class="comment">//获取当前迭代的</span></span><br><span class="line">  System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>jdk8提供的新的遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;<span class="comment">//匿名内部类</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">    System.out.println(aLong);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda表达式来替代匿名内部类的写法</span></span><br><span class="line"><span class="comment">//配合函数式接口[只能包含一个抽象方法]</span></span><br><span class="line">System.out.println(<span class="string">&quot;======lambda====&quot;</span>);</span><br><span class="line">list.forEach(e -&gt; System.out.println(e));</span><br><span class="line">            </span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="LinkedList-C"><a href="#LinkedList-C" class="headerlink" title="LinkedList[C]"></a>LinkedList[C]</h1><blockquote><p>有序的序列,<strong>底层的数据结构双向链表</strong>,jdk6以及之前是双向循环链表</p><p>链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动.</p><p>适合解决栈列和队列的业务题型 - 贪吃蛇</p><p>栈列 - 先进后出</p><p>队列 - 先进先出</p></blockquote><h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><blockquote><p>相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址.</p></blockquote><blockquote><ol><li><p>单向链表</p><p>head - 头节点</p><p>tail - 尾节点</p><p>element - 节点中真正的保存的数据</p><p>next - 下一个节点的地址</p><p><img src="/2021/07/25/day11/link01.png"> </p></li><li><p>单向循环链表</p><p>尾节点的next又指向了头节点.</p><p><img src="/2021/07/25/day11/link02.png"> </p></li><li><p>双向链表 - LinkedList底层数据结构</p><p>增加了一个pre - 保存的是上一个节点的地址.</p><p><img src="/2021/07/25/day11/link03.png"> </p></li><li><p>双向循环链表</p><p><img src="/2021/07/25/day11/link04.png"> </p></li></ol></blockquote><h2 id="剖析源码"><a href="#剖析源码" class="headerlink" title="剖析源码"></a>剖析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node代表的是链表的节点 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   E item;<span class="comment">//真正的元素</span></span><br><span class="line">   Node&lt;E&gt; next;<span class="comment">//下一个节点的地址</span></span><br><span class="line">   Node&lt;E&gt; prev;<span class="comment">//上一个节点的地址</span></span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">     <span class="keyword">this</span>.item = element;</span><br><span class="line">     <span class="keyword">this</span>.next = next;</span><br><span class="line">     <span class="keyword">this</span>.prev = prev;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表如何插入一个新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第一次进入last最后一个节点Node - null</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//l = null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二次进入 l = new Node&lt;&gt;(null,&quot;ok&quot;,null)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次进入</span></span><br><span class="line">  <span class="comment">//newNode = new Node&lt;&gt;(null,&quot;ok&quot;,null)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二次进入</span></span><br><span class="line">  <span class="comment">//newNode =  new Node&lt;&gt;(链表中原来的最后一个节点l, &quot;java&quot;, null);</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//新插入的节点肯定是作为最后一个节点 - 尾节点</span></span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//第一次进入,链表之前没有任何元素</span></span><br><span class="line">    first = newNode;<span class="comment">//新的节点作为头节点</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//原来链表中的最后一个节点的next同时也指向新的节点</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>查找源码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//index = 3</span></span><br><span class="line">  <span class="comment">// 假设集合中有10个元素 = size = 10</span></span><br><span class="line"><span class="comment">//index&lt;5 - 链表的坐标</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;<span class="comment">//确定头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">      x = x.next;</span><br><span class="line">      <span class="comment">//① - x第二个 ,i=0</span></span><br><span class="line">      <span class="comment">//i=1  x第三个</span></span><br><span class="line">      <span class="comment">//i=2  x第四个</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//index&gt;=5</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>删除源码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   <span class="comment">//找到index对应的Node对象,传入到了unlink方法中.</span></span><br><span class="line">   <span class="keyword">return</span> unlink(node(index));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//防止删除的是头节点</span></span><br><span class="line">    first = next;<span class="comment">//需要删除的那个节点的下一个节点作为头节点了.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//删除的是中间节点</span></span><br><span class="line">    prev.next = next;<span class="comment">//原来节点的上一个节点的next指向原来节点的下一个节点</span></span><br><span class="line">    x.prev = <span class="keyword">null</span>;<span class="comment">//优化,更快让GC会回收pre指针.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是尾结点</span></span><br><span class="line">    last = prev;<span class="comment">//原来节点的上一个节点作为尾节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//删除的是中间节点</span></span><br><span class="line">    next.prev = prev;<span class="comment">//原来节点的下一个节点指向原来节点的上一个节点</span></span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  size--;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习-括号匹配"><a href="#练习-括号匹配" class="headerlink" title="练习-括号匹配"></a>练习-括号匹配</h2><p><img src="/2021/07/25/day11/bc.png"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11.homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 括号匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/29 1:51 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BracketsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入括号:&gt;&quot;</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(matches(line))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 将字符串转成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = line.toCharArray();</span><br><span class="line">        <span class="comment">//2. 新建一个LinkedList集合</span></span><br><span class="line">        LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//3. 将数组中的第一个元素压入栈顶</span></span><br><span class="line">        list.push(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//4. 从arr数组的第二个位置开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//()[]&#123;&#125;</span></span><br><span class="line">            <span class="comment">//获取当前的arr[i]</span></span><br><span class="line">            Character c = arr[i];</span><br><span class="line">            <span class="comment">//为了避免在栈顶已经没有元素的情况下还去获取栈顶元素,非空判断</span></span><br><span class="line">            <span class="keyword">if</span>(list.isEmpty())&#123;</span><br><span class="line">                list.push(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5. 先获取栈顶元素</span></span><br><span class="line">            Character top = list.getFirst();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 栈顶元素和当前的arr[i]进行匹配</span></span><br><span class="line">            <span class="keyword">if</span>(top.equals(<span class="string">&#x27;(&#x27;</span>)&amp;&amp;c.equals(<span class="string">&#x27;)&#x27;</span>) || top.equals(<span class="string">&#x27;&#123;&#x27;</span>)&amp;&amp;c.equals(<span class="string">&#x27;&#125;&#x27;</span>) || top.equals(<span class="string">&#x27;[&#x27;</span>)&amp;&amp;c.equals(<span class="string">&#x27;]&#x27;</span>))&#123;</span><br><span class="line">                <span class="comment">//弹出栈顶元素</span></span><br><span class="line">                list.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//继续将当前的arr[i]压入栈顶</span></span><br><span class="line">                list.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map-I"><a href="#Map-I" class="headerlink" title="Map[I]"></a>Map[I]</h1><h2 id="HashMap-C"><a href="#HashMap-C" class="headerlink" title="HashMap[C]"></a>HashMap[C]</h2><blockquote><p>数据存储的形式是key-value,针对key是无序不可重复的.</p><p>jdk8.x之前,底层的数据结构是桶数组+链表</p><p>jd8.0开始,底层的数据结构是<strong>桶数组+链表+红黑树</strong></p><p>桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的.</p></blockquote><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2021/07/25/day11/map.png"> </p><p><img src="/2021/07/25/day11/map2.png"> </p><h2 id="剖析put方法"><a href="#剖析put方法" class="headerlink" title="剖析put方法"></a>剖析put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash函数就是扰动函数</span></span><br><span class="line"><span class="comment">//1. 尽可能减少哈希冲突</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map数据结构图示中每个节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;<span class="comment">//单向链表</span></span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认值是null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hash(key)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第一次进来</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次进来,第二次肯定不走</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//第一次肯定会进来</span></span><br><span class="line">    <span class="comment">//1. 对tab进行一个初始化操作</span></span><br><span class="line">    <span class="comment">//2. 得到初始化数组的长度,赋值给了n</span></span><br><span class="line">    n = (tab = resize()).length;<span class="comment">//n=16</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次肯定判断结果为null</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//tab[i] = 新的节点</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//哈希碰撞了,哈希冲突了.</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="comment">//key值冲突了.</span></span><br><span class="line">      <span class="comment">//e = 数组中的旧的Node对象</span></span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">//hash虽然碰撞了,但是key是不一样</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//判断是否为红黑树结构</span></span><br><span class="line">      <span class="comment">//当链表的节点&gt;8个,链表结构转成红黑树结构</span></span><br><span class="line">      <span class="comment">//当红黑树节点&lt;6个,恢复成链表结构</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//链表结构</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//p代表的就是哈希碰撞位置的第一个Node对象</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//新的节点挂载到链表的末尾</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新的节点可能和链表结构中的某个节点的key也是一样的</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//e肯定是不为null</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="comment">//把旧的节点的value赋值给了oldValue,put方法的返回结果</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//新值覆盖旧值</span></span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>扩容方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">//第一进来就会执行到此处 , 16</span></span><br><span class="line">             <span class="comment">//扩容因子是0.75</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="comment">//初始化一个长度为16的数组</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/25/day11/put.png"> </p><h2 id="map集合的迭代方式"><a href="#map集合的迭代方式" class="headerlink" title="map集合的迭代方式"></a>map集合的迭代方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式 - 将map集合中所有的key全部取出来放入到一个Set集合中.</span></span><br><span class="line"><span class="comment">//set集合 - 无序不可重复,map集合的key也是无序不可重复.</span></span><br><span class="line">Set&lt;Integer&gt; sets = maps.keySet();</span><br><span class="line"><span class="comment">//遍历set集合</span></span><br><span class="line">Iterator&lt;Integer&gt; iter = sets.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">  Integer key = iter.next();</span><br><span class="line">  String value = maps.get(key);</span><br><span class="line">  System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式 - 将map集合中的每对key-value封装到了一个内置的Entry对象中</span></span><br><span class="line"><span class="comment">//然后将每个entry对象放入到Set集合中</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter2 = entries.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter2.hasNext())&#123;</span><br><span class="line">  Map.Entry&lt;Integer,String&gt; e = iter2.next();</span><br><span class="line">  Integer key = e.getKey();</span><br><span class="line">  String value = e.getValue();</span><br><span class="line">  System.out.println(key+<span class="string">&quot;-&gt;&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map作业"><a href="#Map作业" class="headerlink" title="Map作业"></a>Map作业</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,.....&#125;</span><br><span class="line"></span><br><span class="line">统计每个随机数出现的次数 - Map集合</span><br><span class="line">  </span><br><span class="line">String str = <span class="string">&quot;sfhdsfkdfdfjdfjdfdjfdsa&quot;</span>;</span><br><span class="line"></span><br><span class="line">String[] arr = [<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;php&quot;</span>,<span class="string">&quot;python&quot;</span>];</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;python java python java mysql java mysql php&quot;</span>;   spilt(<span class="string">&quot;\\s&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> 写一个程序统计每个品牌花费的总费用 - 统计类题型</span><br><span class="line"><span class="number">2.</span> 根据总费用降序排 - 可以暂时不做.          </span><br></pre></td></tr></table></figure><blockquote><p><a href="http://xzc.cn/sYtc8YkClM">http://xzc.cn/sYtc8YkClM</a> - 宝洁作业</p><p><a href="http://xzc.cn/p5acBgPAHf">http://xzc.cn/p5acBgPAHf</a> - <strong>基础弱的 - 1. 当天的代码2遍</strong></p><p>​                                                                    <strong>2. 解决了哪些问题? 列一下自己尚未解决的问题?</strong></p></blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="比较器接口Comparator"><a href="#比较器接口Comparator" class="headerlink" title="比较器接口Comparator"></a>比较器接口Comparator</h2><blockquote><p>jdk8.0开始,在List接口中已经定义了排序的方法</p><p>void sort(Comparator&lt;? super E&gt; c)</p><p>分析:java.util.Comparator<T>[I]函数式接口 - 允许使用lambda表达式 </T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day10.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 集合排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/30 9:29 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSortDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book b1 = <span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">100.0d</span>);</span><br><span class="line">        Book b2 = <span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">200.0d</span>);</span><br><span class="line">        Book b3 = <span class="keyword">new</span> Book(<span class="number">3</span>,<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">200.0d</span>);</span><br><span class="line">        Book b4 = <span class="keyword">new</span> Book(<span class="number">4</span>,<span class="string">&quot;1004&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="number">300.0d</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bookList.add(b1);</span><br><span class="line">        bookList.add(b2);</span><br><span class="line">        bookList.add(b3);</span><br><span class="line">        bookList.add(b4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        bookList.sort(new Comparator&lt;Book&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Book o1, Book o2) &#123;</span></span><br><span class="line"><span class="comment">//                if(o1.getPrice()&gt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                    return -1;</span></span><br><span class="line"><span class="comment">//                else if(o1.getPrice()&lt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                    return 1;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据价格降序排</span></span><br><span class="line"><span class="comment">//        bookList.sort((o1,o2)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            if(o1.getPrice()&gt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                return -1;</span></span><br><span class="line"><span class="comment">//            else if(o1.getPrice()&lt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                return 1;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据编号降序排 - String类型</span></span><br><span class="line"><span class="comment">//        bookList.sort((o1, o2) -&gt; o2.getIsbn().compareTo(o1.getIsbn()));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据价格降序排,如果价格一样的话,按照编号继续降序排</span></span><br><span class="line">        bookList.sort((o1,o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.getPrice()&gt;o2.getPrice())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(o1.getPrice()&lt;o2.getPrice())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> o2.getIsbn().compareTo(o1.getIsbn());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="可比较接口"><a href="#可比较接口" class="headerlink" title="可比较接口"></a>可比较接口</h2><blockquote><p>排序的对象对应的实体类实现java.lang.Comparable<T>接口</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11.compares;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/30 10:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Teacher</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Teacher&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;id=&quot;</span>).append(id);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;, age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Teacher o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定制排序的规则</span></span><br><span class="line">        <span class="keyword">return</span> o.age - <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11.compares;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/30 10:54 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTeacherSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher t1 = <span class="keyword">new</span> Teacher(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Teacher t2 = <span class="keyword">new</span> Teacher(<span class="number">2</span>,<span class="string">&quot;jack&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        Teacher t3 = <span class="keyword">new</span> Teacher(<span class="number">3</span>,<span class="string">&quot;james&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Teacher t4 = <span class="keyword">new</span> Teacher(<span class="number">4</span>,<span class="string">&quot;rose&quot;</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Teacher&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(t1);</span><br><span class="line">        list.add(t2);</span><br><span class="line">        list.add(t3);</span><br><span class="line">        list.add(t4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (Teacher teacher : list) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(teacher);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Teacher teacher : list) &#123;</span><br><span class="line">            System.out.println(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><blockquote><p>java.util.Collections[C] - 集合工具类</p><p>面试题 - Collection和Collections有什么区别?</p><ol><li><p>static <T> void    sort(List<T> list, Comparator&lt;? super T&gt; c)<br>根据指定的比较器引起的顺序对指定的列表进行排序。</T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(bookList,((o1, o2) -&gt; (<span class="keyword">int</span>) (o2.getPrice()-o1.getPrice())));</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口</T></li></ol></blockquote><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><blockquote><p>Set[I]接口下的实现类 - 存储的数据是无序不可重复复的.</p><p>添加数据到容器的原理:</p><ol><li>当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值.</li><li>如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置</li><li>如果这个哈希值在这之前出现过了.产生了哈希碰撞或者哈希冲突.但是这个时候,还不能确定哈希碰撞的俩个对象是同一个对象</li><li>继续调用对象的equals方法,如果返回true,说明是同一个对象.则拒绝添加.</li></ol><p>底层数据结构</p><ol><li>散列表</li><li>桶数组 + 链表 + 红黑树</li></ol></blockquote><blockquote><p>查看HashSet源码</p><p>Set<Teacher> sets = new HashSet&lt;&gt;();</Teacher></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//HashSet的底层是HashMap</span></span><br><span class="line">  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet的add方法的底层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的e是添加到容器中的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实际上还是在调用map的put方法</span></span><br><span class="line">  <span class="comment">//HashSet中添加的对象是作为了Map集合的key</span></span><br><span class="line">  <span class="comment">//Map的key具有什么特点 = HashSet中的数据有何特点.</span></span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="HashMap-和-HashTable-区别"><a href="#HashMap-和-HashTable-区别" class="headerlink" title="HashMap 和 HashTable 区别"></a>HashMap 和 HashTable 区别</h2><blockquote><p>HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null  key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下:</p><ol><li><p>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p></li><li><p>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</p></li><li><p>HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</p></li><li><p>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</p></li><li><p>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</p></li></ol></blockquote><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><blockquote><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</li></ol></blockquote><h2 id="List和Set区别"><a href="#List和Set区别" class="headerlink" title="List和Set区别"></a>List和Set区别</h2><blockquote><p>两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下：</p><ol><li>List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。</li><li> 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。</li><li> List可以通过下标来访问，而Set不能。</li></ol></blockquote><h2 id="HashSet和HashMap区别"><a href="#HashSet和HashMap区别" class="headerlink" title="HashSet和HashMap区别"></a>HashSet和HashMap区别</h2><blockquote><p>HashSet的底层是HashMap</p></blockquote><blockquote><table><thead><tr><th><em>HashMap</em></th><th><em>HashSet</em></th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap储存键值对</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用put()方法将元素放入map中</td><td>使用add()方法将元素放入set中</td></tr><tr><td>HashMap中使用键对象来计算hashcode值</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap比较快，因为是使用唯一的键来获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></blockquote><h2 id="ArrayList和HashSet区别"><a href="#ArrayList和HashSet区别" class="headerlink" title="ArrayList和HashSet区别"></a>ArrayList和HashSet区别</h2><blockquote><p>1.HashSet 是不重复的 而且是无序的!</p><p>​     唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数</p><p>​     HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分,</p><p>2.ArrayList是可重复的 有序的</p><p>​    特点：查询效率高，增删效率低 轻量级 线程不安全。</p><p>   arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快</p></blockquote><h2 id="HashSet和TreeSet区别"><a href="#HashSet和TreeSet区别" class="headerlink" title="HashSet和TreeSet区别"></a>HashSet和TreeSet区别</h2><blockquote><p><strong>一、HashSet</strong></p><p>HashSet内部的数据结构是哈希表，是线程不安全的。</p><p>HashSet当中，保证集合中元素是唯一的方法。</p><p>通过对象的hashCode和equals方法来完成对象唯一性的判断。</p><p>假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。</p><p>假如，结果是true，那么就要视作相同元素，不存。</p><p>假如，结果是false，那么就视为不同元素，存储。</p><p>注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。</p><p><strong>二、TreeSet</strong></p><p>TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。</p><p>TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。</p><p>TreeSet对元素进行排序的方式：</p><p>1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。</p><p>2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。</p><p>除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。</p><p>也就是其元素的存入和输出的顺序是相同的。</p></blockquote><h2 id="HashMap和TreeMap区别"><a href="#HashMap和TreeMap区别" class="headerlink" title="HashMap和TreeMap区别"></a>HashMap和TreeMap区别</h2><blockquote><p>HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。</p><p>另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。</p><p>HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。</p><p>TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。           </p></blockquote><h2 id="ArrayList和Vector区别"><a href="#ArrayList和Vector区别" class="headerlink" title="ArrayList和Vector区别"></a>ArrayList和Vector区别</h2><blockquote><ol><li>Vector是线程安全的，ArrayList不是线程安全的。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</li></ol></blockquote><h1 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h1><blockquote><p>贪吃蛇算法 - LinkedList-操作头和尾-适合解决队列和栈列的业务题目</p></blockquote><blockquote><h6 id="算法的思路"><a href="#算法的思路" class="headerlink" title="算法的思路"></a>算法的思路</h6><p>蛇移动,判断方向,#### - 坐标</p><ol><li>蛇头节点的坐标getFirst() -&gt; 移动之后的新的节点</li><li>不管新的节点是否为食物.蛇linkeList集合果断先将新的节点加入到该链表的头结点中.addFirst</li><li>判断新的节点如果是食物的节点,那么链表就不删除最后一个节点.否则删除链表的最后一个节点.</li></ol></blockquote><h1 id="TreeSet-C"><a href="#TreeSet-C" class="headerlink" title="TreeSet[C]"></a>TreeSet[C]</h1><blockquote><p>简单了解一下</p><p>Set[I] - SortedSet[I] - TreeSet[C] - 底层是TreeMap[C] - 使map集合的key根据定制的规则来进行排序.</p><p>Set - 无序不可重复的.</p><p>TreeSet - 不可重复的,但是可以根据定制的排序规则来进行排序.</p></blockquote><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><blockquote><p>java.util.stream.Stream;</p><p>它和传统的集合框架在性能上的比较.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day10</title>
    <link href="http://example.com/2021/07/24/day10/"/>
    <id>http://example.com/2021/07/24/day10/</id>
    <published>2021-07-24T10:02:10.000Z</published>
    <updated>2022-01-07T08:55:44.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h1><blockquote><p>每个基本类型都有其对应的包装类型[对象类型]</p><p>byte-&gt;Byte</p><p>short-&gt;Short</p><p><strong>int-&gt;Integer</strong></p><p>long-&gt;Long</p><p>float-&gt;Float</p><p><strong>double-&gt;Double</strong></p><p><strong>char-&gt;Character</strong></p><p>boolean-&gt;Boolean</p><p><strong>学习掌握目标</strong></p><ol><li><strong>包装类型的api的常用方法</strong></li><li><strong>包装类型和基本数据类型以及String类型三者之间的相互转换问题.</strong></li></ol></blockquote><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><blockquote><p>api:java.lang包,所有关于上面包装类型[数字]的共同的抽象的父类.</p><table><thead><tr><th><code>byte</code></th><th><code>byteValue()</code>返回指定号码作为值 <code>byte</code> ，这可能涉及舍入或截断。</th></tr></thead><tbody><tr><td><code>abstract double</code></td><td><code>doubleValue()</code>返回指定数字的值为 <code>double</code> ，可能涉及四舍五入。</td></tr><tr><td><code>abstract float</code></td><td><code>floatValue()</code>返回指定数字的值为 <code>float</code> ，可能涉及四舍五入。</td></tr><tr><td><code>abstract int</code></td><td><code>intValue()</code>返回指定号码作为值 <code>int</code> ，这可能涉及舍入或截断。</td></tr><tr><td><code>abstract long</code></td><td><code>longValue()</code>返回指定数字的值为 <code>long</code> ，可能涉及四舍五入或截断。</td></tr><tr><td><code>short</code></td><td><code>shortValue()</code>返回指定号码作为值 <code>short</code> ，这可能涉及舍入或截断。</td></tr></tbody></table></blockquote><p><code>提供的这些方法都是关于包装类型转换成对应的基本类型的方法</code></p><h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><blockquote><ol><li><p>Integer(int i);//利用int类型的整数来构建一个Integer对象 - int类型-&gt;Integer类型</p></li><li><p>Integer(String s);//此处的字符串一定是数字形式的字符串 - String类型-&gt;Integer类型</p><p>如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常</p></li></ol></blockquote><h2 id="自动解封箱"><a href="#自动解封箱" class="headerlink" title="自动解封箱"></a>自动解封箱</h2><blockquote><p>jdk5.x开始支持的新的功能</p></blockquote><blockquote><ol><li>封箱 - 基本数据类型可以自动转换成对应的包装类型</li><li>解箱 - 包装类型可以自动转换成对应的基本的数据类型</li></ol></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>static Integer valueOf(int i);//将int-&gt;Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">128</span>,<span class="number">127</span>] -&gt; 比较的结果是<span class="keyword">true</span>,不在这个范围的是返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果[-128,127]之间,那么直接返回内部的缓冲数组中的数据</span></span><br><span class="line"><span class="comment">//如果不在这个范围,返回一个新的Integer对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Integer类内部有一个静态内部类</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">//缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">      cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> j = low;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  [-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false</span></span><br><span class="line"><span class="comment">//剖析自动封箱</span></span><br><span class="line">Integer a = <span class="number">127</span>;<span class="comment">//Integer a = Integer.valueOf(127);</span></span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">admindeMacBook-Pro:Desktop admin$ javap -c IntegerHello</span><br><span class="line">Compiled from <span class="string">&quot;IntegerHello.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerHello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IntegerHello</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">127</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: bipush        <span class="number">127</span></span><br><span class="line">       <span class="number">8</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="number">11</span>: astore_2</span><br><span class="line">      <span class="number">12</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">15</span>: aload_1</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">      <span class="number">19</span>: bipush        <span class="number">7</span></span><br><span class="line">      <span class="number">21</span>: if_icmpne     <span class="number">28</span></span><br><span class="line">      <span class="number">24</span>: iconst_1</span><br><span class="line">      <span class="number">25</span>: goto          <span class="number">29</span></span><br><span class="line">      <span class="number">28</span>: iconst_0</span><br><span class="line">      <span class="number">29</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line">      <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于进制转换的方法</p><p>2-1. static String toBinaryString(int n);//十进制n转换成对应的二进制</p><p>2-2. static String toHexString(int n);//十进制n转换成对应的十六进制</p><p>2-3. static String toOctalString(int n);//十进制n转换成对应的八进制</p></li><li><p>static int parseInt(String s);//将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常</p></li><li><p>static Integer valueOf(String s);//String-&gt;Integer</p></li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>包装类型和基本数据类型以及String类型三者之间的相互转换问题.</strong></p></blockquote><blockquote><ol><li><p>int-&gt;Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer的构造Integer(<span class="keyword">int</span> n)</span><br><span class="line"><span class="number">2.</span> jdk5<span class="number">.0</span>提供的自动封箱Integer a = <span class="number">10</span>;</span><br><span class="line"><span class="number">3.</span> java.lang.Integer提供的<span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Integer -&gt; int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;<span class="comment">//java.lang.Number提供的抽象方法,java.lang.Integer重写了该方法</span></span><br><span class="line"><span class="number">2.</span> jdk5<span class="number">.0</span>提供的自动解箱</span><br></pre></td></tr></table></figure></li><li><p>int-&gt;String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.String提供的方法<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>String-&gt;int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer类<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>String-&gt;Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer的构造Integer(String n)</span><br><span class="line"><span class="number">2.</span> java.lang.Integer的方法<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(String n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Integer-&gt;String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer的<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2.</span> java.lang.String中提供了<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><blockquote><p>笔试题:int和Integer之间的区别</p><ol><li>Integer是int的包装类；int是基本数据类型；</li><li>Integer变量必须实例化后才能使用；int变量不需要；</li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li><li>Integer的默认值是null；int的默认值是0。</li><li>泛型不支持int，但是支持Integer</li><li>int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。</li></ol></blockquote><h2 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h2><p><img src="/2021/07/24/day10/%E6%9D%A1%E5%BD%A2%E7%A0%81.png"> </p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><blockquote><p>java.lang.Object类是所有的类的基类,根类,超类</p><p>所有的类如果没有明确指定父类,都会默认继承Object类.</p></blockquote><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><blockquote><ol><li><p>boolean equals(Object obj);//对象之间的比较.默认仍然使用的是==</p><p><strong>“业内认可的一种说法” - 基本类型用==比较的值,对象类型用==比较的是地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的比较方式不符合实际的业务需要,因此需要重写equals方法</p><p>success版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="comment">//1. 非空性</span></span><br><span class="line">  <span class="keyword">if</span>(obj == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//2. 自反性</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == obj)<span class="comment">//p1.equals(p1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//3. 一致类型,判断具体的哪个属性是一致的,才认为返回true</span></span><br><span class="line">  <span class="comment">// p1.equals(user);</span></span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Product)&#123;</span><br><span class="line">    Product p = (Product) obj;</span><br><span class="line">    <span class="comment">//return this.id == p.id;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//id和name都一致的时候,才认为是同一个对象</span></span><br><span class="line">    <span class="comment">//return (this.id == p.id) &amp;&amp; (this.name.equals(p.name));</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//需求 - 认为产品的id以及这个产品对应的产品信息的id一致的时候认为返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id == p.id &amp;&amp; <span class="keyword">this</span>.getProductInfo().equals(p.productInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><blockquote><p>int hashCode();//返回对象的哈希值.一般是和equals方法是成对出现的.目的是为了<strong>提高性能.</strong></p></blockquote><blockquote><p>容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法</p><p>而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间]</p></blockquote><blockquote><p><strong><code>关于数字31</code> - 质数 - 1. 尽可能产生更多的哈希值  2. 让哈希碰撞/冲突尽可能少.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">  result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">  result = <span class="number">31</span> * result + (productInfo != <span class="keyword">null</span> ? productInfo.hashCode() : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>超前知识点</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day10.hashcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/28 2:01 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Course c1 = <span class="keyword">new</span> Course(<span class="number">1</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Course c2 = <span class="keyword">new</span> Course(<span class="number">2</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c3 = <span class="keyword">new</span> Course(<span class="number">3</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c4 = <span class="keyword">new</span> Course(<span class="number">4</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c5 = <span class="keyword">new</span> Course(<span class="number">5</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c6 = <span class="keyword">new</span> Course(<span class="number">1</span>,<span class="string">&quot;oracle&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(c1 == c2);//false</span></span><br><span class="line"><span class="comment">//        System.out.println(c1.equals(c2));//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合 - &quot;容器&quot;,比数组更加强大的.</span></span><br><span class="line">        <span class="comment">//集合 - 里面存储的数据是无序不可重复的</span></span><br><span class="line">        <span class="comment">//不能存储同一个对象</span></span><br><span class="line">        Set&lt;Course&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//1. 当把某个对象放入到该容器之前,先调用了该对象的hashCode方法,得到一个哈希值</span></span><br><span class="line">        <span class="comment">//2. 根据这个哈希值就可以被分配一个内存地址</span></span><br><span class="line">        <span class="comment">//3. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用.那么就会直接将该对象放入到</span></span><br><span class="line">        <span class="comment">//   这个哈希值对应的在容器中的那个位置</span></span><br><span class="line">        <span class="comment">//4. 如果这个哈希值在这之前出现过.但是此时还不能说明这个对象和之前的那个对象是同一个对象?</span></span><br><span class="line">        <span class="comment">//   因为哈希值是通过哈希算法计算得到的,可能产生&quot;哈希冲突&quot; - &quot;哈希碰撞&quot;</span></span><br><span class="line">        <span class="comment">//5. 当哈希值一样的时候,那么才会去调用equals方法,如果equals方法仍然返回true,那么才</span></span><br><span class="line">        <span class="comment">//   最终确定这个对象曾经出现过,那么就拒绝添加.</span></span><br><span class="line">        sets.add(c1);</span><br><span class="line">        sets.add(c2);</span><br><span class="line">        sets.add(c3);</span><br><span class="line">        sets.add(c4);</span><br><span class="line">        sets.add(c5);</span><br><span class="line">        sets.add(c6);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Course c : sets) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><ol><li>如果俩个对象的hashcode值一样,那么equals比较,不一定返回true</li><li>如果俩个对象equals返回true,那么这俩个对象的哈希值必须要一样 - 数据的完整性.</li></ol></blockquote><h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><blockquote><p>== 和 equals的区别</p><ol><li>== 基本类型使用,比较的就是基本类型的数值</li><li>equals 对象类型使用.如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true.</li></ol></blockquote><h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><blockquote><p>protected Object clone();//默认的克隆方法是浅克隆</p></blockquote><h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><blockquote><p>浅拷贝,浅层复制,浅复制 - 默认的.</p><p>protected - public</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">Object中的clone方法 - <span class="keyword">native</span>修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常.</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Product copy = (Product) p1.clone();</span><br><span class="line"></span><br><span class="line">Product copy2 = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;mac&quot;</span>,<span class="number">1000.0d</span>);</span><br><span class="line"></span><br><span class="line">为什么需要使用clone,而不直接<span class="keyword">new</span>一个.</span><br><span class="line">clone方法它直接操作的堆里面的内存 - 效率是高于重新<span class="keyword">new</span>的.</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day10.obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/28 2:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCloneDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product p1 = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;mac&quot;</span>,<span class="number">1000.0d</span>);</span><br><span class="line">        ProductInfo info = <span class="keyword">new</span> ProductInfo(<span class="number">1</span>,<span class="string">&quot;good&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.setProductInfo(info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(p1 instanceof Cloneable);//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//浅拷贝</span></span><br><span class="line">            Product copy = (Product) p1.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1. 修饰基本数据类型以及字符串 - 原来的对象 - 是否对copy对象产生影响 - 不会</span></span><br><span class="line">            p1.setId(<span class="number">10</span>);</span><br><span class="line">            p1.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 修改对象类型 - 会对copy的对象产生影响的</span></span><br><span class="line">            p1.getProductInfo().setId(<span class="number">100</span>);</span><br><span class="line">            p1.getProductInfo().setInfo(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(copy);</span><br><span class="line">            System.out.println(copy.getProductInfo());</span><br><span class="line">            <span class="comment">//System.out.println(copy == p1);//false</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;<span class="comment">//不能被克隆的异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><blockquote><p>深层复制,深拷贝,深复制 - 需要自己重写clone里面的具体的代码的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深拷贝 - 修改原来对象中的任何类型的数据都不会对副本对象产生影响</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="comment">//Product copy = (Product)p1.clone();</span></span><br><span class="line">  <span class="comment">//手动新建一个Product对象</span></span><br><span class="line">  Product product = <span class="keyword">new</span> Product();</span><br><span class="line">  product.setId(id);</span><br><span class="line">  product.setName(name);</span><br><span class="line">  product.setPrice(price);</span><br><span class="line"></span><br><span class="line">  ProductInfo infos = getProductInfo();</span><br><span class="line">  <span class="keyword">if</span>(infos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    ProductInfo pi = <span class="keyword">new</span> ProductInfo();</span><br><span class="line">    pi.setId(infos.getId());</span><br><span class="line">    pi.setInfo(infos.getInfo());</span><br><span class="line"></span><br><span class="line">    product.setProductInfo(pi);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><p>就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用.</p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api:java.util</span><br><span class="line">  </span><br><span class="line">Collection[I]</span><br><span class="line">  - List[I] - 有序可重复</span><br><span class="line">    - ArrayList[C]</span><br><span class="line">    - LinkedList[C]</span><br><span class="line">    - Vector[C]</span><br><span class="line">  - Set[I] - 无序不可重复</span><br><span class="line">    - HashSet[C]</span><br><span class="line">    - SortedSet[I]</span><br><span class="line">      - TreeSet[C]</span><br><span class="line">Map[I]</span><br><span class="line">  - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复.</span><br><span class="line">  - Hashtable[C]</span><br><span class="line">    - Properteis[C] - 属性文件在内存中的映射的对象</span><br></pre></td></tr></table></figure><h2 id="Collection-I"><a href="#Collection-I" class="headerlink" title="Collection[I]"></a>Collection[I]</h2><blockquote><ol><li>boolean add(E e);//向容器中添加一个元素</li><li>void clear();//清空容器</li><li>boolean contains(Object o);//判断容器中是否包含某个对象</li><li>boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true</li><li>Iterator<E>    iterator();// 获取集合对象的迭代器</E></li><li>boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个</li><li>int size();//返回集合中的数据的个数 - 集合的大小</li></ol></blockquote><h2 id="List-I"><a href="#List-I" class="headerlink" title="List[I]"></a>List[I]</h2><blockquote><p>特点 - 有序并且是可以重复的.</p><ol><li>E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1]</li><li>int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</li><li>E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素</li><li>Object[] toArray();//将集合转换成数组.</li></ol></blockquote><h1 id="ArrayList-C"><a href="#ArrayList-C" class="headerlink" title="ArrayList[C]"></a>ArrayList[C]</h1><blockquote><p>特点:有序可重复的,<strong>底层数据结构就是一个”动态增长”的数组.</strong></p><p>优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高.</p><p>缺点:增删效率会低.</p></blockquote><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就是真正的存储数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1. 初始化elementData,长度为0</span></span><br><span class="line">  <span class="comment">//2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  <span class="comment">//this.elementData = &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剖析add方法"><a href="#剖析add方法" class="headerlink" title="剖析add方法"></a>剖析add方法</h2><blockquote><p>ArrayList扩容的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;<span class="comment">//第一次进来1</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次minCapacity = 10</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续ensureExplicitCapacity(minCapacity);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="comment">//第一次进来10-0&gt;0</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grow(minCapacity)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次</span></span><br><span class="line">  <span class="comment">//oldCapacity = 0</span></span><br><span class="line">  <span class="comment">//newCapacity = 0</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//第一次会进来</span></span><br><span class="line">    newCapacity = minCapacity;<span class="comment">//newCapacity = 10</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h2><blockquote><ol><li><p>直接输出</p></li><li><p>增强for循环 - 只读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常</span><br><span class="line">      </span><br><span class="line">实际的底层,调用迭代器对象中的next方法</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//modCount是当初调用add方法,添加1个元素,modCount自增1个</span></span><br><span class="line">   <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">发现只要调用了remove方法 - modCount++</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day09</title>
    <link href="http://example.com/2021/07/23/day09/"/>
    <id>http://example.com/2021/07/23/day09/</id>
    <published>2021-07-23T10:02:10.000Z</published>
    <updated>2022-01-07T06:46:52.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-lang-String"><a href="#java-lang-String" class="headerlink" title="java.lang.String"></a>java.lang.String</h1><blockquote><p>Java中提供的处理字符串的类.</p><ol><li><p>不可变的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;eef&quot;</span>;<span class="comment">//ok,&quot;abc&quot;就变成了垃圾对象.</span></span><br></pre></td></tr></table></figure></li><li><p>字符串本质上就是一个字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final修饰的类不可被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//维护的是不可变的字符数组</span></span><br><span class="line">    <span class="comment">//String s = &quot;abc&quot;;//将&quot;abc&quot;打散,保存成value[]数组中.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="字符串构建的方式"><a href="#字符串构建的方式" class="headerlink" title="字符串构建的方式"></a>字符串构建的方式</h2><blockquote><ol><li><p>通过new关键字来构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了几个对象?</span></span><br><span class="line"><span class="comment">//1个或者2个</span></span><br><span class="line"><span class="comment">//①通过new关键字在堆里面创建一个字符串对象&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//②同时在&quot;串池&quot;里面扔一个对象&quot;abc&quot;[前提是串池中之前不存在&quot;abc&quot;]</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>直接通过”串池”/“字符串常量池”的方式来构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了几个对象?</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//它会在&quot;串池&quot;中创建一个&quot;abc&quot;字符串对象,然后将地址给了s1</span></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//&quot;串池&quot;中的特点:优先先到串池中查找是否已经存在&quot;abc&quot;对象,如果有直接返回地址给s2</span></span><br><span class="line"><span class="comment">//否则才会继续创建新的字符串对象</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="关于字符串的拼接"><a href="#关于字符串的拼接" class="headerlink" title="关于字符串的拼接"></a>关于字符串的拼接</h2><blockquote><p>字符串的拼接使用+,但是使用+的拼接效率非常低.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符串拼接效率低</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 2:15 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPlusDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test02();<span class="comment">//append</span></span><br><span class="line"></span><br><span class="line">        test01();<span class="comment">//+</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();<span class="comment">//获取当前系统时间的毫秒数</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            str+=i;<span class="comment">//str = str + i;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str拼接时间:&quot;</span>+(t2-t1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//java.lang.StringBuilder</span></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();<span class="comment">//获取当前系统时间的毫秒数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">           builder.append(i);<span class="comment">//拼接方式</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;append拼接时间:&quot;</span>+(t2-t1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>拼接效率的原因</code></p><blockquote><ol><li>+底层每次都会产生一个StringBuilder对象</li><li>+底层仍然是调用StringBuilder中的append方法</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">字符串使用+拼接的过程中,会产生新的对象 - 拼接效率低</span><br><span class="line"></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  </span><br><span class="line">admindeMacBook-Pro:Desktop admin$ javap -c HelloStr</span><br><span class="line">Compiled from <span class="string">&quot;HelloStr.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStr</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloStr</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc  放在了&quot;串池中&quot;</span></span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">       <span class="number">6</span>: dup                               <span class="comment">// &quot;abc&quot; -&gt; 堆里面</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc  &quot;串池中已经出现了&quot;</span></span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: astore_2</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = s1 + s2;<span class="comment">//会产生一个新的对象</span></span><br><span class="line"></span><br><span class="line">admindeMacBook-Pro:Desktop admin$ javap -c HelloStr</span><br><span class="line">Compiled from <span class="string">&quot;HelloStr.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStr</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloStr</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">       <span class="number">6</span>: dup</span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String def</span></span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: astore_2</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">                              <span class="comment">//字符串每次拼接+,都会产生一个新的StringBuilder对象</span></span><br><span class="line">      <span class="number">16</span>: dup</span><br><span class="line">      <span class="number">17</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">                          <span class="comment">//StringBuilder builder = new StringBuilder();</span></span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:</span></span><br><span class="line">                                          <span class="comment">//(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串的+,底层仍然是去调用StringBuilder类中提供的append方法</span></span><br><span class="line">      <span class="number">24</span>: aload_2</span><br><span class="line">      <span class="number">25</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">28</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">31</span>: astore_1</span><br><span class="line">      <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符串的各种比较</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 2:35 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCompare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//s1默认指向的是堆里面的字符串对象</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//intern()强制让s1指向串池的对象</span></span><br><span class="line">        System.out.println(s1.intern() == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;a&quot;</span> + s3;<span class="comment">//产生一个StringBuilder对象</span></span><br><span class="line">        String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;<span class="comment">//因为此处的&quot;a&quot;和&quot;b&quot;就是字符串常量</span></span><br><span class="line">                              <span class="comment">//jvm对待字符串常量的拼接 - &quot;a&quot;和&quot;b&quot;的拼接</span></span><br><span class="line">                              <span class="comment">//当成&quot;ab&quot;的整体,直接扔到常量池中.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s4 == s5);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> String s6 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="comment">//&quot;a&quot;+s6 =&gt; &quot;ab&quot;扔到常量池,没有产生新的对象.</span></span><br><span class="line">        String s7 = <span class="string">&quot;a&quot;</span> + s6;</span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String x1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String x2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(x1 == x2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//希望字符串的值是一样的,就希望返回true</span></span><br><span class="line">        System.out.println(x1.equals(x2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><blockquote><p>构造方法</p><p>String();</p><p>String(String val);</p><p>String(StringBuilder builder);//StringBuilder对象转换成String对象</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符串常用方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 3:02 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">// java.lang.StringIndexOutOfBoundsException</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));<span class="comment">//b</span></span><br><span class="line">        System.out.println(s.length());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        String result = s.concat(<span class="string">&quot;de&quot;</span>);<span class="comment">//原来的字符串的末尾添加新的字符串</span></span><br><span class="line">        System.out.println(result);<span class="comment">//abcde</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断字符串中是否包含某个序列</span></span><br><span class="line">        System.out.println(s.contains(<span class="string">&quot;bc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断前缀或者后缀</span></span><br><span class="line">        System.out.println(<span class="string">&quot;xxx.gif&quot;</span>.endsWith(<span class="string">&quot;.gif&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;javaScript&quot;</span>.startsWith(<span class="string">&quot;java&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(s));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略大小写的比较</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;abc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换大写和小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.toUpperCase());<span class="comment">//ABC</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.toLowerCase());<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回指定字符第一次出现的字符串内的索引。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcabc&quot;</span>.indexOf(<span class="string">&quot;b&quot;</span>));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abcabc&quot;</span>.lastIndexOf(<span class="string">&quot;b&quot;</span>));<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.isEmpty());<span class="comment">//长度为0的字符串 - 返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;I Love Girl&quot;</span>.replace(<span class="string">&quot;Girl&quot;</span>,<span class="string">&quot;Java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串的切割</span></span><br><span class="line">        String ip = <span class="string">&quot;192:168:3:90&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String[] arr = ip.split(<span class="string">&quot;\\:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s1 : arr) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串转换成char类型数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr2 = <span class="string">&quot;白日依山尽&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr2) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String x1 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">        String x2 = x1.substring(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//[1,3)</span></span><br><span class="line">        System.out.println(x2);</span><br><span class="line"></span><br><span class="line">        System.out.println(x1.substring(<span class="number">1</span>));<span class="comment">//从1一直截取到最后bcde</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//trim() - 去除字符串左右两边的空格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;  ab c  &quot;</span>.trim().length());<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;       &quot;</span>.trim().length());<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int-&gt;String</span></span><br><span class="line">        String o = String.valueOf(<span class="number">10</span>);</span><br><span class="line">        System.out.println(o+<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="java-lang-StringBuilder"><a href="#java-lang-StringBuilder" class="headerlink" title="java.lang.StringBuilder"></a>java.lang.StringBuilder</h1><blockquote><p>它是一个可变的字符串 - final修饰,性能最高的.默认的容量16.线程不安全的</p><p>StringBuilder();</p><p>StringBuilder(String val);//String类型转换成StringBuilder类型</p></blockquote><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><blockquote><p>研究append方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder x = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">x.append(<span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line">StringBuilder类的父类<span class="function">AbstractStringBuilder</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> appendNull();</span><br><span class="line">  <span class="keyword">int</span> len = str.length();<span class="comment">//len = 3</span></span><br><span class="line">  <span class="comment">//count+len</span></span><br><span class="line">  <span class="comment">//count - 原来数组中已经存在的字符的长度</span></span><br><span class="line">  <span class="comment">//len - 需要存入的新的字符串长度</span></span><br><span class="line">  ensureCapacityInternal(count + len);<span class="comment">//3</span></span><br><span class="line">  str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">  count += len;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩容方法</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">    expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正的扩容方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;<span class="comment">//扩容,得到新的长度</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)<span class="comment">//扩容得不够,不够长</span></span><br><span class="line">    newCapacity = minimumCapacity;<span class="comment">//直接补充到最长的.</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;<span class="comment">//长度会溢出.</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    newCapacity = Integer.MAX_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 常用方法 - 可变的字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 4:20 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder x = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//String-&gt;StringBuilder</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line"></span><br><span class="line">        StringBuilder result = x.delete(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//[1,3)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);<span class="comment">//ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span>+x);<span class="comment">//ad</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x.deleteCharAt(<span class="number">0</span>));<span class="comment">//d 根据下标进行删除操作</span></span><br><span class="line"></span><br><span class="line">        x.insert(<span class="number">0</span>,<span class="string">&quot;管管&quot;</span>);</span><br><span class="line">        System.out.println(x);<span class="comment">//管管d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转字符串</span></span><br><span class="line">        System.out.println(x.reverse());<span class="comment">//d管管</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int n = 6723;</span></span><br><span class="line"><span class="comment">//        System.out.println(String.valueOf(n).length());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        StringBuilder y = new StringBuilder(String.valueOf(n));</span></span><br><span class="line"><span class="comment">//        System.out.println(y.reverse());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder-&gt;String</span></span><br><span class="line">        System.out.println(x.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>String类型和StringBuilder类型之间的相互转换问题</p><p>StringBuilder-&gt;String类型</p><ol><li>java.lang.StringBuilder中提供的String toString();</li><li>java.lang.String类中提供的构造方法String(StringBuilder builder);</li><li>java.lang.String类中提供的static String valueOf(Object obj);//面向父类编程    </li></ol></blockquote><blockquote><p>String-&gt;StringBuilder</p><ol><li>java.lang.StringBuilder中提供的构造StringBuilder(String val);</li></ol></blockquote><h1 id="java-lang-StringBuffer"><a href="#java-lang-StringBuffer" class="headerlink" title="java.lang.StringBuffer"></a>java.lang.StringBuffer</h1><blockquote><p>它的使用方式和StringBuilder是一模一样的.唯一区别是它是多线程安全的.可变的字符串</p><p>因为它里面的方法都使用<strong>synchronized</strong>关键字进行了修饰,重量级的对象.</p><p>性能低于StringBuilder</p></blockquote><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><blockquote><p>String,StringBuilder,StringBuffer三者的区别? - 查,<strong>补充完整</strong> - 作业</p><ol><li><p>三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点</p></li><li><p>不同点</p><p>2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的.</p><p>2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的.</p><p>2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String</p></li></ol></blockquote><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><p>两道笔试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从oldStr中删除指定的target字符串</span></span><br><span class="line"><span class="comment">//比如&quot;abcdebcef&quot;,&quot;bc&quot; -&gt; 返回&quot;adeef&quot;</span></span><br><span class="line"><span class="comment">//禁止使用replace方法</span></span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">delByStr</span><span class="params">(String oldStr,String target)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出俩个字符串中的最大长度的公串</span></span><br><span class="line"><span class="comment">//abcbcedfdfdepopoqqq</span></span><br><span class="line"><span class="comment">//fdfdbcbceoifdfdeqqa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bcbce fdfde</span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day08</title>
    <link href="http://example.com/2021/07/22/day08/"/>
    <id>http://example.com/2021/07/22/day08/</id>
    <published>2021-07-22T10:02:10.000Z</published>
    <updated>2022-01-07T06:46:31.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><blockquote><ol><li><strong>static修饰的成员是在JVM加载类的时候就会被立即分配空间以及初始化 - 只有1次</strong>,内存的实例只有1份</li><li>非静态的成员的是在每次创建对象的时候才会被分配空间以及初始化</li></ol></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><ol><li>static修饰符类 - 静态内部类[过]</li><li>修饰的属性 - 静态属性</li><li>方法 - 静态方法</li><li>代码块 - 静态代码块</li></ol></blockquote><h2 id="JVM加载类进内存的活动顺序"><a href="#JVM加载类进内存的活动顺序" class="headerlink" title="JVM加载类进内存的活动顺序"></a>JVM加载类进内存的活动顺序</h2><ol start="0"><li><p>JVM加载类进内存</p></li><li><p>给所有的静态属性分配空间以及初始化</p></li><li><p>给所有的静态方法分配空间以及初始化</p></li><li><p>调用静态代码块</p></li><li><p>如果创建了对象</p><p>4-1. 给这个对象的所有的非静态属性分配空间以及初始化</p><p>4-2. 给这个对象的所有的非静态方法分配空间</p><p>4-3. 调用普通代码块</p><p>4-4. 调用构造块</p></li></ol><h1 id="static关键字应用"><a href="#static关键字应用" class="headerlink" title="static关键字应用"></a>static关键字应用</h1><blockquote><p>设计模式 - 单例模式</p><p>如何保证某个类的对象在内存中永远只有1份.后期,某些类的创建和销毁的时间成本比较高.这些类有必要设计成单例的.</p><p>比如jdbc中的连接池对象[重量级的对象]</p></blockquote><h2 id="饿汉模式-多线程安全"><a href="#饿汉模式-多线程安全" class="headerlink" title="饿汉模式 多线程安全"></a>饿汉模式 多线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 将Singleton01设置成饿汉模式 - 单例的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 9:28 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 初始化一个变量,该变量就是该类的唯一实例[对象]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有化构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较费时费力的代码,可能需要更多的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton01...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公开的静态的方法来返回这个类的唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类的实例</span></span><br><span class="line">        Singleton01 s1 = Singleton01.getInstance();</span><br><span class="line">        Singleton01 s2 = Singleton01.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式-多线程不安全"><a href="#懒汉模式-多线程不安全" class="headerlink" title="懒汉模式 多线程不安全"></a>懒汉模式 多线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 懒汉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 9:35 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span>?instance = <span class="keyword">new</span> Singleton02():instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton02</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Singleton02 s1 = Singleton02.getInstance();</span></span><br><span class="line"><span class="comment">//        Singleton02 s2 = Singleton02.getInstance();</span></span><br><span class="line"><span class="comment">//        System.out.println(s1 == s2);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重检查锁-笔试脱手写的版本"><a href="#双重检查锁-笔试脱手写的版本" class="headerlink" title="双重检查锁 - 笔试脱手写的版本"></a>双重检查锁 - 笔试脱手写的版本</h2><blockquote><p>懒汉模式下 - 仍然是多线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:双重检查锁 - 笔试脱手写的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 10:07 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断.</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//跑得快的线程都会进入此处A,B</span></span><br><span class="line">            <span class="comment">//A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入</span></span><br><span class="line">            <span class="comment">//同步代码块去执行里面的代码</span></span><br><span class="line">            <span class="comment">//假设A线程抢到了,B就会在等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton03.class)&#123;</span><br><span class="line">                <span class="comment">//A进入判断instance==null</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//只要抢到&quot;锁&quot;的线程,如果此处没有非null判断</span></span><br><span class="line">                <span class="comment">//那么进入到这的线程都会去执行instance = new Singleton03();</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//由A线程进行实例的初始化</span></span><br><span class="line">                    <span class="comment">//A继续执行,等A执行完毕之后,那么A就会释放锁资源</span></span><br><span class="line">                    <span class="comment">//其他线程继续争抢锁资源.</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote><ol><li><p>可见性 - 忽略</p></li><li><p>禁止JVM的指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;<span class="comment">//原子性操作</span></span><br><span class="line">   </span><br><span class="line">Student s = <span class="keyword">new</span> Student();<span class="comment">//不是一个原子性操作</span></span><br><span class="line">①给s对象分配内存空间</span><br><span class="line">②调用构造块,执行构造函数 - 初始化动作</span><br><span class="line">③将引用s指向内存中的那个对象.</span><br><span class="line">     </span><br><span class="line">但是JVM内部会对这些指令进行一个优化操作.</span><br><span class="line">本来你的顺序应该是①-②-③,经过JVM指令重排之后,顺序有可能</span><br><span class="line">变成①-③-②</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:双重检查锁 - 笔试脱手写的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 10:07 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton03 instance;</span><br><span class="line">    <span class="comment">//private static Singleton03 instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//② - 跑得很慢的线程刚刚到达此处,其他线程判断instance是不为null的</span></span><br><span class="line">        <span class="comment">//但是instance可能指向的是一个&quot;半成品&quot; - A线程还没有完成构造方法.</span></span><br><span class="line">        <span class="comment">//其他线程可能会使用到这个&quot;半成品&quot;对象,肯定会有问题.</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton03.class)&#123;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//① - A线程可能执行到2步骤的时候,instance已经不为null</span></span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">//不是一个原子性操作,可能经过JVM指令重排</span></span><br><span class="line">                    <span class="comment">//1. 给instance对象分配空间</span></span><br><span class="line">                    <span class="comment">//2. 将对象的内存地址赋值给了instance</span></span><br><span class="line">                    <span class="comment">//3. 调用构造方法</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day07</title>
    <link href="http://example.com/2021/07/21/day07/"/>
    <id>http://example.com/2021/07/21/day07/</id>
    <published>2021-07-21T10:02:10.000Z</published>
    <updated>2022-01-07T06:46:10.979Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><blockquote><ol><li><p>抽象类天生就是用来被子类继承的.抽象类天生就是不能够被外部进行实例化的</p></li><li><p>抽象类使用abstract关键字来进行修饰 </p></li><li><p>抽象类中允许存在构造方法,普通属性,普通方法以及抽象方法.</p></li><li><p>普通类是没有资格去定义抽象方法</p></li><li><p>抽象方法也是使用abstract来修饰的,抽象方法是指没有方法体的方法.</p><p>抽象的方法天生也是用来被子类重写的.</p></li><li><p>抽象类是一种抽象的数据类型.</p></li></ol></blockquote><h2 id="抽象类的继承的特点"><a href="#抽象类的继承的特点" class="headerlink" title="抽象类的继承的特点"></a>抽象类的继承的特点</h2><blockquote><ol><li>如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中的所有的抽象方法.</li><li>如果某个子类继承了抽象类,不想重写抽象父类中的所有的抽象方法,那么需要将这个子类也定义成抽象类.</li></ol></blockquote><h1 id="不能一起混用的修饰符"><a href="#不能一起混用的修饰符" class="headerlink" title="不能一起混用的修饰符"></a>不能一起混用的修饰符</h1><blockquote><ol><li><p>final和abstract一起使用</p></li><li><p>private和abstract能不能一起修饰方法.</p></li><li><p>static和abstract不能一起用来修饰方法</p><p>static是不存在多态的.</p></li></ol></blockquote><h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><blockquote><p>模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。即：<strong>处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。处理步骤在父类中定义好，具体实现延迟到子类中定义 。</strong></p></blockquote><blockquote><p>抽象的类应用 -  模板方法设计模式.</p><p>模板类中只负责定义</p><ol><li>需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现.</li><li>做的事情的流程[步骤]</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 9:36 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定了需要完成的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//演员登台</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;<span class="comment">//演员表演</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;<span class="comment">//落幕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个不可变的方法,用来控制事情执行的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.play();</span><br><span class="line">        <span class="keyword">this</span>.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>模板方法的优点和缺点：</p><p><strong>优点</strong>：</p><ol><li>模板方法提供了一个很好的代码复用平台。</li><li>实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，符合 “开闭原则”。</li></ol><p><strong>缺点：</strong></p><p>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><blockquote><ol><li>属于抽象的数据类型,也是不能够被实例化的</li><li>接口中不允许定义普通属性的,不允许出现构造的.</li><li>jdk8.x允许在接口中使用<strong>default关键字来定义普通方法</strong>.</li><li>接口也是用来定义抽象的方法的.<strong>接口中的方法都是抽象的方法.</strong></li><li><strong>接口的属性都是公开的静态的常量属性.</strong></li><li>定义接口的关键字是interface,编译之后也是.class字节码文件</li><li>接口也是可以静态方法的.</li></ol></blockquote><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><blockquote><p>使用I开头或者able结尾</p></blockquote><h2 id="多态的另外应用"><a href="#多态的另外应用" class="headerlink" title="多态的另外应用"></a>多态的另外应用</h2><blockquote><p>面向接口编程</p><ol><li>对象的编译时类型写成接口,对象的运行时类型写成是实现类</li><li>方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类.</li><li>方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类.</li></ol></blockquote><h2 id="接口的规则"><a href="#接口的规则" class="headerlink" title="接口的规则"></a>接口的规则</h2><blockquote><ol><li><p>接口和类 - 类是可以去实现这个接口的.</p><blockquote><ol><li>接口天生是用来是<strong>实现类</strong>来实现的 - implements</li><li>普通的类去实现某个接口的话,那么必须要实现这个接口中所有的抽象方法</li><li>如果抽象的类去实现某个接口的话,那么可以选择实现或者不实现.</li><li>一个接口可以拥有多个实现类.</li><li>一个类可以同时实现多个接口,接口之间用逗号隔开.需要实现这些接口中所有的抽象方法.</li></ol></blockquote></li><li><p>接口和接口</p><blockquote><ol><li>一个接口可以继承多个接口,接口是支持多重继承的.</li></ol></blockquote></li></ol></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>提供了一种”契约机制”,屏蔽了底层的具体的实现,为了程序的拓展</p><p>作用 - 制定开发的这个软件中的功能 - “业务方法”</p></blockquote><h2 id="接口的分类"><a href="#接口的分类" class="headerlink" title="接口的分类"></a>接口的分类</h2><blockquote><ol><li><p>业务接口 - 该接口中只定义抽象方法</p></li><li><p>常量接口 - 该接口中只定义了常量属性,管理系统中所有的常量属性的.jdk5.x使用了枚举类型来替代了常量接口</p></li><li><p>标记接口 - 什么都没有,做标记的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aimpl</span> <span class="keyword">implements</span> <span class="title">IA</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">Aimpl a = <span class="keyword">new</span> Aimpl();</span><br><span class="line">System.out.println(a <span class="keyword">instanceof</span> IA);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>函数式接口 - jdk8.x - 配合jdk8.x - lambda表达式</p><p>里面只有一个抽象方法的接口 - @FunctionalInterface</p></li></ol></blockquote><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="设计模式概念"><a href="#设计模式概念" class="headerlink" title="设计模式概念"></a>设计模式概念</h2><p>设计模式（Design Pattern）<strong>是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结</strong>。</p><p>使用设计模式的目的：为了<strong>代码可重用性</strong>、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码<strong>编写真正工程化</strong>；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><p>项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，<strong>每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案</strong>，这也是设计模式能被广泛应用的原因。</p><h1 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h1><p>为什么要提倡“Design Pattern”呢？根本原因是为了<strong>代码复用，增加可维护性</strong>。那么怎么才能实现代码复用呢？面开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。<em><strong>其他几条，则可以看做是开闭原则的实现方法。</strong></em></p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><em><strong>简介:单一职责原则（Single Responsiblity Principle SRP）</strong></em></p><p><strong>接口或类只提供一种业务实现。</strong><br>单一职责原则宗旨是每个接口、类的功能，只能用来做专门的事，强调系统内业务职责唯一，避免职责扩散，做到业务统一管理.</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><em><strong>简介:总原则:开闭原则（Open Close Principle）</strong></em></p><p><strong>开闭原则就是说对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代 码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，<strong>我们需要使用接口和抽象类等</strong>，后面的具体设计中我们会提到这点。 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 </p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><em><strong>简介:里氏替换原则（Liskov Substitution Principle）</strong></em></p><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实 现抽象化的具体步骤的规范。<strong>里氏替换原则中，子类对父类的方法尽量不要重写和重载</strong>。<strong>因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</strong></p><p><strong>因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。</strong></p><ul><li>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><em><strong>简介:依赖倒转原则（Dependence Inversion Principle）</strong></em> </p><p><strong>这个是开闭原则的基础</strong>，具体内容：<strong>面向接口编程，依赖于抽象而不依赖于具体</strong>。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 </p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><em><strong>简介:接口隔离原则（Interface Segregation Principle</strong></em>）</p><p>这个原则的意思是：<strong>每个接口中不存在实现类用不到却必须实现的方法</strong>，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p><em><strong>简介:迪米特法则（最少知道原则）（Demeter Principle)</strong></em></p><p>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：<em><strong>只与直接的朋友通信</strong></em>。类之间只要有耦合关系，就叫朋友关系。<em><strong>耦合分为依赖、关联、聚合、组合等</strong></em>。<em><strong>我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友</strong></em>。<em><strong>局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部 变量出现在类中。</strong></em> </p><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><em><strong>简介:合成复用原则（Composite Reuse Principle)</strong></em></p><p>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式是属于<strong>创建型模式</strong>，<strong>但不属于23种GOF设计模式之一</strong>。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂一般分为：<strong>普通简单工厂</strong>、<strong>多方法简单工厂</strong>、<strong>静态方法简单工厂</strong>。 </p><p><strong>作用:把对象的创建和对象的使用分离</strong></p><p>User user = new User();//对象的创建和对象使用没有分离</p><h2 id="普通简单工厂-必须要脱手写出来的"><a href="#普通简单工厂-必须要脱手写出来的" class="headerlink" title="普通简单工厂 - 必须要脱手写出来的."></a>普通简单工厂 - 必须要脱手写出来的.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 根据传入的参数来返回某个具体的产品[对象]</span></span><br><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.simple01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 简单工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 3:19 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WX = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入的参数来返回某个具体的产品</span></span><br><span class="line">    <span class="comment">//多态的应用 - 面向接口编程</span></span><br><span class="line">    <span class="comment">//3. 方法的返回类型写成接口,方法的执行结果可以是这个接口的任意一个实现类.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        Sender sender = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">//对象的创建 - 复杂的过程...</span></span><br><span class="line">                sender = <span class="keyword">new</span> QQSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                sender = <span class="keyword">new</span> WXSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;参数不合法&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多方法简单工厂"><a href="#多方法简单工厂" class="headerlink" title="多方法简单工厂"></a>多方法简单工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.simple02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 多方法工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 3:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有几个产品,就定义几个方法</span></span><br><span class="line">    <span class="comment">//每个方法负责生成一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QQSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createWx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WXSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法简单工厂"><a href="#静态方法简单工厂" class="headerlink" title="静态方法简单工厂"></a>静态方法简单工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.simple02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 多方法工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 3:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有几个产品,就定义几个方法</span></span><br><span class="line">    <span class="comment">//每个方法负责生成一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">createQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QQSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">createWx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WXSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂优缺点"><a href="#简单工厂优缺点" class="headerlink" title="简单工厂优缺点"></a>简单工厂优缺点</h2><p>优点：</p><ul><li>很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。</li></ul><p>缺点：</p><ul><li><p>任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大</p></li><li><p><strong>在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。</strong></p></li></ul><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，<strong>如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能， 直接增加新的工厂类就可以了，不需要修改之前的代码</strong>。</p><h2 id="工厂方法模式优缺点"><a href="#工厂方法模式优缺点" class="headerlink" title="工厂方法模式优缺点"></a>工厂方法模式优缺点</h2><p>优点：</p><ul><li>工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1）</li><li>同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，<strong>使得工厂类符合开闭原则。</strong></li></ul><p>缺点：</p><ul><li>相比简单工厂，实现略复杂。</li><li>对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。</li></ul><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。<strong>抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个<em>产品族</em>中的产品对象</strong>。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。</p><h2 id="抽象工厂模式优缺点"><a href="#抽象工厂模式优缺点" class="headerlink" title="抽象工厂模式优缺点"></a>抽象工厂模式优缺点</h2><p>优点： </p><ul><li>抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><p>​        缺点：</p><ul><li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。</li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><ol start="0"><li><p>循环</p><p><img src="/2021/07/21/day07/%E8%AF%95%E9%A2%98.jpg"> </p></li><li><p>OO题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Book[id,name,price...]</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>定义图书操作业务接口 IBookBiz</span><br><span class="line"></span><br><span class="line">有如下方法:</span><br><span class="line"><span class="comment">//添加图书</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Book b)</span></span>;</span><br><span class="line"><span class="comment">//根据图书name 来删除指定图书</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">deleteByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//打印出所有的图书信息</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">outputAllBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 定义 数组图书管理业务实现类(ArrayBookBiz) </span><br><span class="line">实现 IBookBiz接口，</span><br><span class="line">实现所有方法,</span><br><span class="line">提示，给出如下属性</span><br><span class="line">属性:</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//代表有效图书数量</span></span><br><span class="line"><span class="keyword">private</span> Book[] books = <span class="keyword">new</span> Book[CAPACITY];</span><br><span class="line">方法：</span><br><span class="line">  就是实现接口中的所有方法</span><br><span class="line"></span><br><span class="line">最后，写测试类，测试这三个方法.</span><br></pre></td></tr></table></figure></li><li><p>接口练习题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">接口更重要的作用：作为模块与模块之间一个协议，软件生产一直希望能够像硬件生产一样：主板可由一个厂家生产，显卡可由另一个厂家生产，用户只需要将显卡插到主板上的显卡插槽上，便可以协同工作了。（插槽——主板、显卡的标准接口已经确定，插槽就是接口）。显卡厂商去实现接口中所暴露出来的方法。主板只需要利用显卡的插槽去获取（调用）显卡的功能。</span><br><span class="line"><span class="number">1</span>、定义一个显卡接口VideoCard，此接口中有抽象方法：</span><br><span class="line"><span class="number">1</span>）videoRunning()：显示显卡运行信息 ;</span><br><span class="line"><span class="number">2</span>）videoClosing()：显示显卡停止工作时的信息;</span><br><span class="line"><span class="number">2</span>、定义一个芯片接口Cpu,此接口中有抽象方法：</span><br><span class="line"><span class="number">1</span>）cpuRunning()：显示显卡运行信息 ;</span><br><span class="line"><span class="number">2</span>）cpuClosing()：显示显卡停止工作时的信息;</span><br><span class="line"><span class="number">3</span>、定义类IntelCpu：实现Cpu接口的全部功能，其中包括：</span><br><span class="line"><span class="number">1</span>）无参构造方法：显示：” Make an Intel<span class="string">&#x27;s CPU”.</span></span><br><span class="line"><span class="string">2）实现Cpu接口的所有方法</span></span><br><span class="line"><span class="string">4、定义类DmengVideoCard：实现VideoCard接口的全部功能，其中包括：</span></span><br><span class="line"><span class="string">1）无参构造方法：显示：”Make a Dmeng&#x27;</span>s VideoCard”.</span><br><span class="line"><span class="number">2</span>）实现VideoCard接口的所有方法.</span><br><span class="line"><span class="number">5</span>、定义类Mainboard</span><br><span class="line"><span class="number">1</span>）创建有参构造体，传入显卡和芯片</span><br><span class="line"><span class="number">2</span>）run():显示主板运行信息</span><br><span class="line"><span class="number">3</span>）close():显示主板停止信息</span><br><span class="line"><span class="number">6</span>、定义一个Computer类，包含主函数main(),组装一台电脑，测试接口的应用，其中main()方法包括：</span><br><span class="line"><span class="number">1</span>）买一块Dmeng公司的显卡</span><br><span class="line"><span class="number">2</span>）买一块Intel公司的芯片</span><br><span class="line"><span class="number">3</span>）买一块主板:插上显卡、芯片</span><br><span class="line"><span class="number">4</span>）组装好后，开机运行显示显卡、芯片、主板等开机信息。</span><br><span class="line"><span class="number">5</span>）关机信息显示</span><br><span class="line"><span class="number">6</span>）创建openPC方法，打开电脑。</span><br><span class="line"><span class="number">7</span>）创建closePC方法，关闭电脑。</span><br></pre></td></tr></table></figure></li><li><p>预习题 - <strong>static关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1.</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cygnus</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">9</span>;  </span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> value = <span class="number">69</span>; </span><br><span class="line">           System.out.println(<span class="keyword">this</span>.value);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">           <span class="keyword">new</span> Cygnus().printValue();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   这个程序会有下面哪种结果？</span><br><span class="line">   A. 编译错误</span><br><span class="line">   B. 打印<span class="number">9</span></span><br><span class="line">   C. 打印<span class="number">69</span></span><br><span class="line">   D. 运行时抛出异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">2.</span> 写出以下程序的输出结果</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;base static&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;base constructor&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;test static&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">           System.out.println(<span class="string">&quot;test constructor&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">new</span> Test();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">3.</span> 写出以下程序的输出结果</span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;test static 1&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;test static 2&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">4.</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> x,y;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      x--;</span><br><span class="line">      myMethod( );</span><br><span class="line">      System.out.println(x+y+ ++x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">( )</span></span>&#123;</span><br><span class="line">     y=x++ + ++x;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   A.编译错误</span><br><span class="line">   B.输出：<span class="number">1</span></span><br><span class="line">   C.输出：<span class="number">2</span></span><br><span class="line">   D.输出：<span class="number">3</span></span><br><span class="line">   E.输出：<span class="number">7</span></span><br><span class="line">   F.输出：<span class="number">8</span></span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">5.</span> 阅读下列程序，选择哪一个是正确的输出结果 </span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;I’m A class &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;static A&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;I’m B class&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;static B&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="keyword">new</span> HelloB();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   A.<span class="keyword">static</span> A I’m A <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">B</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">   <span class="title">B</span>.<span class="title">I</span>’<span class="title">m</span> <span class="title">A</span> <span class="title">class</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span> <span class="title">static</span> <span class="title">A</span> <span class="title">static</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">   <span class="title">C</span>.<span class="title">static</span> <span class="title">A</span> <span class="title">static</span> <span class="title">B</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">A</span> <span class="title">class</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">   <span class="title">D</span>.<span class="title">I</span>’<span class="title">m</span> <span class="title">A</span> <span class="title">class</span> <span class="title">static</span> <span class="title">A</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span> <span class="title">static</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    ---------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="class">   6. 以下代码的输出结果是？</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> B t1 = <span class="keyword">new</span> B();</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> B t2 = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;构造块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           B t = <span class="keyword">new</span> B();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   A.静态块 构造块 构造块 构造块</span><br><span class="line">   B.构造块 静态块 构造块 构造块</span><br><span class="line">   C.构造块 构造块 静态块 构造块</span><br><span class="line">   D.构造块 构造块 构造块 静态块</span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">7.</span> 下面代码在main方法代码后可以正常使用的是（ ）</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">       <span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">           Test t = <span class="keyword">new</span> Test();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   A.t.a</span><br><span class="line">   B.<span class="keyword">this</span>.c</span><br><span class="line">   C.Test.b</span><br><span class="line">   D.Test.c</span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">8.</span> 下列程序执行后结果为( )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a - b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a + b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       A a = <span class="keyword">new</span> B();</span><br><span class="line">       B b = <span class="keyword">new</span> B();</span><br><span class="line">       System.out.println(<span class="string">&quot;Result=&quot;</span> + a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;Result=&quot;</span> + b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   A.Result=150Result=<span class="number">150</span></span><br><span class="line">   B.Result=100Result=<span class="number">100</span></span><br><span class="line">   C.Result=100Result=<span class="number">150</span></span><br><span class="line">   D.Result=150Result=<span class="number">100</span></span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">9.</span> 以下代码执行后输出结果为（ ）</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;blockA&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;blockB&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   A.blockAblockBblockA</span><br><span class="line">   B.blockAblockAblockB</span><br><span class="line">   C.blockBblockBblockA</span><br><span class="line">   D.blockBblockAblockB</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
</feed>
