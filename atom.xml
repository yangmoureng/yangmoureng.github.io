<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YangBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-07T06:26:36.665Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringClound</title>
    <link href="http://example.com/2021/10/19/springclound/"/>
    <id>http://example.com/2021/10/19/springclound/</id>
    <published>2021-10-19T07:20:57.000Z</published>
    <updated>2022-01-07T06:26:36.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ol><li><p>springcloud的组件哪些?</p><p>Eureka,Ribbon,Feign</p></li><li><p>Eureka - 治理服务 -SOA架构</p><p>Eureka-server - 服务中心 - 可以做集群 - 降低各个服务之间耦合.服务于服务之间不需要关心具体怎么通信.</p><p>Eureka-client - 服务客户端,每次启动客户端的时候,需要将客户端的信息[名称,网络信息]注册到eureka-server</p><p>每30s会向eureka-server发送一次心跳 - 目的是为了告诉eureka-server它还活着,想要续约.如果超过90s,eureka-server接受不到该客户的心跳,那么再比例[失败的比例如果低于85%],那么就会剔除.</p></li><li><p>Ribbon</p><p>提供负载均衡策略,rest方式[RestTemplate + ribbon]</p></li><li><p>Feign</p><p>基于Ribbon,Feign最主要的作用是用来提供服务于服务之间的通信的问题.默认提供了负载均衡</p></li><li><p>nginx负载均衡(服务器端)和Feign/Ribbon负载均衡(客户端)区别  -   负载均衡的策略</p></li><li><p>SpringCloud2020版本开始,剔除了netflix项目[不进行更新了,仍然会继续维护bug]的组件,保留了Eureka组件.</p></li></ol></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><ol><li><p>分布式 - 将一个庞大的系统按照模块进行拆分,拆分成若干个子模块[微服务] , 进行分布式的部署[各个服务部署在不同的服务器]</p><p>着重点 - 有无进行分布式部署 - <strong>部署的方式</strong></p></li><li><p>微服务 - 架构风格,微服务不一定是分布式的.但是分布式微服务架构的.</p><p>“每个微服务都是单独的独立的工程项目,可以进行单独的部署 = 不同的人做不同的事情”</p></li><li><p>集群 - “很多人做同一件事情” - 分布式上的每个节点[微服务]都是可以进行集群的.</p><p>解决”三高” - 高并发,高性能,高可用</p></li><li><p>单体架构 - 整个项目都在一个工程里面,一起进行部署的.弊端 - 如果项目中的某个模块修改了,需要整体重新打包,重新部署.</p><p>如果某个模块”坏掉了” - 导致整个项目都”崩”</p></li></ol></blockquote><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ol><li><p>什么是我服务?</p><ul><li>微服务是一种架构风格，也是一种服务；</li><li>微服务的颗粒比较小，一个大型复杂软件应用由多个微服务组成，比如Netflix目前由500多个的微服务组成；</li><li>它采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。</li></ul></li><li><p>微服务架构图</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\small.png"> </p></li><li><p>微服务好处</p><ul><li>技术异构性：在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。</li><li>弹性：如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。</li><li>扩展：可以只对那些需要扩展的服务进行扩展。<br>简化部署：各个服务的部署是独立的，这样就可以更快地对特定部分的代码进行部署。</li><li>与组织结构相匹配：可以很好地将架构与组织结构相匹配，避免出现过大的代码库，从而获得理想团队大小及生产力。</li><li>可组合性：不同服务模块的接口可以再进行重用，成为其他产品中的一个组件；</li><li>对可替代性的优化：可以在需要时轻易地重写服务，或者删除不再使用的服务</li></ul></li><li><p>微服务缺点</p><ul><li><p><em><strong>运维开销</strong></em><br>更多的服务也就意味着更多的运维，产品团队需要保证所有的相关服务都有完善的监控等基础设施，传统的架构开发者只需要保证一个应用正常运行，而现在却需要保证几十甚至上百道工序高效运转，这是一个艰巨的任务。</p></li><li><p><em><strong>DevOps要求</strong></em><br>使用微服务架构后，开发团队需要保证一个Tomcat集群可用，保证一个数据库可用，这就意味着团队需要高品质的DevOps和自动化技术。而现在，这样的全栈式人才很少。</p></li><li><p><em><strong>隐式接口</strong></em><br>服务和服务之间通过接口来“联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做调整。</p></li><li><p><em><strong>重复劳动</strong></em><br>在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这个时候可能不同的服务团队都会单独开发这一功能，重复的业务逻辑，这违背了良好的软件工程中的很多原则。</p></li><li><p><em><strong>分布式系统的复杂性</strong></em><br>微服务通过REST API或消息来将不同的服务联系起来，这在之前可能只是一个简单的远程过程调用。分布式系统也就意味着开发者需要考虑网络延迟、容错、消息序列化、不可靠的网络、异步、版本控制、负载等，而面对如此多的微服务都需要分布式时，整个产品需要有一整套完整的机制来保证各个服务可以正常运转。</p></li><li><p><em><strong>事务、异步、测试面临挑战</strong></em><br>跨进程之间的事务、大量的异步处理、多个微服务之间的整体测试都需要有一整套的解决方案，而现在看起来，这些技术并没有特别成熟。</p></li></ul></li></ol><h1 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h1><ul><li><p>springcloud是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。</p></li><li><p>通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p></li><li><p>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix</p></li></ul><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\springcloud.jpg"> </p><p>下面简单介绍下经常用的5个:</p><p>服务发现——Netflix Eureka</p><p>客服端负载均衡——Netflix Ribbon(<strong>重点掌握Netflix Feign</strong>)</p><p>断路器——Netflix Hystrix</p><p>服务网关——Netflix Zuul</p><p>分布式配置——Spring Cloud Config</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\eureka.jpg"> </p><p>作用：实现服务治理（服务注册与发现）</p><p>简介：Spring Cloud Eureka是Spring Cloud Netflix[停止更新]项目下的服务治理模块。</p><p>由两个组件组成：Eureka服务端和Eureka客户端。</p><p>Eureka服务端用作服务注册中心。支持集群部署。</p><p>Eureka客户端是一个java客户端，用来处理服务注册与发现。</p><p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\ribbon.jpg"> </p><p>作用：Ribbon，主要提供客户侧的软件负载均衡算法。</p><p>简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</p><p>注意看上图，关键点就是将外界的rest调用，根据负载均衡策略转换为微服务调用。Ribbon有比较多的负载均衡策略，以后专门讲解。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix.jpg"> </p><p>作用：断路器，保护系统，控制故障范围。</p><p>简介：为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\zuul.jpg">  </p><p>作用：api网关，路由，负载均衡等多种作用</p><p>简介：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p><p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。</p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\config.jpg"> </p><p>作用：配置管理</p><p>简介：SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。</p><p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p><h2 id="相关组件架构图"><a href="#相关组件架构图" class="headerlink" title="相关组件架构图"></a>相关组件架构图</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\all.png">  </p><p>从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。</p><ul><li>其中Eureka负责服务的注册与发现，很好将各服务连接起来</li><li>Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li><li>Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示</li><li>Spring Cloud Config 提供了统一的配置中心服务</li><li>当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息</li><li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用</li><li>最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析</li></ul><h2 id="为什么要使用springcloud"><a href="#为什么要使用springcloud" class="headerlink" title="为什么要使用springcloud"></a>为什么要使用springcloud</h2><p>Spring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利。</p><p>微服务架构是一种趋势，Spring Cloud提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><h1 id="Eureka服务与注册"><a href="#Eureka服务与注册" class="headerlink" title="Eureka服务与注册"></a>Eureka服务与注册</h1><h2 id="为什么需要服务中心"><a href="#为什么需要服务中心" class="headerlink" title="为什么需要服务中心"></a>为什么需要服务中心</h2><p>过去，每个应用都是一个CPU，一个主机上的单一系统。然而今天，随着大数据和云计算时代的到来，任何独立的程序都可以运行在多个计算机上。并且随着业务的发展，访问用户量的增加，开发人员或小组的增加，系统会被拆分成多个功能模块。拆分后每个功能模块可以作为一个独立的子系统提供其职责范围内的功能。而多个子系统中，由于职责不同并且会存在相互调用，同时可能每个子系统还需要多个实例部署在多台服务器或者镜像中，导致了子系统间的相互调用形成了一个错综复杂的网状结构</p><p><strong>对于微服务之间错综复杂的调用关系，通过eureka来管理，可以让每个服务之间不用关心如何调用的问题，专注于自己的业务功能实现。</strong></p><h2 id="Eureka的管理"><a href="#Eureka的管理" class="headerlink" title="Eureka的管理"></a>Eureka的管理</h2><ul><li>服务需要有一个统一的名称（或服务ID）并且是唯一标识，以便于接口调用时各个接口的区分。并且需要将其注册到Eureka Server中，其他服务调用该接口时，也是根据这个唯一标识来获取。</li><li>服务下有多个实例，每个实例也有一个自己的唯一实例ID。因为它们各自有自己的基础信息如：不同的IP。所以它们的信息也需要注册到Eureka Server中，其他服务调用它们的服务接口时，可以查看到多个该服务的实例信息，根据负载策略提供某个实例的调用信息后，调用者根据信息直接调用该实例。</li></ul><h2 id="Eureka如何管理服务调用"><a href="#Eureka如何管理服务调用" class="headerlink" title="Eureka如何管理服务调用"></a>Eureka如何管理服务调用</h2><ul><li>在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。然后进行2调用当前服务器节点中的其他服务信息，保存到Eureka Client中。当服务间相互调用其它服务时，在Eureka Client中获取服务信息（如服务地址，端口等）后，进行第3步，根据信息直接调用服务。（注：服务的调用通过http(s)调用）</li><li>当某个服务仅需要调用其他服务，自身不提供服务调用时。在Eureka Client启动后会拉取Eureka Server的其他服务信息，需要调用时，在Eureka Client的本地缓存中获取信息，调用服务。</li><li>Eureka Client通过向Eureka Serve发送心跳（默认每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 以此来确保当前服务还“活着”，可以被调用。</li><li>来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次），以此来确保调用到的服务是“活的”。并且当某个服务被更新或者新加进来，也可以调用到新的服务。</li></ul><h2 id="Eureka-Server和Eureka-Client"><a href="#Eureka-Server和Eureka-Client" class="headerlink" title="Eureka Server和Eureka Client"></a>Eureka Server和Eureka Client</h2><ul><li><p>Eureka Server</p><ul><li><p>提供服务注册：各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如服务信息和网络信息），Eureka Server会存储该服务的信息。</p></li><li><p>提供服务信息提供：服务消费者在调用服务时，本地Eureka Client没有的情况下，会到Eureka Server拉取信息。</p></li><li><p>提供服务管理：通过Eureka Client的Cancel、心跳监控、renew等方式来维护该服务提供的信息以确保该服务可用以及服务的更新。</p></li><li><p>信息同步：每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过P2P复制的方式完成服务注册表的同步</p></li></ul></li><li><p>Eureka Client</p><ul><li><p>Eureka Client是一个Java客户端，用于简化与Eureka Server的交互。并且管理当前微服务，同时为当前的微服务提供服务提供者信息。</p></li><li><p><strong>Eureka Client会拉取、更新和缓存Eureka Server中的信息</strong>。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。</p></li><li><p>Eureka Client在微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）。</p></li></ul></li></ul><h2 id="服务续约、下线、剔除"><a href="#服务续约、下线、剔除" class="headerlink" title="服务续约、下线、剔除"></a>服务续约、下线、剔除</h2><ul><li><p>服务续约</p><p>Application Service内的Eureka Client后台启动一个定时任务，跟Eureka Server保持一个心跳续约任务，每隔一段时间(默认30S)向Eureka Server发送一次renew请求，进行续约，告诉Eureka Server我还活着，防止被Eureka Server的Evict任务剔除。</p></li><li><p>服务下线</p><p>Application Service应用停止后，向Eureka Server发送一个cancel请求，告诉注册中心我已经退出了，Eureka Server接收到之后会将其移出注册列表，后面再有获取注册服务列表的时候就获取不到了，防止消费端消费不可用的服务。</p></li><li><p>服务剔除</p><p>Eureka Server启动后在后台启动一个Evict任务，对一定时间内没有续约的服务进行剔除。</p></li></ul><ul><li><p>服务通讯方式</p><p>服务间使用标准的REST方式通讯，所以Eureka服务注册中心并不仅适用于Java平台，其他平台也可以纳入到服务治理平台里面。</p></li></ul><ul><li><p>自我保护</p><p>本地调试Eureka的程序时，会出现：　</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\safe.png"> </p><p>该警告是触发了Eureka Server的自我保护机制。</p><p>Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果低于，就会将当前实例注册信息保护起来，让实例不会过期，尽可能保护这些注册信息。</p><p>但是如果在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。这个时候客户端的容错机制就很重要了。（重新请求，断路器）</p><p>保护机制，可能会导致服务实例不能够被正确剔除。</p><p>在本地开发时，可使用：eureka.server.enable-self-preservation=false关闭保护机制，使不可用实例能够正常下线。</p></li></ul><h2 id="Eureka和Zookeeper区别"><a href="#Eureka和Zookeeper区别" class="headerlink" title="Eureka和Zookeeper区别"></a>Eureka和Zookeeper区别</h2><p>Eureka：可以在发生因网络问题导致的各节点失去联系也不会暂停服务，但是最新的数据可能不统一。</p><p>Zookeeper：如果发生网络问题导致的Master和其他节点失去联系，就会使得其他的节点推选出新的Master，但是推选的时间内无法提供服务，但是可以保证任何时候的数据都是统一的。</p><h1 id="基于idea多模块搭建eureka注册中心"><a href="#基于idea多模块搭建eureka注册中心" class="headerlink" title="基于idea多模块搭建eureka注册中心"></a>基于idea多模块搭建eureka注册中心</h1><ul><li><p>首先创建父工程parent-demo,父工程pom.xml配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>user-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>order-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>zuul-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>config-server-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>config-client-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tech.aistar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>parent-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建注册中心模块moudle</p><p>eureka-demo模块,pom.xml文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tech.aistar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tech.aistar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eureka-demo的application.yml文件配置如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-demo</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 注册到eurekaip地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 因为自己是注册中心,不需要自己注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 因为自己是注册中心,不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">        <span class="comment"># 服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">        <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>添加启动类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启注册中心</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(EurekaDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问网页,查看EurekaServer</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\server.png"> </p></li></ul><h1 id="生产者和消费者注册及调用实战"><a href="#生产者和消费者注册及调用实战" class="headerlink" title="生产者和消费者注册及调用实战"></a>生产者和消费者注册及调用实战</h1><h2 id="生产者-user-demo"><a href="#生产者-user-demo" class="headerlink" title="生产者 - user-demo"></a>生产者 - user-demo</h2><ul><li><p>创建用户user-demo用户服务,pom.xml文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>user-demo的application.yml文件配置如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8885</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 注册到eurekaip地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">        <span class="comment"># 服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka/</span></span><br><span class="line">        <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>user-demo的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启eureka的客户端注解</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(UserDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="消费者-order-demo"><a href="#消费者-order-demo" class="headerlink" title="消费者 - order-demo"></a>消费者 - order-demo</h2><ul><li><p>创建moudle - order-demo订单服务,pom.xml文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo的application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8882</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 注册到eurekaip地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">        <span class="comment"># 服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka/</span></span><br><span class="line">        <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(OrderDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后,一次启动服务注册中心eureka-demo,user-demo和order-demo</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\user-order.png"> </p><h1 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h1><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。Feign默认集成了Ribbon，并和Eureka结合，默认实现了<strong>负载均衡</strong>的效果</p><p>简而言之：</p><p>Feign 采用的是基于接口的注解</p><h2 id="RestTemplate和feign区别"><a href="#RestTemplate和feign区别" class="headerlink" title="RestTemplate和feign区别"></a>RestTemplate和feign区别</h2><p>使用RestTemplate时，URL参数是以编程方式构造的，数据被发送到其他服务。</p><p>Feign是Spring Cloud Netflix库，用于在基于REST的服务调用上提供更高级别的抽象。Spring Cloud Feign在声明性原则上工作。使用Feign时，我们在客户端编写声明式REST服务接口，并使用这些接口来编写客户端程序。开发人员不用担心这个接口的实现。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>需求:在order-demo服务中调用user-demo服务的程序.</p><ul><li><p>在user-demo服务中添加controller - UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;min&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;驰星&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo服务pom.xml文件,添加如下配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改order-demo服务,添加FeignService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo服务,添加controller - OrderController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeignService feignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrder</span><span class="params">(Integer id,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用user-demo的信息</span></span><br><span class="line">        String result = feignService.get(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品名称:&quot;</span>+name+<span class="string">&quot;,生成订单:&quot;</span>+result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(OrderDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>分别启动eureka-demo,user-demo,order-demo</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\order_invoke_user.png"> </p></li></ul><h2 id="Feign负载均衡效果测试"><a href="#Feign负载均衡效果测试" class="headerlink" title="Feign负载均衡效果测试"></a>Feign负载均衡效果测试</h2><ul><li><p>启动eureka-demo</p></li><li><p>启动user-demo</p></li><li><p>再次启动第二个实例user-demo,在启动之前,修改user-demo的application.yml</p><p>和UserController.java</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8886</span></span><br></pre></td></tr></table></figure><p>UserController.java</p><p>为了体现俩个服务实例的区别,把”驰星”修改成”驰星1”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;min&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;驰星1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动order-demo</p></li><li><p>测试1 - <a href="http://localhost:8882/order?id=2&amp;name=tom">http://localhost:8882/order?id=2&amp;name=tom</a></p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\feign01.png"> </p></li><li><p>测试2 - <a href="http://localhost:8882/order?id=2&amp;name=tom">http://localhost:8882/order?id=2&amp;name=tom</a></p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\feign02.png"> </p><p><strong>采用”轮询”的方式进行调用!</strong></p></li><li><p>测试3 - 断掉其中一个user-demo的服务实例,再次输入上面的地址进行测试</p></li></ul><h1 id="Eureka会将服务端的服务信息缓存到本地测试"><a href="#Eureka会将服务端的服务信息缓存到本地测试" class="headerlink" title="Eureka会将服务端的服务信息缓存到本地测试"></a>Eureka会将服务端的服务信息缓存到本地测试</h1><p>将eureka-demo服务停止,测试order-demo是否能够调用user-demo</p><p>结论:是可以正常调用的!</p><h1 id="hystrix熔断器"><a href="#hystrix熔断器" class="headerlink" title="hystrix熔断器"></a>hystrix熔断器</h1><p>为什么要使用熔断器?</p><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><p>为了解决这个问题，业界提出了断路器模型。</p><h2 id="熔断器简介"><a href="#熔断器简介" class="headerlink" title="熔断器简介"></a>熔断器简介</h2><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix01.png">  </p><p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix02.png"> </p><p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。</p><h2 id="hystrix特性"><a href="#hystrix特性" class="headerlink" title="hystrix特性"></a>hystrix特性</h2><ul><li><p>请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).</p><p>这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p></li><li><p><strong>服务降级</strong>：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。</p></li><li><p>依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放，后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。</p></li><li><p>请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。</p><blockquote><p>请求缓存是在同一请求多次访问中保证只调用一次这个服务提供者的接口，在这同一次请求第一次的结果会被缓存，保证同一请求中同样的多次访问返回结果相同。</p></blockquote></li><li><p><strong>请求合并</strong>：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。</p></li></ul><h2 id="hystrix流程结构解析"><a href="#hystrix流程结构解析" class="headerlink" title="hystrix流程结构解析"></a>hystrix流程结构解析</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\hystrix03.png">  </p><p>流程说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.</span><br><span class="line"><span class="number">2</span>:执行execute()/queue做同步或异步调用.</span><br><span class="line"><span class="number">3</span>:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤<span class="number">8</span>,进行降级策略,如果关闭进入步骤.</span><br><span class="line"><span class="number">4</span>:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤<span class="number">8</span>,否则继续后续步骤.</span><br><span class="line"><span class="number">5</span>:调用HystrixCommand的run方法.运行依赖逻辑</span><br><span class="line">5a:依赖逻辑调用超时,进入步骤<span class="number">8.</span></span><br><span class="line"><span class="number">6</span>:判断逻辑是否调用成功</span><br><span class="line">6a:返回成功调用结果</span><br><span class="line">6b:调用出错，进入步骤<span class="number">8.</span></span><br><span class="line"><span class="number">7</span>:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.</span><br><span class="line"><span class="number">8</span>:getFallback()降级逻辑.</span><br><span class="line">  以下四种情况将触发getFallback调用：</span><br><span class="line"> (<span class="number">1</span>):run()方法抛出非HystrixBadRequestException异常。</span><br><span class="line"> (<span class="number">2</span>):run()方法调用超时</span><br><span class="line"> (<span class="number">3</span>):熔断器开启拦截调用</span><br><span class="line"> (<span class="number">4</span>):线程池/队列/信号量是否跑满</span><br><span class="line">8a:没有实现getFallback的Command将直接抛出异常</span><br><span class="line">8b:fallback降级逻辑调用成功直接返回</span><br><span class="line">8c:降级逻辑调用失败抛出异常</span><br><span class="line"><span class="number">9</span>:返回执行成功结果</span><br></pre></td></tr></table></figure><h2 id="服务降级实战"><a href="#服务降级实战" class="headerlink" title="服务降级实战"></a>服务降级实战</h2><ul><li><p>修改order-demo的pom.xml,增加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo,启动类开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">//启用熔断器</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo的application.yml开启hystrix功能</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml开启hystrix功能</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>order-demo服务中添加fallback类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:本类用来演示:调用user服务的时候,如果出现错误,则调用此处的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallback</span> <span class="keyword">implements</span> <span class="title">FeignService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error get(Integer id)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-demo的FeignService.java</p><p><strong>在@FeignClient注解中添加fallback=MyFallback.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-demo&quot;,fallback = MyFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试 - 将user-demo服务停止,然后输入</p><p><a href="http://localhost:8882/order?id=2&amp;name=tom">http://localhost:8882/order?id=2&amp;name=tom</a></p><p>出现MyFallback类中的实现语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">商品名称:tom,生成订单:<span class="function">error <span class="title">get</span><span class="params">(Integer id)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><ul><li><p>添加OrderCommand.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.service.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:本类用来演示:依赖隔离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/26 0026</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCommand</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;OrderGroup&quot;</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;OrderPool&quot;</span>))</span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)));</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">return</span> threadName + <span class="string">&quot; || &quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加UserCommand.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.service.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:本类用来演示:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/26 0026</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCommand</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;UserGroup&quot;</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;UserPool&quot;</span>))</span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)));</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">return</span> threadName + <span class="string">&quot; || &quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加OrderService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeignService feignService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试依赖隔离</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserCommand userCommand = <span class="keyword">new</span> UserCommand(<span class="string">&quot;库里&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OrderCommand orderCommand1 = <span class="keyword">new</span> OrderCommand(<span class="string">&quot;篮球&quot;</span>);</span><br><span class="line">        OrderCommand orderCommand2 = <span class="keyword">new</span> OrderCommand(<span class="string">&quot;足球&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步调用</span></span><br><span class="line">        String val1 = userCommand.execute();</span><br><span class="line">        String val2 = orderCommand1.execute();</span><br><span class="line">        String val3 = orderCommand2.execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步调用</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f1 = userCommand.queue();</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f2 = userCommand.queue();</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f3 = userCommand.queue();</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;val1=&quot;</span> + val1 + <span class="string">&quot;val2=&quot;</span> + val2 + <span class="string">&quot;val3=&quot;</span> + val3;</span><br><span class="line">      <span class="comment">//  return &quot;f1=&quot; + f1.get() + &quot;f2=&quot; + f2.get() + &quot;f3=&quot; + f3.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>order-demo控制层添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testpool&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderService.testPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试:<a href="http://localhost:8882/testpool">http://localhost:8882/testpool</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val1=hystrix-UserPool-<span class="number">1</span> || 库里val2=hystrix-OrderPool-<span class="number">1</span> || 篮球val3=hystrix-OrderPool-<span class="number">2</span> || 足球</span><br></pre></td></tr></table></figure></li></ul><h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\merge01.png"> </p><p>如图，多个客户端发送请求调用(消费者)项目中的findOne方法，这时候在这个项目中的线程池中会发申请与请求数量相同的线程数，对EurekaServiceProvider(服务提供者)的getUserById方法发起调用，每个线程都要调用一次，在高并发的场景下，这样势必会对服务提供者项目产生巨大的压力。</p><p>请求合并就是将单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法</p><h3 id="请求合并的原理"><a href="#请求合并的原理" class="headerlink" title="请求合并的原理"></a>请求合并的原理</h3><p>NetFlix在Hystrix为我们提供了应对高并发的解决方案—-请求合并，如下图</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\merge02.png"> </p><p>通过请求合并器设置延迟时间，将时间内的，多个请求单个的对象的方法中的参数（id）取出来，拼成符合服务提供者的多个对象返回接口（getUsersByIds方法）的参数，指定调用这个接口（getUsersByIds方法），返回的对象List再通过一个方法（mapResponseToRequests方法），按照请求的次序将结果对象对应的装到Request对应的Response中返回结果。</p><h3 id="请求合并适用场景"><a href="#请求合并适用场景" class="headerlink" title="请求合并适用场景"></a>请求合并适用场景</h3><p>在服务提供者提供了返回单个对象和多个对象的查询接口，并且单个对象的查询并发数很高，服务提供者负载较高的时候，我们就可以使用请求合并来降低服务提供者的负载</p><h3 id="请求合并带来的问题"><a href="#请求合并带来的问题" class="headerlink" title="请求合并带来的问题"></a>请求合并带来的问题</h3><ol><li>我们为这个请求人为的设置了延迟时间，这样在并发不高的接口上使用请求缓存，会降低响应速度</li><li>实现请求合并比较复杂</li></ol><h3 id="使用注解配置"><a href="#使用注解配置" class="headerlink" title="使用注解配置"></a>使用注解配置</h3><ul><li><p>OrderService.java中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 演示请求合并</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@HystrixCollapser(batchMethod = &quot;findAll&quot;,collapserProperties = &#123;</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;,value = &quot;300&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">findOne</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;被合并的请求!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@HystrixCommand</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAll</span><span class="params">(List&lt;Integer&gt; ids)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;合并的请求&quot;</span>);</span><br><span class="line">       List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(Integer id:ids)&#123;</span><br><span class="line">           results.add(feignService.get(id));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> results;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>OrderController.java中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getMerge&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMerge</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是异步</span></span><br><span class="line">    Future&lt;String&gt; r1 = orderService.findOne(<span class="number">1</span>);</span><br><span class="line">    Future&lt;String&gt; r2 = orderService.findOne(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Thread.sleep(1000);</span></span><br><span class="line">    Future&lt;String&gt; r3 = orderService.findOne(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//context.close();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;u1:&quot;</span>+r1.get()+<span class="string">&quot;,u2:&quot;</span>+r2.get()+<span class="string">&quot;r3:&quot;</span>+r3.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8882/getMerge</span></span><br></pre></td></tr></table></figure><p>观察控制台 - order-demo控制台只会出现一次”合并的请求”</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并的请求</span><br></pre></td></tr></table></figure></li></ul><h2 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h2><ul><li><p>OrderService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求缓存,如果俩次请求的cacheKey是一样的,则此处的代码仅仅会执行一次</span></span><br><span class="line"><span class="comment">    * 此处是采用注解的配置方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> cacheKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CacheResult</span></span><br><span class="line">   <span class="meta">@HystrixCommand(commandKey = &quot;cache-user&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(Integer id,<span class="meta">@CacheKey</span> Long cacheKey)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;请求缓存,如果cacheKey是一样的,则不会再执行!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> feignService.get(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求缓存</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getCache&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">       HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">  </span><br><span class="line">       Long key = <span class="number">9999L</span>;</span><br><span class="line">       String u1 = orderService.getUser(<span class="number">1</span>,key);</span><br><span class="line">       String u2 = orderService.getUser(<span class="number">2</span>,<span class="number">9998L</span>);</span><br><span class="line">  </span><br><span class="line">       context.close();</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;u1:&quot;</span>+u1+<span class="string">&quot;,u2:&quot;</span>+u2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="路由网关zuul"><a href="#路由网关zuul" class="headerlink" title="路由网关zuul"></a>路由网关zuul</h1><h2 id="为什么需要服务网关"><a href="#为什么需要服务网关" class="headerlink" title="为什么需要服务网关"></a>为什么需要服务网关</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\zuul01.webp"> </p><p>在分布式系统系统中，有商品、订单、用户、广告、支付等等一大批的服务，前端怎么调用呢？和每个服务一个个打交道？这显然是不可能的，这就需要有一个角色充当所有请求的入口，这个角色就是服务网关（API gateway）</p><h2 id="客户端直接与微服务通讯的问题"><a href="#客户端直接与微服务通讯的问题" class="headerlink" title="客户端直接与微服务通讯的问题"></a>客户端直接与微服务通讯的问题</h2><ol><li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li><li>存在跨域请求，在一定场景下处理相对复杂。</li><li>认证复杂，每个服务都需要独立认证。</li><li>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通讯，那么重构将会很难实施。</li></ol><h2 id="网关的优点"><a href="#网关的优点" class="headerlink" title="网关的优点"></a>网关的优点</h2><ol><li>易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。</li><li>易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li><li>减少了客户端与各个微服务之间的交互次数。</li></ol><h2 id="什么是网关？"><a href="#什么是网关？" class="headerlink" title="什么是网关？"></a>什么是网关？</h2><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><h2 id="使用zuul"><a href="#使用zuul" class="headerlink" title="使用zuul"></a>使用zuul</h2><ul><li><p>新建zuul-demo模块</p></li><li><p>pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring:  application:    name: zuul-demoserver:  port: 9000eureka:  instance:    hostname: localhost  client:    register-with-eureka: true    fetch-registry: true    service-url:        defaultZone: http://localhost:8888/eureka/        preferIpAddress: truezuul:  routes:# 配置统一前缀访问    api-order:      path: /api-order/**      serviceId: order-demo    api-user:      path: /api-user/**      serviceId: user-demo</span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableEurekaClient</span><span class="meta">@EnableDiscoveryClient</span><span class="comment">// 开启zuul功能@EnableZuulProxypublic class ZuulDemoApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(ZuulDemoApplication.class, args);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试路由访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 测试<span class="number">1</span>:http:<span class="comment">//localhost:9000/api-order/testpool# 测试2:http://localhost:9000/api-user/user/1# 测试3:http://localhost:9000/user-demo/user/1# 测试4:http://localhost:9000/order-demo/testpool</span></span><br></pre></td></tr></table></figure><p>都是允许访问的</p></li><li><p>配置统一前缀访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:# 配置统一前缀访问    api-order:      path: /api-order/**      serviceId: order-demo    api-user:      path: /api-user/**      serviceId: user-demo#前缀访问  prefix: /parent</span><br></pre></td></tr></table></figure><p>测试路由访问:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># http:<span class="comment">//localhost:9000/parent/api-order/testpool# http://localhost:9000/parent/order-demo/testpool</span></span><br></pre></td></tr></table></figure></li><li><p>忽略服务名serviceId访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:# 配置统一前缀访问    api-order:      path: /api-order/**      serviceId: order-demo    api-user:      path: /api-user/**      serviceId: user-demo# 前缀访问  prefix: /parent# 忽略服务名serviceId访问ignored-services: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>测试路由访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#测试 http://localhost:9000/parent/api-order/testpool -&gt;ok#测试http//localhost:9000/parent/order-demo/testpool -&gt;error</span><br></pre></td></tr></table></figure></li><li><p>配url绑定映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul:  routes:    testurl:      # url: http://www.iduoan.com  url: http://localhost:8885/      path: /testurl/**</span><br></pre></td></tr></table></figure><p>测试路由访问:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 测试 http://localhost:9000/testurl/user/1</span><br></pre></td></tr></table></figure></li><li><p>配置URL映射负载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ribbon:  eureka:    enabled: false#Ribbon请求的微服务serviceIdsuccess-user:  ribbon:    listOfServers: http://www.huya.com,http://www.douyu.comzuul:  routes:    testurl:      serviceId: success-user      path: /testurl/**</span><br></pre></td></tr></table></figure></li></ul><h2 id="zuul过滤器"><a href="#zuul过滤器" class="headerlink" title="zuul过滤器"></a>zuul过滤器</h2><p>Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能，zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器，简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。</p><h3 id="添加过滤器类"><a href="#添加过滤器类" class="headerlink" title="添加过滤器类"></a>添加过滤器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.filter;<span class="keyword">import</span> com.netflix.zuul.ZuulFilter;<span class="keyword">import</span> com.netflix.zuul.exception.ZuulException;<span class="keyword">import</span> com.sun.scenario.effect.FilterContext;<span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="comment">/** * <span class="doctag">@author</span> success * <span class="doctag">@version</span> 1.0 * <span class="doctag">@description</span>:本类用来演示: * Zuul本身是一系列过滤器的集成，那么他当然也就提供了自定义过滤器的功能， * zuul提供了四种过滤器：前置过滤器，路由过滤器，错误过滤器， * 简单过滤器，实现起来也十分简单，只需要编写一个类去实现zuul提供的接口。 */</span><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter01</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span></span>&#123;    <span class="comment">/**     * 类型包含 pre post route error     * pre 代表在路由代理之前执行     * route 代表代理的时候执行     * error 代表出现错的时候执行     * post 代表在route 或者是 error 执行完成后执行     */</span>    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> FilterConstants.PRE_TYPE;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;        <span class="comment">// 优先级，数字越大，优先级越低        return 1;    &#125;    @Override    public boolean shouldFilter() &#123;        // 是否执行该过滤器，true代表需要过滤        return true;    &#125;    @Override    public Object run() throws ZuulException &#123;        System.out.println(&quot;1111111111111111111&quot;);        return null;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="高可用分布式配置中心"><a href="#高可用分布式配置中心" class="headerlink" title="高可用分布式配置中心"></a>高可用分布式配置中心</h1><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\config01.png"> </p><h2 id="没有使用统一配置中心时，所存在的问题"><a href="#没有使用统一配置中心时，所存在的问题" class="headerlink" title="没有使用统一配置中心时，所存在的问题"></a>没有使用统一配置中心时，所存在的问题</h2><ul><li>配置文件分散在各个项目里，不方便维护</li><li>配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的</li><li>更新配置后，项目需要重启</li></ul><h2 id="有哪些开源配置中心"><a href="#有哪些开源配置中心" class="headerlink" title="有哪些开源配置中心"></a>有哪些开源配置中心</h2><p>spring-cloud/spring-cloud-config<br><a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a><br>spring出品，可以和spring cloud无缝配合<br>diamond<br><a href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a><br>disconf<br><a href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a><br>ctrip apollo<br><a href="https://github.com/ctripcorp/apollo/">https://github.com/ctripcorp/apollo/</a><br>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。</p><h2 id="快速入门config-server"><a href="#快速入门config-server" class="headerlink" title="快速入门config-server"></a>快速入门config-server</h2><ul><li><p>创建config-server-demo工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableConfigServerpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerDemoApplication</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;SpringApplication.run(ConfigServerDemoApplication.class, args);&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 9100spring:  application:    name: config-server-demo  cloud:    config:      server:        git:          uri:</span> <span class="string">https://gitee.com/guancg/config-server-demo.git</span></span><br></pre></td></tr></table></figure></li><li><p>创建码云仓库 </p><p><a href="https://gitee.com/guancg/config-server-demo.git">https://gitee.com/guancg/config-server-demo.git</a></p></li><li><p>创建测试的配置文件</p><ul><li><p>文件名-环境名.后缀</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\dev.png"></p></li></ul></li><li><p>config支持我们使用的请求的参数规则为：</p><ul><li>/ { 应用名 } / { 环境名 } [ / { 分支名 } ]<br><a href="http://localhost:9100/config-server-demo/dev">http://localhost:9100/config-server-demo/dev</a></li><li>/ { 应用名 } - { 环境名 }.yml<br>/ { 应用名 } - { 环境名 }.properties<br><a href="http://localhost:9100/config-server-demo-dev.properties">http://localhost:9100/config-server-demo-dev.properties</a></li><li>/ { 分支名 } / { 应用名 } - { 环境名 }.yml<br>/ { 分支名 } / { 应用名 } - { 环境名 }.properties<br><a href="http://localhost:9100/master/config-server-demo-dev.properties">http://localhost:9100/master/config-server-demo-dev.properties</a></li></ul></li></ul><h2 id="快速入门config-client"><a href="#快速入门config-client" class="headerlink" title="快速入门config-client"></a>快速入门config-client</h2><ul><li><p>创建config-client-demo模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplicationpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientDemoApplication</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;SpringApplication.run(ConfigClientDemoApplication.class, args);&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">//刷新消息组件@RefreshScopepublic class ConfigClientController &#123;    @Value(&quot;$&#123;name&#125;&quot;)    private String name;    @GetMapping(&quot;/value&quot;)    public String getName()&#123;        return name;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>bootstrap.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 9201spring:  application:    name:</span> <span class="string">config-client-demo</span>           <span class="comment"># 指定了配置文件的应用名  cloud:    config:      uri: http://localhost:9100/      #Config server\的uri      profile: dev                       #指定的环境      label: master                      #指定的分支    </span></span><br></pre></td></tr></table></figure><p><a href="http://localhost:9201/value">http://localhost:9201/value</a></p></li></ul><h1 id="Config-Bus-实现动态刷新"><a href="#Config-Bus-实现动态刷新" class="headerlink" title="Config+Bus : 实现动态刷新"></a>Config+Bus : 实现动态刷新</h1><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\bus.png"> </p><ul><li><p>config-client-demo模块添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息总件组件--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新消息组件@RefreshScopepublic class ConfigClientController &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>启动rabbitmq消息队列</p></li><li><p>修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 9201spring:  application:    name:</span> <span class="string">config-client-demo</span>           <span class="comment"># 指定了配置文件的应用名  cloud:    config:      uri: http://localhost:9100/      #Config server\的uri      profile: dev                       #指定的环境      label: master                      #指定的分支  rabbitmq:      host: 192.168.2.49      port: 5672      username: guest      password: guestmanagement: # 暴露总线消息地址`  endpoints:    web:      exposure:        include: &quot;bus-refresh&quot;      cors:        allowed-origins: &quot;*&quot;        allowed-methods: &quot;*&quot;  #测试 - http://localhost:9201/actuator/bus-refresh</span></span><br></pre></td></tr></table></figure></li><li><p>本次测试地址：POST请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:9201/actuator/bus-refresh</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h1><h2 id="消息队列中间件"><a href="#消息队列中间件" class="headerlink" title="消息队列中间件"></a>消息队列中间件</h2><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构]</p><p>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。其使用场景为：异步处理，应用解耦，流量削锋和消息通讯四个场景。</p><h2 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ul><li>可靠性(Reliability)：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由(Flexible Routing)：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群(Clustering)：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用(Highly Available Queues)：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li>多种协议(Multi-protocol)：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>多语言客户端(Many Clients)：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li><li>管理界面(Management UI)：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方<br>面。</li><li>跟踪机制(Tracing)：如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li><li>插件机制(Plugin System)：RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件</li></ul><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\rbm.png"> </p><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><p><strong>RabbitMQ Server</strong>： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</p><p>Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接<strong>RabbitMQ</strong>服务器然后将消息投递到Exchange。</p><p><strong>Consumer</strong>：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。</p><p><strong>Exchange</strong>：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</p><p><strong>Queue</strong>：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><strong>RoutingKey</strong>：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytes，</p><p><strong>Connection</strong>： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</p><p><strong>Channels</strong>： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p><p><strong>VirtualHost</strong>：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>自己搞定</p><h2 id="RabbitMQ三种模式"><a href="#RabbitMQ三种模式" class="headerlink" title="RabbitMQ三种模式"></a>RabbitMQ三种模式</h2><h3 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h3><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\direct.png"> </p><p>我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。</p><p>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</p><p>一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p><p>这种模式下不需要将Exchange进行任何绑定(binding)操作<br>消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。<br>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p><ul><li><p>创建队列</p><p>首先在浏览器登录RabbitMQ：<a href="http://192.168.228.129:15672/">http://192.168.2XX.129:15672</a> ，按照下图创建一个队列就可以了:</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\d00.png"></p></li><li><p>代码</p><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:  port: 8010spring:  application:    name: rabbitmq-demo  rabbitmq:    host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.49</span></span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplicationpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqDemoApplication</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;SpringApplication.run(RabbitmqDemoApplication.class, args);&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们写生产者代码（生产者采用Junit和SpringBoot整合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span><span class="meta">@SpringBootTestpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqDemoApplicationTests</span> </span>&#123;<span class="meta">@Autowired</span><span class="keyword">private</span> RabbitTemplate rabbitTemplate;<span class="comment">/** * 直接模式 */</span><span class="meta">@Test</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;<span class="comment">//在直接模式的队列中放入数据rabbitTemplate.convertAndSend(&quot;j05_direc&quot;,&quot;我是直接模式!&quot;);&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>此时你运行生产者函数时，在消息队列的界面会显示一条消息（Ready）</p></li><li><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 运行方式:直接启动springboot的启动类,在控制台观察msg * <span class="doctag">@author</span> success * <span class="doctag">@version</span> 1.0 * <span class="doctag">@description</span>:本类用来演示:消费直接模式消息队列中的数据 * <span class="doctag">@date</span> 2019/9/2 0002 */</span><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;j05_direc&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectionController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;直接模式j05_direc-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>当你运行消费者代码时，在run栏会打印出：</p><p><img src></p></li><li><p>当然，你想设置多个消费者时，我们可以将springboot单例运行选项去掉</p><p>然后改掉配置文件的端口号，重新把程序跑一次，这样，就有两个消费者了，再改端口号，再运行就是三个消费者了。多运行几次生产者的测试函数，三个消费者会轮流输出（因为这里是默认负载均衡的，所有会轮流输出）。</p></li></ul><h2 id="分裂模式"><a href="#分裂模式" class="headerlink" title="分裂模式"></a>分裂模式</h2><p>当我们需要将消息一次发给多个队列时，需要使用这种模式。如下图：</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\exchange.png"> </p><p>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</p><ol><li>可以理解为路由表的模式</li><li>这种模式不需要RouteKey</li><li>这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。</li><li>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃.</li></ol></li></ul><h3 id="交换器绑定队列"><a href="#交换器绑定队列" class="headerlink" title="交换器绑定队列"></a>交换器绑定队列</h3><ul><li><p>创建三个队列</p><p>j05_direc和cctv1和cctv2</p><p><img src></p></li><li><p>创建j05_alls交换器</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\fadeout.png"> </p></li><li><p>将j05_alls交换器和三个队列进行绑定</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\binding.png"> </p><p>这样向j05_alls交换器里发消息，交换器就会向绑定的三个消息队列里面发消息（）。</p></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  * 分裂模式  */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testFadeIn</span><span class="params">()</span></span>&#123;    <span class="comment">//在分裂模式中的exchanges中放入数据    rabbitTemplate.convertAndSend(&quot;j05_alls&quot;,&quot;&quot;,&quot;我是分裂模式!&quot;);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>三个消费者</p><ul><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;j05_direc&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectionController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;直接模式j05_direc-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;cctv1&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FadeOutController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;分裂模式-cctv1-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="meta">@RabbitListener(queues = &quot;cctv2&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicController</span> </span>&#123;    <span class="meta">@RabbitHandler</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;        System.out.println(<span class="string">&quot;主题模式模式cctv2-&gt;msg:&quot;</span>+msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>运行后可得下面结果</p><p><img src></p></li></ul><h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\topic_exchange.png"> </p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\topic.png"> </p><p>如上图所示此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.newsusa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。</p><p>注：<br>交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p><p>这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。<br>这种模式需要RouteKey，也许要提前绑定Exchange与Queue。<br>在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。<br>“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。<br>同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息</p><h4 id="创建队列与绑定"><a href="#创建队列与绑定" class="headerlink" title="创建队列与绑定"></a>创建队列与绑定</h4><p>和分裂模式一样，只是在Exchanges设置里面添加Routing  Key</p><p><img src="/2021/10/19/springclound/cloud-demo03s\note\imgs\topic_binding.png"> </p><p>代码编写</p><p>分裂模式一样，只需要在3个Customer类里面修改下convertAndSend的参数就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 主题模式 */</span><span class="meta">@Testpublic</span> <span class="function"><span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span></span>&#123;    <span class="comment">//分别测试    rabbitTemplate.convertAndSend(&quot;j05_topic&quot;,&quot;good.log&quot;,&quot;我是主题模式!&quot;);&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>数组排序</title>
    <link href="http://example.com/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-10T09:54:17.000Z</published>
    <updated>2022-01-10T02:16:58.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><p><strong>简介:重点掌握冒泡,选择,快速排序</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>相邻的俩个进行俩俩比较.</p><p>每一轮比较完 - 确定一个最值</p><p><strong>9 3</strong> 1 7 5 2 1 </p><p>3 <strong>9 1</strong> 7 5 2 1</p><p>3 1 <strong>9 7</strong> 5 2 1</p><p>3 1 7 <strong>9 5</strong> 2 1</p><p>3 1 7 5 <strong>9 2</strong> 1</p><p>3 1 7 5 2 <strong>9 1</strong></p><p>3 1 7 5 2 1 <strong>9</strong></p><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/bubble.gif">      </p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>9 3</strong> 1 7 5 2 6</p><p>arr[0] -&gt; 依次和 后面所有的元素进行比较</p><p><strong>3</strong> 9 <strong>1</strong> 7 5 2 6</p><p><strong>1</strong> 9 3 7 5 2 6</p><p>确定最值</p><p>arr[1] -&gt; 依次和后面的所有的元素进行比较</p><p><strong>1</strong> <strong>2</strong> 9 7 5 3 6</p><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/select.gif"> </p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>简介:<em><strong>最简单的</strong></em></p><p>将数组中剩余的值(从数组中第2个位置开始)依次直接插入到前面,<strong>保证前面的序列仍然是一个有序的序列</strong></p><p>{3,1,2,5,4,6}</p><p>{<em><strong>3</strong></em>,1,2,5,4,6}</p><p>{<em><strong>1,3</strong></em>,2,5,4,6}</p><p>{<em><strong>1,2,3</strong></em>,5,4,6}</p><p>…</p><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/insert.gif">  </p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/2021/08/10/%E5%90%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/fast.gif"> </p><p>算法思想:</p><p><strong>分治思想</strong>:比大小,再分区</p><ol><li>从数组中取出一个数,作为<strong>基准数</strong></li><li>分区:将比这个数[基准数]大或者等于的数全部放在它的右边,小于它的数全部放在它的左边</li><li>再对左右分区间重复第二步骤,直到各分区只有一个数</li></ol><p>实现思路:</p><p>挖坑填数</p><ol><li><strong>将基准数挖出形成第一个坑</strong></li><li><strong>由后向前找比它小的数,找到后挖出此数填到前一个坑中</strong></li><li><strong>由前向后找比它大或等于的数,找到后也挖出此数填到前一个坑中</strong></li><li><strong>再重复执行2,3两步骤.例如对5391672408</strong></li></ol><table><thead><tr><th>元素</th><th>5</th><th>3</th><th>9</th><th>1</th><th>6</th><th>7</th><th>2</th><th>4</th><th>0</th><th>8</th></tr></thead><tbody><tr><td>坑位</td><td>坑1</td><td></td><td>坑3</td><td></td><td>坑5</td><td>坑7</td><td>坑6</td><td>坑4</td><td>坑2</td><td></td></tr><tr><td></td><td>0</td><td>3</td><td>4</td><td>1</td><td>2</td><td>基准数5</td><td>7</td><td>6</td><td>9</td><td>8</td></tr><tr><td>坑位</td><td></td><td></td><td></td><td></td><td></td><td>pos</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>元素</th><th>5[基准数]</th><th>3</th><th>9</th><th>1</th><th>6</th><th>7</th><th>2</th><th>4</th><th>0</th><th>8</th></tr></thead><tbody><tr><td>坑位</td><td>坑1</td><td></td><td>坑3</td><td></td><td>坑5</td><td>坑7</td><td>坑6</td><td>坑4</td><td>坑2</td><td></td></tr><tr><td></td><td>0</td><td>3</td><td>4</td><td>1</td><td>2</td><td>基准数5</td><td>7</td><td>6</td><td>9</td><td>8</td></tr><tr><td>坑位</td><td></td><td></td><td></td><td></td><td></td><td>第一次重合的位置</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一轮以数组中的第一个元素5为基准数 - 经过一轮循环走完 - 以5位置为基准,左边的都是比5小的值,右边的都是大于或者等于5的数字 - <strong>关键就是找到重合的位置!!!(分区 - 递归调用)</strong></p><p>int[] arr = {5,3,9,1,6,7,2,4,0,8};</p><p>t</p><h2 id="其他排序"><a href="#其他排序" class="headerlink" title="其他排序"></a>其他排序</h2><ul><li>希尔排序</li><li>堆排序</li><li>归并排序6t</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day16</title>
    <link href="http://example.com/2021/08/01/day16/"/>
    <id>http://example.com/2021/08/01/day16/</id>
    <published>2021-08-01T11:02:10.000Z</published>
    <updated>2022-01-07T09:04:19.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h1><blockquote><ol><li><p><strong>反射式编程</strong>（英语：reflective programming）或<strong>反射</strong>（英语：reflection)或者<strong>内省</strong></p></li><li><p>是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。[<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-Forman_p8-1">1]</a>用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p><p>“通俗讲” - 通过反射技术在程序的运行过程中,来获取类/接口的信息[修饰符,类的名称,父类],属性的信息[修饰符,数据类型,属性名],方法的信息[修饰符,数据类型,名称]等.</p><p><strong>在运行的时候才知道我操作的是哪个类</strong></p></li><li><p>掌握目标:</p><p>3-1. <strong>通过反射技术来动态获取属性的信息</strong>以及<strong>操作属性</strong>[反射的技术来对属性的值进行设置和获取]</p><p>3-2. 通过<strong>反射技术来动态调用类中的构造方法</strong>以及<strong>获取构造方法的信息</strong>[修饰符,方法名,参数列表]</p><p>3-3. 通过反射技术来动态获取类里面的<strong>方法的信息</strong>[修饰符,数据类型,方法名以及方法参数列表]以及反射<strong>调用方法</strong></p></li><li><p>api包 - java.lang.reflect</p></li><li><p>反射优势 - “很流氓” - 破坏封装性.</p></li><li><p><strong>学好反射和设计模式 - 帮助我们未来来读懂一些框架源码的.所有的框架的底层都是基于反射技术来实现的.</strong></p></li></ol></blockquote><h1 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class<T></T></h1><blockquote><ol><li><p>class实例 - 一个类无论被实例化多少次,那么它在JVM中的class实例永远只有1个.</p></li><li><p>它是学习反射技术的必备的类 - 提供了很多api来完成掌握目标中的动作.</p></li><li><p><strong>所有被类加载器加载到内存中的类都是属于Class的对象</strong> - Class类是用来描述类的类[用来描述类的元信息]</p><p><strong>我们的类在Class面前,就是一个Class的对象而已</strong></p></li></ol></blockquote><h2 id="反射相关api"><a href="#反射相关api" class="headerlink" title="反射相关api"></a>反射相关api</h2><blockquote><ol><li><p><strong>Field getDeclaredField(String name);//根据属性的名称来得到Field对象</strong></p></li><li><p><strong>Field[] getDeclaredFields();//获取类里面所有的[包括私有的]声明的属性对应的Field数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只能获取到非私有的</span><br><span class="line"><span class="number">1.</span> <span class="function">Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="number">2.</span> Field[] getFields();</span><br></pre></td></tr></table></figure></li><li><p>String getName();//获取类的全限定名</p></li><li><p>String getSimpleName();//获取类的简称</p></li><li><p><strong>T newInstance();//调用空参构造</strong></p></li><li><p><strong>Constructor<T>    getDeclaredConstructor(Class&lt;?&gt;…  parameterTypes);</T></strong></p><p><strong>根据指定的参数类型来得到指定的构造对应的实例Constructor对象.</strong></p><p>如果什么参数都不传入,拿到的就是空参构造对应的Constructor对应的实例.</p></li><li><p><strong>Constructor&lt;?&gt;[]    getDeclaredConstructors();</strong></p><p><strong>直接获取类中的所有的构造,每个构造对应一个Constructor.</strong></p></li><li><p><strong>Method    getDeclaredMethod(String methodName,Class&lt;?&gt;…  parameterTypes);</strong></p></li><li><p><strong>Method][]    getDeclaredMethods();</strong></p></li></ol></blockquote><h2 id="获取类的Class实例的方式"><a href="#获取类的Class实例的方式" class="headerlink" title="获取类的Class实例的方式"></a>获取类的Class实例的方式</h2><blockquote><ol><li><p>类名.class</p></li><li><p>调用java.lang.Object类提供的方法Class&lt;?&gt; getClass();</p></li><li><p>框架底层喜欢的使用一种,更加灵活</p><p>Class类中提供的static Class&lt;?&gt; forName(“类的全限定名”);//需要抓取一个非运行时异常java.lang.ClassNotFoundException类型找不到异常</p></li><li><p>基本类型.class</p></li></ol></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: java.lang.Class&lt;T&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 10:26 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类的class实例的方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个类在JVM中的class实例永远只有1个 - 无论构建了多少个对象</span></span><br><span class="line">        <span class="comment">//1. 类名.class</span></span><br><span class="line">        Class&lt;?&gt; c1 = Point.class;</span><br><span class="line">        Class&lt;?&gt; c2 = Point.class;</span><br><span class="line">        System.out.println(c1);<span class="comment">//class tech.aistar.day16.Point</span></span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c3 = String.class;</span><br><span class="line">        System.out.println(c3);<span class="comment">//class java.lang.String</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对象.getClass();</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">        Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c4 = p1.getClass();<span class="comment">//对象的类型</span></span><br><span class="line">        Class&lt;?&gt; c5 = p2.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型判断    对象 instanceof 类</span></span><br><span class="line">        System.out.println(c4);<span class="comment">//class tech.aistar.day16.Point</span></span><br><span class="line">        System.out.println(c4 == c5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. Class类中提供的static Class&lt;?&gt; forName(&quot;类的全限定名&quot;);</span></span><br><span class="line">        <span class="comment">//TODO... 为甚鼓励使用这种 ???</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c6 = Class.forName(<span class="string">&quot;tech.aistar.day16.Point&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;c6:&quot;</span>+c6);<span class="comment">//c6:class tech.aistar.day16.Point</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 基本类型.class</span></span><br><span class="line">        Class&lt;?&gt; c7 = <span class="keyword">int</span>.class;</span><br><span class="line">        System.out.println(c7);<span class="comment">//int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Field字段实例"><a href="#Field字段实例" class="headerlink" title="Field字段实例"></a>Field字段实例</h1><blockquote><p>java.lang.reflect.Field</p></blockquote><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><blockquote><ol><li><p>int getModifiers();<br>返回由该 Field对象表示的字段的Java语言修饰符，作为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的 - 0</span></span><br><span class="line"><span class="comment">//public  -1</span></span><br><span class="line"><span class="comment">//private - 2</span></span><br><span class="line"><span class="comment">//protected - 4</span></span><br></pre></td></tr></table></figure></li><li><p>Class&lt;?&gt; getType();//返回属性的数据类型</p></li><li><p>String getName();//属性的名称</p></li><li><p>void set(Object obj,Object value);//通过属性对应的Field对象来告知JVM,应该把value设置到哪个obj对象上去.</p></li><li><p>void setAccessible(boolean on);//反射操作私有属性,必须要设置为true,否则会抛出-java.lang.IllegalAccessException</p></li><li><p>Object get(Object obj);//返回obj中属性字段的对应的属性值.</p></li></ol></blockquote><h1 id="Constructor构造实例"><a href="#Constructor构造实例" class="headerlink" title="Constructor构造实例"></a>Constructor构造实例</h1><h2 id="调用空参构造"><a href="#调用空参构造" class="headerlink" title="调用空参构造"></a>调用空参构造</h2><blockquote><ol><li><p>直接调用java.lang.Class<T>提供的方法T newsIntance();</T></p></li><li><p>java.lang.reflect.Constructor提供了方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">Constructor&lt;?&gt; c1 </span>= c.getDeclaredConstructor();</span><br><span class="line">Point p2 = (Point) c1.newInstance();<span class="comment">//可变长列表的方法</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="调用带参构造"><a href="#调用带参构造" class="headerlink" title="调用带参构造"></a>调用带参构造</h2><blockquote><ol><li><p>java.lang.reflect.Constructor - 提供的方法</p><p>public T newInstance(Object … initargs)</p></li></ol></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>int getModifiers();//获取修饰符对应的数字</p></li><li><p>String getName();//构造方法的名称 - [类的全限定名]</p></li><li><p><strong>void setAccessible(boolean on);//如果设置true,直接调用私有的的构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射可以破坏单例</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h1><blockquote><p>java.lang.reflect</p><ol><li><p>传入一个修饰符对应的数字,来返回修饰的具体的中文的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; PUBLIC) != <span class="number">0</span>)        sb.append(<span class="string">&quot;public &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; PROTECTED) != <span class="number">0</span>)     sb.append(<span class="string">&quot;protected &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; PRIVATE) != <span class="number">0</span>)       sb.append(<span class="string">&quot;private &quot;</span>);</span><br><span class="line">         </span><br><span class="line">  <span class="comment">/* Canonical order */</span></span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; ABSTRACT) != <span class="number">0</span>)      sb.append(<span class="string">&quot;abstract &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; STATIC) != <span class="number">0</span>)        sb.append(<span class="string">&quot;static &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; FINAL) != <span class="number">0</span>)         sb.append(<span class="string">&quot;final &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; TRANSIENT) != <span class="number">0</span>)     sb.append(<span class="string">&quot;transient &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; VOLATILE) != <span class="number">0</span>)      sb.append(<span class="string">&quot;volatile &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; SYNCHRONIZED) != <span class="number">0</span>)  sb.append(<span class="string">&quot;synchronized &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; NATIVE) != <span class="number">0</span>)        sb.append(<span class="string">&quot;native &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; STRICT) != <span class="number">0</span>)        sb.append(<span class="string">&quot;strictfp &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((mod &amp; INTERFACE) != <span class="number">0</span>)     sb.append(<span class="string">&quot;interface &quot;</span>);</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span> ((len = sb.length()) &gt; <span class="number">0</span>)    <span class="comment">/* trim trailing space */</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString().substring(<span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="反射可以破坏单例"><a href="#反射可以破坏单例" class="headerlink" title="反射可以破坏单例"></a>反射可以破坏单例</h2><blockquote><p>反射破坏不了枚举单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.design.singleton.version03.Singleton03;</span><br><span class="line"><span class="keyword">import</span> tech.aistar.design.singleton.version04.Singleton04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射可以破坏单例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 2:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectPoSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取单例的Class实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(<span class="string">&quot;tech.aistar.design.singleton.version03.Singleton03&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 获取空参构造对应的Constructor实例</span></span><br><span class="line">            Constructor&lt;?&gt; c1 = c.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">//3. 调用私有的空参构造</span></span><br><span class="line">            c1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 调用</span></span><br><span class="line">            Singleton03 s1 = (Singleton03) c1.newInstance();</span><br><span class="line">            <span class="comment">//反射连续调用俩次私有的空参构造</span></span><br><span class="line">            Singleton03 s2 = (Singleton03) c1.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="为何破坏不了枚举类型单例"><a href="#为何破坏不了枚举类型单例" class="headerlink" title="为何破坏不了枚举类型单例"></a>为何破坏不了枚举类型单例</h2><h2 id="分析-NoSuchMethodException"><a href="#分析-NoSuchMethodException" class="headerlink" title="分析-NoSuchMethodException"></a>分析-NoSuchMethodException</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记载类,初始化静态属性,调用空参构造 </span></span><br><span class="line">Class&lt;?&gt; c5 = Class.forName(<span class="string">&quot;tech.aistar.design.singleton.version05.Singleton05&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; cc = c5.getDeclaredConstructor();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">控制台效果</span><br><span class="line">比较繁琐的操作的事情,费时费力的事情</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在一个空参构造的方法让我们去调用</span></span><br><span class="line">java.lang.NoSuchMethodException: tech.aistar.design.singleton.version05.Singleton05.&lt;init&gt;()</span><br><span class="line">at java.lang.Class.getConstructor0(Class.java:<span class="number">3082</span>)</span><br><span class="line">at java.lang.Class.getDeclaredConstructor(Class.java:<span class="number">2178</span>)</span><br><span class="line">at tech.aistar.day16.ReflectPoSingleton.main(ReflectPoSingleton.java:<span class="number">36</span>)</span><br></pre></td></tr></table></figure><p>控制台</p><p>hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">  INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">确认jdk-bin-jad.exe - 没有下载 - http:<span class="comment">//varaneckas.com/jad/</span></span><br><span class="line">javac hello</span><br><span class="line">jad -s java hello</span><br><span class="line">反编译之后出来之后 hello(String.class,<span class="keyword">int</span>.class)</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br></pre></td></tr></table></figure><h2 id="分析-IllegalArgumentException"><a href="#分析-IllegalArgumentException" class="headerlink" title="分析 - IllegalArgumentException"></a>分析 - IllegalArgumentException</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载这个类</span></span><br><span class="line">Class&lt;?&gt; c5 = Class.forName(<span class="string">&quot;tech.aistar.design.singleton.version05.Singleton05&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">//java.lang.NoSuchMethodException - 抛出一个不存在这个方法</span></span><br><span class="line"></span><br><span class="line">cc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: </span></span><br><span class="line"><span class="comment">// Cannot reflectively create enum objects</span></span><br><span class="line">Singleton05 s05 = (Singleton05) cc.newInstance();</span><br></pre></td></tr></table></figure><p><code>原因剖析newInstance方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//判断是否为枚举类型,如果是枚举类型直接抛出了这个异常了.</span></span><br><span class="line">  <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>结论 - 不允许我们用反射的技术来构建枚举类型的实例,底层会进行类型的判断,发现如果是枚举类型对应的class实例,直接抛出异常</code></p></blockquote><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><p>一个对象的中的所有String类型的成员变量所对应的字符串内容中的”b”改为”a”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name = <span class="string">&quot;tbm&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String s1 = <span class="string">&quot;adminb&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射技术 - 所有字段拿出来 - Field数组中 </span></span><br><span class="line"><span class="comment">//获取到Field的类型,判断是不是String类型</span></span><br><span class="line"><span class="comment">//如果是String-&quot;b&quot;改为&quot;a&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="反射工厂"><a href="#反射工厂" class="headerlink" title="反射工厂"></a>反射工厂</h1><blockquote><p>回忆工厂设计模式[GOF]</p><ol><li>简单工厂方法,多方法工厂,静态方法工厂 - 本质上不属于GOF</li><li>工厂方法设计模式以及抽象工厂[专注于产品族] - 属于GOF</li><li>反射工厂 - 工厂类中利用反射技术来构建某个类的/接口的具体的实例.</li></ol></blockquote><h2 id="补充Properties"><a href="#补充Properties" class="headerlink" title="补充Properties"></a>补充Properties</h2><blockquote><ol><li><p>属于集合框架的类 - 属于Map[I]</p></li><li><p><strong>java.util.Properties extends java.util.Hashtable</strong>[哈希表,多线程安全的]</p></li><li><p>作用:通过io流把本地的.properties文件读取到内存中,然后映射到Properties对象</p><p><strong>Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射.</strong></p><p>File - 本地磁盘的文件在java内存中的映射的那个对象.</p></li><li><p>存储数据的格式然后是一个键值对的形式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key=value - key也是不要重复的.</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">tom</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>根据key来获取value的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="6"><li><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16.prop;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 读取Properties文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 8:41 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ReadPropDemo</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 定义一个Properties属性</span></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">   </span><br><span class="line">    ReadPropDemo()&#123;</span><br><span class="line">        <span class="comment">//可以在构造方法 - 初始化的</span></span><br><span class="line">        <span class="comment">//Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射.</span></span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//读取属性文件</span></span><br><span class="line">        <span class="comment">//InputStream in = new FileInputStream(&quot;src/tech/aistar/day16/prop.bean.properties&quot;);</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">//固定的语法 - 死记住</span></span><br><span class="line">        <span class="comment">//获取属性文件字节输入流</span></span><br><span class="line">        InputStream in = Thread.currentThread()</span><br><span class="line">                                .getContextClassLoader()</span><br><span class="line">                                .getResourceAsStream(<span class="string">&quot;tech/aistar/day16/prop/bean.properties&quot;</span>);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射.</span></span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确认properties不为null</span></span><br><span class="line">        <span class="keyword">return</span> properties == <span class="keyword">null</span>?<span class="keyword">null</span>:properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="6"><li><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16.prop;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 8:47 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadPropDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String value = ReadPropDemo.INSTANCE.getValue(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="反射工厂demo"><a href="#反射工厂demo" class="headerlink" title="反射工厂demo"></a>反射工厂demo</h2><blockquote><ol><li><p>简单工厂的缺点 - 如果有新的产品的加入,需要修改工厂类的 - 违背了软件开发的设计原则 - “开闭原则”</p><p>优点 - 够简单</p></li><li><p>工厂方法设计模式 - 优点:一个工厂类只负责生产一个产品,如果有新的产品的加入.不需要修改工厂类,只需要增加一个工厂类</p><p>缺点 - 项目中会存在很多的工厂类.</p></li><li><p>抽象工厂 - 负责创建一个产品族.</p></li><li><p><strong>反射工厂既能够保证在新增一个产品的时候,能够遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类.</strong></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射工厂 - 反射工厂既能够保证在新增一个产品的时候,能够遵守&quot;开闭原则&quot;,</span></span><br><span class="line"><span class="comment"> *                      又能够保证始终仅仅只有一个工厂类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             Properties + 反射 + 泛型方法/泛型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 9:13 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFactory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//面向接口编程</span></span><br><span class="line">    <span class="comment">//泛型方法 - 静态方法&lt;T&gt;,同时也要设置泛型类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T <span class="title">getInstance</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果传入进来的是type - 是某个类的全限定名,比如</span></span><br><span class="line">        <span class="comment">//tech.aistar.design.factory.reflect.TeacherDaoImpl</span></span><br><span class="line">        <span class="comment">//获取class实例的方式</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(type);</span><br><span class="line">            <span class="comment">//反射调用空参构造</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Point p = (Point) c.newInstance();</span></span><br><span class="line">                t = (T) c.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><blockquote><p>java.lang.reflect.Method</p></blockquote><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>int getModifiers();<br>返回由该 method对象表示的字段的Java语言修饰符，作为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的 - 0</span></span><br><span class="line"><span class="comment">//public  -1</span></span><br><span class="line"><span class="comment">//private - 2</span></span><br><span class="line"><span class="comment">//protected - 4</span></span><br></pre></td></tr></table></figure></li><li><p>Class&lt;?&gt; getReturnType();//返回方法的返回类型</p></li><li><p>String getName();//方法的名称</p></li><li><p>Class&lt;?&gt;[] getParameterTypes();//返回方法的参数列表.</p></li><li><p>Object invoke(Object obj,Object… args);//反射调用方法</p></li><li><p>void setAccessible(boolean on);//调用私有方法需要调用之前来设置可见性 - true</p></li></ol></blockquote><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><blockquote><p>java.lang.reflect.Array - <code>Array</code>类提供静态方法来动态创建和访问Java数组 - <strong>反射技术操作java数组</strong></p><p>面试题 - <strong>Arrays和Array的区别!</strong></p><p>java.util.Arrays - 数组工具类.</p></blockquote><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><blockquote><ol><li><p>static int getLength(Object array)<br>返回指定数组对象的长度，如 int 。</p></li><li><p>static Object get(Object array, int index)<br>返回指定数组对象中的索引组件的值。</p></li><li><p>static Object newInstance(Class&lt;?&gt; componentType, int length)<br>创建具有指定组件类型和长度的新数组。</p></li><li><p>static void set(Object array, int index, Object value)<br>将指定数组对象的索引组件的值设置为指定的新值。</p></li></ol></blockquote><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射操作java数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 1:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr1 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;java&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;db&quot;</span>,<span class="string">&quot;web&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用一个方法,来遍历上面俩个不同元素类型数组</span></span><br><span class="line">        <span class="comment">//反射技术来遍历数组</span></span><br><span class="line">        printArr(arr1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====华丽丽的分割线====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printArr(arr2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===反射动态创建数组===&quot;</span>);</span><br><span class="line">        <span class="comment">//对任何元素类型的数组,都可以进行扩容操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 确定新的数组的长度 - 原来数组的长度+扩容长度[反射创建新的数组]</span></span><br><span class="line">        <span class="comment">//2. 读取原来数组中的每个下标的数据[反射读取]一一复制到新的数组中[反射设置值]</span></span><br><span class="line">        <span class="comment">//3. 返回类型确定[扩容之后的] - Object</span></span><br><span class="line">        Integer[] temp = (Integer[]) extendsArr(arr1);</span><br><span class="line">        printArr(temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">        String[] strTemp = (String[]) extendsArr(arr2);</span><br><span class="line">        printArr(strTemp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组的扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">extendsArr</span><span class="params">(Object arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建数组必不可少的俩个条件.a. 数组的元素类型  b.数组的长度</span></span><br><span class="line">        <span class="comment">//获取旧数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = Array.getLength(arr);</span><br><span class="line">        <span class="comment">//确定新的数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> newLen = len*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取原来数组的组件的类型 - 数组的元素类型</span></span><br><span class="line">        Class&lt;?&gt; type = arr.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 反射创建新的数组了</span></span><br><span class="line">        Object newArr = Array.newInstance(type,newLen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 把arr旧数组中的元素拷贝新的数组中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//根据下标获取值</span></span><br><span class="line">            Object o = Array.get(arr,i);</span><br><span class="line">            <span class="comment">//把o设置到newArr数组的下标i处</span></span><br><span class="line">            Array.set(newArr,i,o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射访问</span></span><br><span class="line">    <span class="comment">//Integer[] String[] - 数组 - extends Object</span></span><br><span class="line">    <span class="comment">//并不是extends Object[]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(Object arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = Array.getLength(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历这个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//反射的技术通过下标去取元素</span></span><br><span class="line">            Object obj = Array.get(arr,i);</span><br><span class="line"></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><blockquote><p>只要了解即可.jdk5.0开始引入了注解的机制.</p><p>现在框架的配置,框架的使用 - 1. 基于xml的配置方式 2. 基于注解的配置/开发方式 - 简洁</p><p>学习注解的目的是为了以后能够知道我们框架的使用中遇到注解,知道这个注解背后是个大概什么底层即可.</p></blockquote><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><blockquote><ul><li><p>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p></li><li><p>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</p></li><li><p>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</p><p>@SuppressWarnings(“all”) - 抑制所有的警告</p></li><li><p>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</p></li></ul></blockquote><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote><ol><li><p>使用@interface来修饰注解,自定义的注解默认都会继承java.lang.Annotation</p></li><li><p><strong>@Target - 指定你这个注解可以在什么地方被使用</strong></p><p>哪些地方 - 类,方法,参数,接口,局部变量上,属性,构造</p><p>值可以设置成枚举类型java.lang.annotation.ElementType中的枚举常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Retention(RetentionPolicy.RUNTIME)</p><p>可以在程序的运行过程中,通过反射的技术来得到注解的信息.</p></li><li><p><strong>注解中只有方法的概念,没有的属性的概念</strong></p></li></ol></blockquote><h2 id="反射获取注解的值"><a href="#反射获取注解的值" class="headerlink" title="反射获取注解的值"></a>反射获取注解的值</h2><blockquote><p><strong>有办法来判断类或者方法是否加入了注解</strong></p><p><strong>有办法通过反射技术来获取类/方法上加入注解的属性值</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day16.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 反射获取注解的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/13 2:39 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断某个类或者某个方法上是否有注解</span></span><br><span class="line">        <span class="comment">//有注解 - 标志 - 对这个有注解的类该干嘛干嘛...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注解还配置了属性值 - 需要取出属性值,然后再进行进一步的处理...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//类</span></span><br><span class="line">        Class&lt;?&gt; c = UseMyAnno.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 判断类上是否加入了MyAnno注解</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = c.isAnnotationPresent(MyAnno.class);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(c.getSimpleName()+<span class="string">&quot;加入了注解!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取注解的属性值 - 前提是有</span></span><br><span class="line">            MyAnno myAnno = c.getAnnotation(MyAnno.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取属性值</span></span><br><span class="line">            String[] arr = myAnno.value();</span><br><span class="line"></span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(c.getSimpleName()+<span class="string">&quot;上没有加入注解!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====方法上的注解的信息 - 反射技术===&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(m.isAnnotationPresent(MyAnno.class))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;方法上有注解!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                MyAnno myAnno = m.getAnnotation(MyAnno.class);</span><br><span class="line"></span><br><span class="line">                String[] arr = myAnno.value();</span><br><span class="line">                System.out.println(Arrays.toString(arr));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;方法上没有注解...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mybatis注解开发方法"><a href="#mybatis注解开发方法" class="headerlink" title="mybatis注解开发方法"></a>mybatis注解开发方法</h2><blockquote><p>mybatis底层使用到的是jdbc技术 - 和数据库打交道的技术</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jdbc步骤很繁琐,步骤比较多~</span><br><span class="line">打开</span><br><span class="line">Connection con = DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">String sql=<span class="string">&quot;delete from user&quot;</span>;</span><br><span class="line">PreparedStatement pstmt = con.prepareStatement(sql);</span><br><span class="line"> ResultSet rs = pstmt.executeQuery();</span><br><span class="line">关闭</span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure><blockquote><p>mybatis就是会对jdbc的代码进行一个封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>尝试走一遍mybatis作者的路线</code></p><p><code>自定义一个注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Select&#123;</span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注解本身是不会完成任何的业务逻辑的.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">通过反射的技术-&gt;select * from user</span><br><span class="line">  </span><br><span class="line">工具类&#123;</span><br><span class="line">  Connection con = DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    String sql=<span class="string">&quot;反射技术获取的&quot;</span>;</span><br><span class="line">    PreparedStatement pstmt = con.prepareStatement(sql);</span><br><span class="line">     ResultSet rs = pstmt.executeQuery();</span><br><span class="line">    关闭</span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第一阶段corejava总结"><a href="#第一阶段corejava总结" class="headerlink" title="第一阶段corejava总结"></a>第一阶段corejava总结</h1><blockquote><ol><li>JVM内存模型+<strong>GC算法</strong> - 面试必问</li><li><strong>静态代理和动态代理 - 设计模式</strong></li></ol></blockquote><h2 id="体系回顾"><a href="#体系回顾" class="headerlink" title="体系回顾"></a>体系回顾</h2><blockquote><ol><li><strong>part01-基础语法-数组的排重/排序算法/递归算[阶乘,杨辉,斐波那契数列]</strong></li><li><strong>part02</strong><ul><li><strong>封装,继承,多态</strong></li><li><strong>四种访问修饰符</strong></li><li><strong>static关键字,final,abstract修饰符</strong></li><li><strong>String,StringBuffer,StringBuilder</strong></li><li><strong>包装类型Integer - [IntegerCache缓冲区,-128~127]</strong></li><li><strong>设计模式 - 单例[双重锁检测]+工厂+模板+装饰器</strong></li><li><strong>Object - equals&amp;hashcode,clone,toString,wait,notify,notifyAll,finalize,getClass()</strong></li><li><strong>Date&amp;Calendar&amp;SimpleDateFormat&amp;BigInteger - 常用的内置的api</strong></li></ul></li><li><strong>part03 - 集合框架</strong><ul><li><strong>ArrayList&amp;LinkedList&amp;Vector</strong></li><li><strong>HashSet&amp;TreeSet</strong></li><li><strong>HashMap&amp;Properties</strong></li></ul></li><li><strong>多线程体系</strong></li><li><strong>反射+注解</strong></li></ol></blockquote><h1 id="第二阶段的知识点"><a href="#第二阶段的知识点" class="headerlink" title="第二阶段的知识点"></a>第二阶段的知识点</h1><blockquote><p><strong>周一之前 - mysql环境装好</strong></p></blockquote><blockquote><p>围绕数据库</p></blockquote><blockquote><ol><li>mysql学习 - 关系型数据</li><li>jdbc学习 - java和db进行交互的技术</li><li>myabtis框架学习 - 持久层技术,对jdbc的封装</li></ol></blockquote><blockquote><p> <em><strong>相关知识点 - mybatis-plus框架,redis - 非关系型数据</strong></em></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day15</title>
    <link href="http://example.com/2021/07/29/day15/"/>
    <id>http://example.com/2021/07/29/day15/</id>
    <published>2021-07-29T10:02:10.000Z</published>
    <updated>2022-01-07T09:05:45.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><blockquote><p>一个程序至少一个进程，一个进程至少一个线程。<code>线程不能单独执行运行的,它一定是运行在进程的内部的</code></p></blockquote><blockquote><ul><li><p>进程[正在执行中的应用程序]：是并发执行的<strong>程序在执行过程中分配和管理资源的基本单位</strong>，是一个动态概念，</p></li><li><p><em><strong>竞争计算机系统资源的基本单位</strong></em>。 - “多任务操作系统” - “多个进程在**”同时”**在运行” - CPU分配资源 - <strong>“分时分片”</strong></p><p><code>处理器[cpu]调度的基本单位</code></p></li><li><p>线程：<strong>是进程的一个执行单元</strong>，是进程内部调度实体。<strong>比进程更小的独立运行的基本单位</strong>。<strong>线程也被称为轻量级进程</strong>。</p><p><code>一个进程可以拥有多个线程的同一个进程内部的多个线程是可以共享进程资源的.</code></p></li></ul></blockquote><h2 id="比如启动Java程序"><a href="#比如启动Java程序" class="headerlink" title="比如启动Java程序"></a>比如启动Java程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 启动Java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言]</span><br><span class="line">   开启一个JVM进程 - jvm.exe[windows中的可执行文件.C语言写的程序直接编译成了.exe可执行文件]</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 当JVM进程启动之后,同时开启俩个线程 - 分别是main主线程以及一个GC线程[后台守护线程]</span><br><span class="line">   守护线程 - 如果后台只剩下守护线程在执行的时候,那么进程就会结束.</span><br><span class="line">   进程的结束不需要等到守护线程全部执行完才会结束.</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span> main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束</span><br><span class="line">   GC线程负责进行垃圾对象的回收</span><br></pre></td></tr></table></figure><h1 id="创建线程的传统的方式"><a href="#创建线程的传统的方式" class="headerlink" title="创建线程的传统的方式"></a>创建线程的传统的方式</h1><blockquote><ol><li><p>写一个类去继承java.lang.Thread类 - 重写里面的run方法</p></li><li><p>写一个类去实现java.lang.Runnable接口 - 重写里面的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要用到java.lang.Thread类中的构造方法</span><br><span class="line">Thread(Runnable r);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Thread和Runnable区别"><a href="#Thread和Runnable区别" class="headerlink" title="Thread和Runnable区别"></a>Thread和Runnable区别</h2><blockquote><ol><li><p>第一种方式extends Thread方式 - 共享代码,不共享资源</p><blockquote><p>只有将资源设置成静态的 - 也是进行一个资源的共享的</p></blockquote></li><li><p>第二种方式implements Runnable接口 - 共享代码,共享资源</p></li><li><p>第三种方式Callable接口</p><p>推荐配合Future+线程池一起使用</p></li></ol></blockquote><h2 id="Callable和Runnable接口的区别"><a href="#Callable和Runnable接口的区别" class="headerlink" title="Callable和Runnable接口的区别"></a>Callable和Runnable接口的区别</h2><blockquote><ol><li>Callable可以通过Future来得到异步计算的结果 - 拿到线程执行之后的结果.</li><li>Callable调用的是call方法,Runnable调用的是run方法.</li><li>call方法是可以抛出一个异常列表的,但是run方法是不允许抛出异常列表的</li></ol></blockquote><h3 id="Callable-FutureTask"><a href="#Callable-FutureTask" class="headerlink" title="Callable+FutureTask"></a>Callable+FutureTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 拿到线程执行之后的结果</span></span><br><span class="line"><span class="comment"> *             Callable+FutureTask -&gt; 线程执行的结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 8:40 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main-begin...&quot;</span>);</span><br><span class="line">        Callable&lt;Integer&gt; c = <span class="keyword">new</span> C1();</span><br><span class="line">        <span class="comment">//FutureTask - 异步任务</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(c);</span><br><span class="line">        <span class="comment">//利用异步任务来构建Thread对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        t.start();<span class="comment">//启动线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程已经启动了...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//拿线程计算的结果</span></span><br><span class="line">            <span class="comment">//get()方法一定是要等到线程执行结束之后 - 才会停止</span></span><br><span class="line">            System.out.println(<span class="string">&quot;result:&quot;</span>+task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main-end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            total+=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//故意模拟一个比较费时费力的任务</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> total;<span class="comment">//5050</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Callable-Future-线程池"><a href="#Callable-Future-线程池" class="headerlink" title="Callable+Future+线程池"></a>Callable+Future+线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: Callable+Future&lt;T&gt; + 缓存线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/12 8:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallablePoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建一个可缓存的线程池对象</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向这个缓存池中提交任务</span></span><br><span class="line">        <span class="comment">//第一个任务 - 负责计算1~100</span></span><br><span class="line">        Future&lt;Integer&gt; future1 = executorService.submit(<span class="keyword">new</span> C2());<span class="comment">// 准备启动一个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再向这个缓存池中提交一个任务</span></span><br><span class="line">        <span class="comment">//第二个任务 - 负责计算1~10</span></span><br><span class="line">        Future&lt;Integer&gt; future2 = executorService.submit(<span class="keyword">new</span> CC());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务的数量和线程的数量一定一样吗???</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有个效果 -&gt; 俩个线程 - 同时执行这俩个异步任务</span></span><br><span class="line">        <span class="comment">//pool-1-thread-1-正在计算1~100</span></span><br><span class="line">        <span class="comment">//pool-1-thread-2正在计算1~10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要将俩个线程执行的结果进行一个相加的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get()方法肯定是会等到线程执行完之后.才会继续走</span></span><br><span class="line">            Integer result1 = future1.get();</span><br><span class="line">            Integer result2 = future2.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果俩个线程get()方法不走完,那么main线程也是不会继续执行的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开始整合...&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = result1 + result2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//main线程</span></span><br><span class="line">            <span class="comment">//5050+55 = 5105</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(future1.get()+future2.get());</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-正在计算1~100&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            total += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在计算1~10&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            total+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的类和线程非安全的类"><a href="#线程安全的类和线程非安全的类" class="headerlink" title="线程安全的类和线程非安全的类"></a>线程安全的类和线程非安全的类</h2><blockquote><p>StringBuilder - 线程非安全的字符串类,StringBuffer - 线程安全的字符串类</p><p>ArrayList - 线程非安全的集合,Vector - 线程安全的集合</p><p>HashMap - 线程非安全的集合,Hashtable - 线程安全的集合</p><p><strong>以上线程安全的类 - api方法使用到了synchronized方法进行了修饰 - 在某个时刻,只能由一个线程去访问,其他线程都是出于等待状态</strong></p></blockquote><h2 id="Thread提供的常用方法"><a href="#Thread提供的常用方法" class="headerlink" title="Thread提供的常用方法"></a>Thread提供的常用方法</h2><blockquote><ol><li>static Thread currentThread();//返回当前正在执行的线程的引用对象</li><li>String getName();//返回线程的名称</li><li>void start();//启动线程,本质当t1.start()方法的时候底层会让JVM去启动线程,我们的程序是没有资格和能力去真正的把一个线程给启动起来的.  CPU调度JVM进程-调用t1线程.</li><li>void setName(String name);//给线程设置名称</li><li>void setPriority(int n);//设置线程的优先级,数字[1~10].注意点:数字越大,优先级越高.但是并不是优先级越高的线程就一定会优先执行.只是希望它先执行.最终还是要cpu的.</li><li>void setDaemon(boolean on);//设置成true,这个线程成为了一个后台守护线程了.</li></ol></blockquote><h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><blockquote><ol><li>Java语言的关键字，</li><li><strong>可用来给对象和方法或者代码块加锁</strong></li><li>当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候，<strong>同一时刻最多只有一个线程执行这段代码</strong> </li><li>当两个并发线程访问同一个<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1object/22817693">对象object</a>中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li><li>非公平锁</li><li>如果同步代码块中出现了异常,那么仍然还是会自动释放锁资源的</li></ol></blockquote><h2 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2><blockquote><p>在java中,<strong>每个对象有且仅有一个同步锁</strong>,并且同步锁是依赖于对象存在的.当我们调用对象的synchronized修饰的同步方法时候,就是获取了该对象的同步锁.</p></blockquote><blockquote><ol><li>修饰普通方法 - <strong>对象锁</strong> - 不同的对象拥有独立的”一把锁”,每个对象的”锁”是不冲突的 - “自助餐”</li><li>**修饰静态方法 - “类锁” - **作用于这个类下的所有的对象 - 这个类实例化出来的所有的对象竞争的是”同一把锁” - 类锁 - “一个桌子上”</li><li>修饰代码块synchronized(this) - 对象锁</li><li>修饰代码块(XXX.class) - <strong>“类锁”</strong></li></ol></blockquote><h2 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h2><blockquote><ol><li><p>原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所谓的原子性代表一个操作或者多个操作,要么执行全部并且执行的过程中不能被任何因素打断.要么就不执行.</span><br><span class="line">比如i++,i+=<span class="number">2</span>,i=i+<span class="number">1</span>;这些操作都不是原子操作[读取,计算,赋值].这三个步骤不是原子性 - 三个步骤中的任何一个步骤在执行的过程.</span><br><span class="line">其他都可能去打断它.</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;<span class="comment">//原子操作</span></span><br><span class="line">特殊的 - 了解即可</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">3.0d</span>或者<span class="keyword">long</span> x1 = <span class="number">20L</span> - 不具备原子性的.</span><br></pre></td></tr></table></figure></li><li><p>可见性</p><p><code>原因:遇到synchronized之后,清空本地工作内存,重新从主存去拷贝最新的值</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是可见的  </span><br></pre></td></tr></table></figure></li><li><p>有序性</p><blockquote><p>在同一个时刻,只能由一个线程进入.</p></blockquote></li><li><p>可重入性</p><blockquote><p>当一个线程申请到锁资源并且执行完毕之后[释放],仍然还有机会再去继续申请曾经申请过的锁资源.</p></blockquote></li></ol></blockquote><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><blockquote><p>JMM就是<strong>Java内存模型(java memory model - 不是JVM内存模型</strong></p><p>Java内存模型规定<strong>所有的变量都存储在主内存</strong>中，包括实例变量[类中的非静态属性]，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行</strong>。<strong>线程不能直接读写主内存中的变量</strong>。</p><p>不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。</p><p><img src="/2021/07/29/day15/jmm.jpeg"> </p></blockquote><p><img src="/2021/07/29/day15/jmm2.png">    </p><h2 id="描述i-过程-多线程安全问题"><a href="#描述i-过程-多线程安全问题" class="headerlink" title="描述i++过程 - 多线程安全问题"></a>描述i++过程 - 多线程安全问题</h2><blockquote><p>前提:</p><ol><li><p>线程是不能够操作对主存中的数据进行直接的操作的,必须是在本地的工作内存中去完成的.完成之后,刷回主存的</p></li><li><p><strong>线程之间是隔离的</strong>.每个线程去执行方法的时候,都会在本地开辟一块区域[栈帧 - 线程栈],每个线程在本地工作内存中</p><p>对资源的修改,那么这个资源的信息,状态对其他线程都是不可见的.</p></li></ol></blockquote><p><code>add方法没有使用synchronized进行修饰的流程</code></p><p><code>脏数据</code> - 本地工作内存中的变量的数据和主存中的变量的数据的值已经不一样,违背了”JMM中的缓存一致性”的原则.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">i++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断</span><br><span class="line">①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=<span class="number">0</span>)      =&gt; T1</span><br><span class="line">  `T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=<span class="number">0</span>)`   =&gt; T0</span><br><span class="line">          `T0线程直接进行了计算,赋值,重新刷回到主存[i=<span class="number">1</span>]`   =&gt; T0</span><br><span class="line">    `T0线程刷回i到主存之后,此时主存的i=<span class="number">1</span>,T0线程让出cpu执行权` </span><br><span class="line">②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i   =&gt; T1</span><br><span class="line">  `T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本`</span><br><span class="line">  `所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是<span class="number">0</span>]`</span><br><span class="line">  `T1线程i = i + <span class="number">1</span>,刷回到主存[i=<span class="number">1</span>]`</span><br><span class="line">  `因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`</span><br><span class="line">③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存]  =&gt; T1</span><br><span class="line">  [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中</span><br><span class="line">   获取变量的副本,重复执行①②③)</span><br><span class="line">  </span><br><span class="line">隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的</span><br><span class="line">   </span><br><span class="line">看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了<span class="number">1</span>次的结果.</span><br></pre></td></tr></table></figure><h3 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h3><blockquote><p>使用synchronized对i++所在的方法进行修饰.</p><p>当某个对象调用add方法,得到锁资源的时候,会先<strong>清空</strong>本地工作内存.清空的目的是为了让后面的操作重新从主存中拷贝最新的值.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻,只能由一个线程[获得锁资源的]进去执行</li><li>[<strong>读取,计算,赋值</strong>] - 三个步骤中.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞.</li><li>当正在执行的线程释放锁资源之前,它会将本地工作内存中的改变刷回到主存.</li></ol></blockquote><h2 id="什么时候工作内存中的改变会同步到主存中"><a href="#什么时候工作内存中的改变会同步到主存中" class="headerlink" title="什么时候工作内存中的改变会同步到主存中"></a>什么时候工作内存中的改变会同步到主存中</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><blockquote><ol><li>当前的单线程执行方法结束的时候</li></ol></blockquote><p>###多线程</p><blockquote><ol><li>线程释放锁资源的时候</li><li>线程切换</li></ol></blockquote><h1 id="分析可见性代码"><a href="#分析可见性代码" class="headerlink" title="分析可见性代码"></a>分析可见性代码</h1><h2 id="先写再读"><a href="#先写再读" class="headerlink" title="先写再读"></a>先写再读</h2><blockquote><p>读线程为什么可以终止循环.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果先写后读</span></span><br><span class="line">t1.start(); <span class="comment">//x=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的睡一秒,已经足够让我们的写线程把x=5的最终结果刷回到主存了呀</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t2.start();<span class="comment">//发现x变成了5</span></span><br></pre></td></tr></table></figure></blockquote><p><img src="/2021/07/29/day15/write.png"> </p><h2 id="先读再写"><a href="#先读再写" class="headerlink" title="先读再写"></a>先读再写</h2><blockquote><p>多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是不可见的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果先读后写</span></span><br><span class="line">t2.start();<span class="comment">//读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1.start();<span class="comment">//写</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/29/day15/read.png"> </p><h2 id="synchronized深入"><a href="#synchronized深入" class="headerlink" title="synchronized深入"></a>synchronized深入</h2><blockquote><p>特点 - 对象重新获得锁资源的时候,会先清空本地工作内存.强制从主存中去拷贝已经更新的变量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">先读再写,仅仅是在循环体中添加了一行代码 </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readX</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//写线程过了许久之后,x=5的改变刷回到主存</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//但是读线程在执行循环 - 循环体中出现了同步代码块 - 遇到synchronized</span></span><br><span class="line">  <span class="comment">//一旦遇到synchronized - 尝试去获取锁资源 - 会清空本地工作内存[把x清空掉了]</span></span><br><span class="line">  <span class="comment">//继续循环又会使用到x,由于本地工作内存已经清空了呀,所以读线程只能到主存中去强制再去拷贝一份x的变量到本地工作内存</span></span><br><span class="line">  <span class="comment">//拿到的肯定是写线程已经更新之后的那个值x=5</span></span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println();<span class="comment">//增加的代码 - read线程跳出了循环 - 发现了新的x,重新拷贝最新的x</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----stopped---&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>原因</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println()这个println方法的内部底层是 - 同步代码块 - <span class="function"><span class="keyword">synchronized</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">    trouble = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="如何保证可见性-解决方案"><a href="#如何保证可见性-解决方案" class="headerlink" title="如何保证可见性 - 解决方案"></a>如何保证可见性 - 解决方案</h2><blockquote><ol><li><p>使用synchronized来保证可见性</p></li><li><p>使用<strong>volatile来修饰实例变量</strong></p><p>作用1:强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去.</p><p>作用2:禁止指令重排的 - 单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">指令重排 - JVM指令优化之后</span><br><span class="line">①给对象分配空间</span><br><span class="line">②空间地址立即给s,s保存到栈</span><br><span class="line">③对象的初始化</span><br><span class="line">                 </span><br><span class="line"><span class="keyword">volatile</span> Student s = <span class="keyword">new</span> Student();<span class="comment">//禁止指令重排</span></span><br><span class="line">①给对象分配空间</span><br><span class="line">③对象的初始化</span><br><span class="line">②空间地址立即给s,s保存到栈</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h1><blockquote><ol><li><p>保证可见性</p></li><li><p>volatile是不会造成阻塞的</p></li><li><p>禁止指令重排</p></li><li><p>不能保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//i对于俩个线程而言都是可见的.主存中一旦改变了.另外一个线程肯定就能够&quot;看到&quot; - 自己会强制再去重新拷贝 //一份到本地缓存中</span></span><br><span class="line">               </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  add();</span><br><span class="line">&#125;</span><br><span class="line">               </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">               </span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">               </span><br><span class="line"><span class="comment">//诱导 - </span></span><br><span class="line"><span class="comment">//强制让程序遵守&quot;缓存一致性&quot;协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去.</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//最终的i出来的结果&lt;200000 -&gt; 不能保证原子性</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//t1执行到最后一步,在自己的工作内存中已经计算结束了 ,i已经自增完毕,i=1&lt;---其他线程介入了----------&gt;但是还没有来得及刷回到主</span></span><br><span class="line">存.</span><br><span class="line">  t0线程直接计算完,i=<span class="number">1</span>,刷回到主存,结束</span><br><span class="line">                                        但是t1已经对i操作已经结束了,t1的内部已经不会再去操作i</span><br><span class="line">  只剩下最后一个动作-&gt;i=<span class="number">1</span>也会刷回到主存中</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h1><blockquote><ol><li><p>volatile只能作用于变量，而synchronized可以作用于变量、方法和代码块</p></li><li><p>多线程访问volatile不会发生阻塞，而synchronized关键字可能发生阻塞。</p></li><li><p><strong>volatile能够保证数据的可见性</strong>，就是在多个线程之间是可见的，<strong>不能保证原子性</strong>，而synchronized关键字都可以保证。</p></li><li><p>volatile关键字主要解决的是多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性。</p></li><li><p>volatile是可以禁止jvm指令重排的,但是synchronized是不能的.</p></li></ol></blockquote><h1 id="synchronized的底层原理"><a href="#synchronized的底层原理" class="headerlink" title="synchronized的底层原理"></a>synchronized的底层原理</h1><blockquote><p>了解即可</p></blockquote><blockquote><p><strong>每一个锁都对应一个monitor对象</strong>，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。</p></blockquote><p><img src="/2021/07/29/day15/monitor.png"> </p><h1 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h1><blockquote><p>线程是存在于进程内部的.一个进程内部可以拥有多个线程的.</p></blockquote><blockquote><ol><li><p>地址空间：同一进程的线程共享本进程的地址空间，而<strong>进程之间则是独立的地址空间。</strong></p><p><strong>进程与进程之间是独立的.</strong> <strong>同一个进程内部的多个线程是可以共享进程资源的.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如:没有国[进程]就没有家[线程]</span><br><span class="line">  </span><br><span class="line">   家[进程] - 拥有多个家庭成员的[线程]</span><br></pre></td></tr></table></figure></li><li><p>资源拥有：同一进程内的<strong>线程共享本进程的资源</strong>，但是<strong>进程之间的资源是独立的。</strong></p></li><li><p>一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>。<strong>所以多进程要比多线程健壮。</strong></p></li><li><p><strong>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时</strong>，<strong>使用线程要好于进程</strong>。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</p><p>-<em><strong>进程重量级的单位</strong>(创建,切换,销毁 - 费时)</em></p><p>*-**线程轻量级的单位(*<em>创建,切换,销毁 - 比较高)</em></p></li><li><p><strong>线程是处理器调度的基本单位，但是进程不是。</strong></p><p><strong>程序在执行过程中分配和管理资源的基本单位</strong> - 系统是把资源[内存]分给给进程,这个进程内部的线程才会去共享进程得到的这些资源.</p></li><li><p><strong>两者均可并发执行。</strong>   </p></li></ol><p><strong>一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程</strong>资源分配给进程，同一进程中所有线程共享该进程的所有资源。</p></blockquote><h1 id="线程状态-线程生命周期"><a href="#线程状态-线程生命周期" class="headerlink" title="线程状态 - 线程生命周期"></a>线程状态 - 线程生命周期</h1><p><img src="/2021/07/29/day15/thread_status.png"> </p><blockquote><p><strong>简介:线程的生命周期.</strong></p><ol><li><p>New：<strong>新建状态</strong>/<strong>瞬态</strong>，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread()</p></li><li><p>Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，<strong>只是说明此线程已经做好了准备，随时等待cpu调度执行</strong>，并不是说执行了t.start()此线程立即就会执行</p></li><li><p>Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</p></li><li><p>Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态</p></li><li><p>Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期</p></li></ol></blockquote><blockquote><p>（1）就绪状态是进入到运行状态的唯一入口<br>（2）线程想要进入到运行状态执行，首先必须处于就绪状态中<br>（3）根据阻塞产生的原因，阻塞状态又可以分为三种：<br>    【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态<br>    【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态<br>    【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入.</p></blockquote><h1 id="作业-synchronized"><a href="#作业-synchronized" class="headerlink" title="作业-synchronized"></a>作业-synchronized</h1><blockquote><p>Account(id,accno,balance=100) - “临界资源” - “多个线程需要竞争的共享 - 多个线程需要操作的同一个对象”</p><p>写一个线程类 - 同步方法[取钱-10] - 一定是只能在某个时刻只能由一个线程进去执行</p></blockquote><blockquote><p>创建俩个线程对象 - 老公和老婆 -&gt; 调用同步取钱的方法</p><ol><li><p>无论哪个线程在执行 - 100 - 90 - 80 - …. 0</p></li><li><p>效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">老公正在取钱....余额为:<span class="number">90</span></span><br><span class="line">老公正在取钱....余额为:<span class="number">80</span></span><br><span class="line">老公正在取钱....余额为:<span class="number">70</span></span><br><span class="line">老婆正在取钱....余额为:<span class="number">60</span></span><br><span class="line">老公正在取钱....余额为:<span class="number">50</span></span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">   <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><blockquote><p>GC - 运行在后台的 - 负责回收垃圾对象的.</p><p>核心:线程结束的时候不需要关心后台的守护线程是否也运行结束.线程是不会等后台的守护线程全部运行结束才结束.</p><p>当后台只有守护线程在执行的时候,就可以认为线程可以结束了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 后台的守护线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 9:03 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将打印数字的线程 - 设置成后台守护线程</span></span><br><span class="line">        <span class="comment">//如果后台只剩下守护线程在执行 - 可以结束了.</span></span><br><span class="line">        <span class="comment">//不需要等待所有的守护线程运行结束才结束.</span></span><br><span class="line">        t2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果t1和t2都不是守护线程 - main线程一定是等待俩个线程全部执行完之后,才会结束</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">65</span>; i &lt;=<span class="number">90</span> ; i++) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Lock-同步代码"><a href="#Lock-同步代码" class="headerlink" title="Lock - 同步代码"></a>Lock - 同步代码</h1><p>简介:它是一个接口,下面有很多实现类,<em><strong>笔试题lock和synchronized的区别!</strong></em></p><ul><li>lock是接口,synchronized它是一个关键字</li><li><strong>lock锁是一个显示</strong>锁(手动申请锁,手动释放锁),synchronized隐式锁(自动申请/释放锁)</li><li>lock手动申请锁**(对象锁)**</li><li><strong>lock是锁代码块</strong></li><li>lock出现异常的时候,是不会主动释放资源的.</li></ul><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: Lock同步代码 - 同步代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             申请的是对象锁 - 相同的对象才会去竞争一把锁.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             如果出现了异常 - 是不会主动释放锁的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 1:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockHelloDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建lock对象 - 接口</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//begin..</span></span><br><span class="line">            <span class="comment">//多个线程就会去竞争&quot;锁资源&quot;</span></span><br><span class="line">            lock.lock();<span class="comment">//手动申请&quot;锁资源&quot; - 显示锁</span></span><br><span class="line">            <span class="comment">//在某个时刻只能由一个线程进入去执行...</span></span><br><span class="line">            <span class="comment">//同步代码开始</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//sleep如果出现同步代码中,它并不会释放锁资源,只会让出cpu时间片段</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line">            <span class="comment">//end...</span></span><br><span class="line">            <span class="comment">//同步代码结束</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//手动释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockHelloDemo hello = <span class="keyword">new</span> LockHelloDemo();</span><br><span class="line">        <span class="comment">//1. 创建第一个线程对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            hello.add();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            hello.add();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面试题-synchronized和Lock有什么区别？"><a href="#面试题-synchronized和Lock有什么区别？" class="headerlink" title="面试题-synchronized和Lock有什么区别？"></a>面试题-synchronized和Lock有什么区别？</h1><blockquote><p>synchronized和lock都是属于独占锁.</p></blockquote><blockquote><ul><li><p>实现层面不一样。synchronized 是 Java 关键字，JVM层面 实现加锁和释放锁；Lock 是一个接口，在代码层面实现加锁和释放锁</p></li><li><p>是否自动释放锁。synchronized 在线程代码执行完或出现异常时自动释放锁；Lock 不会自动释放锁，需要再 finally {} 代码块显式地中释放锁</p></li><li><p>是否一直等待。<strong>synchronized 会导致线程拿不到锁一直等待</strong>；<strong>Lock 可以设置尝试获取锁或者获取锁失败一定时间超时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock接口中提供的方法</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;<span class="comment">//手动上锁</span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;<span class="comment">//如果获取锁失败 - 直接返回false,如果获取锁成功,返回true</span></span><br><span class="line"> <span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>;<span class="comment">//如果在尝试获取锁的过程中等待超过了time,那么就会导致获取锁失败</span></span><br></pre></td></tr></table></figure></li><li><p>获取锁成功是否可知。synchronized 无法得知是否获取锁成功；Lock 可以通过 tryLock 获得加锁是否成功</p></li><li><p>功能复杂性。synchronized 加锁可重入、不可中断、非公平；Lock 可重入、可中断、可公平和不公平、细分读写锁<strong>提高效率</strong></p><blockquote><p>读锁 - java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock - 共享锁 - 允许多个线程去读.</p><p>写锁 - java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock - 互斥锁 - 一次只能由一个线程去写.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不可中断<span class="keyword">synchronized</span>  - A线程竞争到锁资源 - 顺利进入同步代码块执行 - 只要A资源不释放这个锁资源.B线程只能在外面等待.</span><br><span class="line">      </span><br><span class="line">可中断Lock -&gt; A线程顺利执行同步代码,B线程如果tryLock方法话,那么B线程不断尝试获取锁资源.如果设置了超时等待时间.B线程等太久.已经超过了设置的时间.B线程将不会再傻乎乎继续等待下去[可中断],B线程就有可能去干别的事情了.</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>乐观锁,<strong>悲观锁[synchronized]</strong> - 数据库的时候</p><p>互斥锁 - synchronized和lock</p><p>读写锁</p><p><strong>锁升级</strong> </p><p><strong>锁粗化</strong></p><p>偏向锁</p><p>分布式锁</p></blockquote><h2 id="线程的通信-重点"><a href="#线程的通信-重点" class="headerlink" title="线程的通信 - 重点"></a>线程的通信 - 重点</h2><blockquote><p>同程公司笔试题 - 循环打印abc <strong>ABC</strong> 123 abc  ABC 123</p><p>打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程</p><ol><li><p>保证必须按照上面的顺序进行输出 - synchronized - wait和notify/notifyAll不能解决原因是<code>notify随机唤醒,notifyAll唤醒所有</code></p></li><li><p>使用Lock中的同步队列 - 解决方案 - <strong>唤醒指定的等待队列上的某个线程.</strong></p><p>Lock接口中提供的构建等待队列的方法 -  Condition newCondition();</p><p>Contion提供的关于线程通信的俩个方法 - 出现在同步代码内部 - lock()-&gt;unlock()内部</p><blockquote><ol><li>void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的</li><li>void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒</li></ol></blockquote></li><li><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.lock;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 同程公司笔试题 - 循环打印abc ABC 123 abc  ABC 123</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用Lock中的同步队列 - 解决方案 - **唤醒指定的等待队列上的某个线程.**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 2:29 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTongxinDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//有几个线程,就构建几个队列</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//打印小写字母的</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="comment">//打印大写字母的</span></span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="comment">//打印数字的</span></span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//定义了一个标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//count = 0,打印小写字母的执行</span></span><br><span class="line">    <span class="comment">//count = 1,打印大写字母的执行</span></span><br><span class="line">    <span class="comment">//count = 2,打印数字的执行</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//1. void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的</span></span><br><span class="line">    <span class="comment">//2. void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLower</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    <span class="comment">//一开始,第一次count=0,说明打印小写字母的线程正常执行</span></span><br><span class="line">                    c1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">                c2.signal();<span class="comment">//唤醒打印大写字母的线程</span></span><br><span class="line">      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        c2.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count=<span class="number">2</span>;</span><br><span class="line">                c3.signal();</span><br><span class="line">      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">2</span>)&#123;</span><br><span class="line">                    c3.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="number">123</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                c1.signal();</span><br><span class="line">      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTongxinDemo demo = <span class="keyword">new</span> LockTongxinDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printLower();</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printUpper();</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printNum();</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="面试题-常用方法区别"><a href="#面试题-常用方法区别" class="headerlink" title="面试题 - 常用方法区别"></a>面试题 - 常用方法区别</h1><blockquote><p><strong>wait方法和sleep方法的区别?</strong></p><p>a. wait方法一定是出现在synchronized同步代码内部的.[sleep是可以放在同步/不同步的代码内部的]</p><p>b. <strong>wait方法,执行这个方法的线程就会释放锁,释放cpu.但是sleep是不会释放锁的.只是释放了cpu</strong> - 核心的区别</p><p>c. sleep - 线程会自动进入到阻塞状态[其他阻塞状态],一旦睡眠时间结束.会自动从阻塞状态恢复到可就绪态 - 等到cpu到来 - 运行态.</p><p>​    wait - 线程会自动进入到等待阻塞状态,自己不会主动”醒过来”,必须是其他线程调用notify或者notifyAll,进入到锁定状态[再次尝试                去获取锁]</p></blockquote><blockquote><ol><li>sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</li></ol></blockquote><blockquote><ol start="2"><li>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</li></ol></blockquote><blockquote><ol start="3"><li>wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</li></ol></blockquote><blockquote><ol start="4"><li><p>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line">         </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> * join：一种特殊的wait[等待]，当前运行线程[mother]调用另一个线程[son]的join方法，</span></span><br><span class="line"><span class="comment"> * 当前线程[mother]进入阻塞状态直到另一个线程[son]运行结束等待该线程终止。</span></span><br><span class="line"><span class="comment"> * 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 9:21 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mother = <span class="keyword">new</span> Mother();</span><br><span class="line">        mother.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈正在做饭...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈发现酱油了...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈让熊孩子打酱油...&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//应该是希望儿子的线程介入进来了吧...</span></span><br><span class="line">        Thread son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.start();<span class="comment">//启动儿子线程</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//希望妈妈的线程先暂停一下,然后等儿子的线程跑完,妈妈的线程才继续跑.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            son.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//期望的是这条语句一定是出现在最后的...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈可以继续做饭了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;熊孩子接到任务...屁颠颠打酱油去了...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;熊孩子还有&quot;</span>+i+<span class="string">&quot;分钟就回来了...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;熊孩子把酱油打回来了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h1><blockquote><p><strong>wait</strong>：<strong>Object类的方法(notify()、notifyAll())，</strong>必须放<strong>在循环体</strong>和<strong>同步代码块中</strong>，执行该<strong>方法的线程会释放锁</strong>，</p><p>进入<strong>线程等待池中</strong>等待被再次唤醒(<strong>notify随机唤醒，notifyAll全部唤醒</strong>，线程结束自动唤醒)即放入锁池中竞争同步锁</p></blockquote><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><blockquote><p>单个生产者和单个消费者 </p><p>生产者线程 - 负责生产产品-box[把产品放入到box]</p><p>消费者线程 - 负责消费产品-box[从box中去获取产品]</p><p>通信的流程</p><ol><li><p>俩条线程并发执行 - 调用的是不同的方法</p></li><li><p>假设消费者线程先执行 - 直接从box中去获取产品.但是此时此刻box中尚无产品.</p><p>消费者线程就需要调用<strong>wait方法 - 自己会释放锁资源</strong>,消费者线程进入到线程等待池[意味着当前的线程会进入到等待阻塞的状态]</p><p>-getter方法</p></li><li><p>假设生产者线程 - setter方法</p><p>先执行了.发现box中没有产品的,顺利放入一个产品到box中的.但是放完之后.生产者还是会继续执行.继续执行的时候又会调用</p><p>setter方法.这个时候,不能允许生产者线程连续再放 - 就得调用<strong>生产者线程的wait方法</strong>,同时还需要唤醒消费者线程过来消费.</p></li><li><p>消费者线程一旦消费成功,它还是会继续执行自己的getter方法.发现box中没有了.回到第2个步骤</p></li></ol></blockquote><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 线程之间的通信 - 生产者和消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 效果是:必须是生产者线程先进去执行.</span></span><br><span class="line"><span class="comment"> *       放1个</span></span><br><span class="line"><span class="comment"> *       取1个</span></span><br><span class="line"><span class="comment"> *       放2个</span></span><br><span class="line"><span class="comment"> *       取2个</span></span><br><span class="line"><span class="comment"> *       放3个</span></span><br><span class="line"><span class="comment"> *       取3个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       一次性放,一次性取.</span></span><br><span class="line"><span class="comment"> *       不能连续出现俩次放/取.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/11 9:55 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTongXinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//典型的不共享代码,但是共享资源.</span></span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        Thread product = <span class="keyword">new</span> ProductThread(box);</span><br><span class="line">        Thread customer = <span class="keyword">new</span> CustomerThread(box);</span><br><span class="line"></span><br><span class="line">        product.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        customer.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        product.start();</span><br><span class="line"></span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个临界资源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> content;<span class="comment">//产品</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设的是是要调用getter方法 - 消费了 - box中没有东西了.</span></span><br><span class="line">    <span class="comment">//如果box中有东西 - 刚生产完,flag为true</span></span><br><span class="line">    <span class="comment">//如果box中没有东西 - 刚消费完 - flag为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;<span class="comment">//标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者线程去调用的</span></span><br><span class="line">    <span class="comment">//线程通信的方法wait,notify,notifyAll方法必须存在于循环体的同步方法中.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//box中是有东西的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//一旦调用wait方法之后,线程会释放锁.并且会自动进入到线程等待池中</span></span><br><span class="line">            <span class="comment">//进入到一个阻塞的状态.</span></span><br><span class="line">            <span class="comment">//它自己是不会主动被唤醒的.必须由其他线程调用notify或者notifyAll才能够</span></span><br><span class="line">            <span class="comment">//notify - 随机唤醒线程等待池中的一个线程</span></span><br><span class="line">            <span class="comment">//notifyAll - 唤醒所有的等待的线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();<span class="comment">//为了防止生产者线程连续执行..</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者顺利去执行.</span></span><br><span class="line">        <span class="comment">//设置flag</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知一下消费者来消费.消费者很有可能已经处于等待阻塞的状态.</span></span><br><span class="line">        notifyAll();<span class="comment">//唤醒全部等待阻塞的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程去调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//1. 保证消费者第一次执行,肯定会进来</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();<span class="comment">//释放锁,自己是不会主动&quot;醒过来的&quot;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;<span class="comment">//消费完了...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒一下生产者</span></span><br><span class="line">        notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义生产者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//产品</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductThread</span><span class="params">(Box box)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不断去生产</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;放&quot;</span>+(++i)+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">            box.setContent(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个消费者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerThread</span><span class="params">(Box box)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;取&quot;</span>+box.getContent()+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁-笔试题"><a href="#死锁-笔试题" class="headerlink" title="死锁 - 笔试题"></a>死锁 - 笔试题</h1><p><em><strong>“哲学家吃饭的问题”</strong></em></p><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程.</p><h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p><strong>1</strong>）<strong>互斥条件：</strong>指进程对所分配到的资源进行排它性使用，<strong>即在一段时间内某资源只由一个进程占用</strong>。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p><p><strong>2</strong>）<strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又<strong>提出了新的资源请求</strong>，而<strong>该资源已被其它进程占有</strong>，此<strong>时请求进程阻塞</strong>，但又对<strong>自己已获得的其它资源保持不放</strong>。</p><p><strong>3</strong>）<strong>不剥夺条件：</strong>指进程已获得的资源，<strong>在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</strong></p><p><strong>4</strong>）<strong>环路等待条件：</strong>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p><p><em><strong>只要打破四个条件的一个,就可以防止死锁.</strong></em></p><p><em><strong>死锁是不可避免,但是需要写程序的破坏四个条件中的一个.</strong></em></p><p><em><strong>静态域容易产生死锁.</strong></em></p><h1 id="四种常见的线程池-必考"><a href="#四种常见的线程池-必考" class="headerlink" title="四种常见的线程池 - 必考"></a>四种常见的线程池 - 必考</h1><p>线程池的返回值ExecutorService简介</p><p>ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：<strong>控制线程数量</strong>和<strong>重用线程</strong></p><ul><li>Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</li><li>Executors.newFixedThreadPool(int n)：创建一个<strong>可重用</strong>固定个数的线程池，以共享的无界队列方式来运行这些线程。</li><li>Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</li><li>Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><ol><li><p>Lock和Condition - 生产者和消费者的demo</p></li><li><p>编写俩个线程,一个线程用来计算2<del>100000之间的素数的个数.第二个线程用来计算1000000</del>200000之间的素数的个数</p><p>将俩个线程计算的结果相加.</p></li></ol></blockquote><h1 id="面试题-请你谈谈java-util-concurrent下的api的认识"><a href="#面试题-请你谈谈java-util-concurrent下的api的认识" class="headerlink" title="面试题 - 请你谈谈java.util.concurrent下的api的认识!"></a>面试题 - 请你谈谈java.util.concurrent下的api的认识!</h1><blockquote><p>主题 - 围绕线程池去问题了.</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day14</title>
    <link href="http://example.com/2021/07/28/day14/"/>
    <id>http://example.com/2021/07/28/day14/</id>
    <published>2021-07-28T10:02:10.000Z</published>
    <updated>2022-01-07T09:03:22.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型Generic"><a href="#泛型Generic" class="headerlink" title="泛型Generic"></a>泛型Generic</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ol><li>Java在1.5之后加入了泛型的概念。泛型，即“<strong>参数化类型</strong>”。</li><li>泛型的本质是为了参数化类型(<em><strong>将类型参数化传递</strong></em>)（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，<strong>操作的数据类型被指定为一个参数</strong>，</li><li>这种参数类型可以用在类、接口和方法中，分别被称为<strong>泛型类、泛型接口、泛型方法</strong>。</li><li>泛型只能是对象类型,比如User,Student,内置对象类型比如String,Integer[一定是包装类型]</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk5.0之前</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();<span class="comment">//集合中可以添加任意类型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk5.0开始~jdk7.0之前</span></span><br><span class="line"><span class="comment">//类型安全的集合框架</span></span><br><span class="line">List&lt;Integer&gt; list - <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//在编译期间确定了集合中添加的数据的类型,只能是Integer类型.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk7.0开始</span></span><br><span class="line"><span class="comment">//结论:泛型只有编译期间的概念,在运行期间将会被擦除.</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="泛型符号"><a href="#泛型符号" class="headerlink" title="泛型符号"></a>泛型符号</h2><blockquote><ol><li>E 元素</li><li>K,V - 键值对</li><li>N - 数字</li><li>T - 类型</li><li><strong>? - 通配符</strong></li></ol></blockquote><h2 id="为何要有泛型呢"><a href="#为何要有泛型呢" class="headerlink" title="为何要有泛型呢"></a>为何要有泛型呢</h2><blockquote><p>对别一下没有泛型,会导致什么结果.</p><blockquote><ol><li>加入了泛型之后,可以保证代码的<strong>健壮性</strong></li><li>加入了泛型之后,取值的时候,不需要进行强制类型的转换</li><li>加入了泛型之后,代码会变得更加简洁</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型的好处</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 9:05 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//jdk5.0之前</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();<span class="comment">//集合中可以添加任意类型的数据</span></span><br><span class="line">        list.add(<span class="number">10</span>);<span class="comment">//10-&gt;java.lang.Integer</span></span><br><span class="line">        list.add(<span class="string">&quot;ok&quot;</span>);<span class="comment">//字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有泛型的时候,获取集合中的元素 - 统计的返回类型都是Object类型</span></span><br><span class="line">        <span class="comment">//需要进行强制类型的转换.转换的过程中有可能会抛出java.lang.ClassCastException类型转换失败异常</span></span><br><span class="line">        <span class="comment">//在类型转换之前,建议先进行类型的判断,使用instanceof关键字</span></span><br><span class="line">        String ok = (String) list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdk7.0开始</span></span><br><span class="line">        <span class="comment">//一旦指定了泛型,add方法中的E成了String类型,返回类型也是String类型</span></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strList.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据下标获取 - 不需要进行类型的强制转换了.自动能够识别出返回类型就是你指定的那个泛型.</span></span><br><span class="line">        String result = strList.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="泛型只有编译期间的概念-在运行期间将会被擦除"><a href="#泛型只有编译期间的概念-在运行期间将会被擦除" class="headerlink" title="泛型只有编译期间的概念,在运行期间将会被擦除."></a>泛型只有编译期间的概念,在运行期间将会被擦除.</h2><blockquote><p>结论:泛型是没有多态的</p></blockquote><blockquote><ol><li><p>泛型只有编译期间的概念 - 泛型仅仅是在编译期间是有效的</p><p>在编译期间一旦确定了泛型,那么在编译期间就只能向这个容器中添加对应类型的数据.</p><p>否则编译报错.</p></li><li><p>运行期间将会被擦除 - 泛型是不存在运行时类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> tech.aistar.day05.User;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型只有编译期间的概念,在运行期间将会被擦除.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 9:16 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericRuntimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多态的语法 - 多态的应用</span></span><br><span class="line">        <span class="comment">//面向父类编程/面向接口编程</span></span><br><span class="line">        <span class="comment">//编译时类型 对象名 = new 运行时类型();</span></span><br><span class="line">        <span class="comment">//父类      对象   = new 子类();</span></span><br><span class="line">        <span class="comment">//接口      对象   = new 实现类();</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//java.lang.Integer extends java.lang.Number</span></span><br><span class="line">        <span class="comment">//java.lang.Long extends java.lang.Number</span></span><br><span class="line">        Number n1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        Number n2 = <span class="keyword">new</span> Long(<span class="number">20L</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//jdk5.0~jdk7.0之前</span></span><br><span class="line">        List&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//思考 - 编译是错误的</span></span><br><span class="line">        <span class="comment">//结论:泛型是没有多态的</span></span><br><span class="line">        <span class="comment">//原因:泛型只有编译期间的概念,在运行期间将会被擦除.</span></span><br><span class="line">        <span class="comment">//List&lt;Number&gt; numberList = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        List&lt;Long&gt; list02 = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//获取对象的运行时类型</span></span><br><span class="line">        <span class="comment">//忘记了 - java.lang.Object中的toString方法 getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode());</span></span><br><span class="line">        <span class="comment">//Class实例 - 别名:对象的运行时类型</span></span><br><span class="line">        Class&lt;?&gt; c1 = list01.getClass();</span><br><span class="line">        Class&lt;?&gt; c2 = list02.getClass();</span><br><span class="line">        System.out.println(c1 == c2);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//结论:获取运行时类型始终都是ArrayList,和&lt;Integer&gt;和&lt;Long&gt;是无关的</span></span><br><span class="line">        <span class="comment">//所以泛型仅仅是在编译期间有效,但是在运行期间是无效的[将会被擦除,将会失效]</span></span><br><span class="line">        System.out.println(c1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">        System.out.println(c2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//结论:一个类无论被实例化多少次,它在JVM中的Class对象/实例永远只有1个</span></span><br><span class="line"><span class="comment">//        User user1 = new User();</span></span><br><span class="line"><span class="comment">//        System.out.println(user1.getClass());//class tech.aistar.day05.User</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        User user2 = new User();</span></span><br><span class="line"><span class="comment">//        System.out.println(user2.getClass());//class tech.aistar.day05.User</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(user1.getClass() == user2.getClass());//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><blockquote><ol><li><p>**? extends T - 只能是T类型或者T类型的子类 **- 指定类型的上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 问号的通配符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 9:45 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildCardDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只能添加添加null</span></span><br><span class="line"><span class="comment">//        List&lt;?&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        //list.add(10);//error</span></span><br><span class="line"><span class="comment">//        //list.add(&quot;ok&quot;);//error</span></span><br><span class="line"><span class="comment">//        list.add(null);//ok</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        intList.add(<span class="number">10</span>);</span><br><span class="line">        intList.add(<span class="number">20</span>);</span><br><span class="line">        intList.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        longList.add(<span class="number">100L</span>);</span><br><span class="line">        longList.add(<span class="number">200L</span>);</span><br><span class="line">        longList.add(<span class="number">300L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//能否定义一个方法,能够打印上面俩个集合</span></span><br><span class="line">        printList(intList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printList(longList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型是不存在多态的.</span></span><br><span class="line">    <span class="comment">//假设认为是List&lt;Number&gt; list = new ArrayList&lt;Long&gt;();//error</span></span><br><span class="line">    <span class="comment">//Integer和Long都是extends Number</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//? extends T - 只能是T类型或者T类型的子类 - 指定类型的上限</span></span><br><span class="line">    <span class="comment">//? super T - 只能是T类型或者T类型的父类 - 指定类型的下限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;? extends Number&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//推荐使用集合的迭代器</span></span><br><span class="line">        <span class="comment">//获取集合的迭代器对象</span></span><br><span class="line">        Iterator&lt;? extends Number&gt; iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            <span class="comment">//Integer,Long -&gt; extends-&gt;Number-&gt;多态的语法</span></span><br><span class="line">            Number result = iter.next();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>? super T - 只能是T类型或者T类型的父类</strong> - 指定类型的下限</p></li></ol></blockquote><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><blockquote><p>定义类的时候,给定一个泛型,真正使用的时候,再确定具体的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 10:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> T type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClassDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将类型参数化传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClassDemo</span><span class="params">(T type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将类型参数化传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(T type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试泛型类</span></span><br><span class="line">        GenericClassDemo&lt;String&gt; c1 = <span class="keyword">new</span> GenericClassDemo&lt;&gt;(<span class="string">&quot;python&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.setType(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String result = c1.getType();</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===华丽丽的分割线===&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GenericClassDemo&lt;Integer&gt; c2 = <span class="keyword">new</span> GenericClassDemo&lt;&gt;();</span><br><span class="line">        c2.setType(<span class="number">10</span>);</span><br><span class="line">        System.out.println(c2.getType());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><blockquote><p>如果泛型加在类上面,对整个类内部的泛型的地方都会有影响</p><p><strong>可能某个类中就那么几个方法需要使用到泛型</strong>,没有必要定义泛型类,只需要<strong>定义泛型方法</strong>即可.</p><p><strong>如果若干个很多个方法都使用到了泛型,有必要定义一个泛型类.</strong></p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 10:17 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法 - 无返回类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01...&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法 - 带返回类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">test02</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;e:&quot;</span>+e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;N&gt; <span class="function">N <span class="title">test03</span><span class="params">(N n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;n:&quot;</span>+n);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethodDemo m = <span class="keyword">new</span> GenericMethodDemo();</span><br><span class="line">        <span class="comment">//如何确定到方法的参数T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM根据传入的方法的实参 - 拿到这个实参的类型 -&gt; 方法的参数T</span></span><br><span class="line">        m.test01(<span class="number">10</span>);<span class="comment">//Integer</span></span><br><span class="line"></span><br><span class="line">        m.test01(<span class="string">&quot;ok&quot;</span>);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用带有返回类型</span></span><br><span class="line">        String ok = m.test02(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        Integer t = m.test02(<span class="number">100</span>);</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">        <span class="comment">//泛型是类型安全的</span></span><br><span class="line">        Integer s = GenericMethodDemo.test03(<span class="number">12</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="泛型应用"><a href="#泛型应用" class="headerlink" title="泛型应用"></a>泛型应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream/ObjectOuputStream - 操作对象类型的字节文件输入流和对象类型的文件字节输出流</span><br><span class="line">  </span><br><span class="line">Object in.readObject()/out.writeObject(Object obj);</span><br><span class="line"></span><br><span class="line">Jdk没有对readObject方法进行优化,每次调用完之后,进行强制类型的转换操作的.</span><br><span class="line">  </span><br><span class="line">思考 - 无论是保存/读取User对象或者Book对象 - 用一个方法去实现</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day13.Book;</span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: IO流的工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/7 10:59 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法可以保存任意对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeList</span><span class="params">(List&lt;T&gt; list,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            out.writeObject(list);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法可以读取文件中的任意对象</span></span><br><span class="line">    <span class="comment">//语法如果定义成了一个泛型类,并且是静态方法的话,那么必须要把这个静态方法也设置成泛型方法</span></span><br><span class="line">    <span class="comment">//如果是定义成了一个泛型类,但是是普通方法的话,那么这个普通方法是不需要设置成泛型方法的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">readList</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            list = (List&lt;T&gt;) in.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUtilTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book b1 = <span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="number">100.0d</span>);</span><br><span class="line">        Book b2 = <span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">100.0d</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        books.add(b1);</span><br><span class="line">        books.add(b2);</span><br><span class="line">        String path = <span class="string">&quot;src/tech/aistar/util/content.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="comment">//IOUtil.writeList(books,path);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读</span></span><br><span class="line"><span class="comment">//        List&lt;Book&gt; list = IOUtil.readList(path);</span></span><br><span class="line"><span class="comment">//        if(null!=list &amp;&amp; list.size()&gt;0)&#123;</span></span><br><span class="line"><span class="comment">//            for (Book book : list) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(book);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Product p1 = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;macbook&quot;</span>);</span><br><span class="line">        Product p2 = <span class="keyword">new</span> Product(<span class="number">2</span>,<span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Product&gt; products = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        products.add(p1);</span><br><span class="line">        products.add(p2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//IOUtil.writeList(products,path);</span></span><br><span class="line"></span><br><span class="line">        List&lt;Product&gt; ps = IOUtil.readList(path);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=ps &amp;&amp; ps.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Product p : ps) &#123;</span><br><span class="line">                System.out.println(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型类的继承"><a href="#泛型类的继承" class="headerlink" title="泛型类的继承"></a>泛型类的继承</h1><blockquote><ol><li>子类不指定具体的类型</li><li>子类指定具体的类型</li></ol></blockquote><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 泛型类的继承</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:34 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericExtendsDemo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sup</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类继承父类的时候,没有指定具体的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Sup</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类继承父类的时候,指定了具体的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub01</span>&lt;<span class="title">Product</span>&gt; <span class="keyword">extends</span> <span class="title">Sup</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型的具体应用"><a href="#泛型的具体应用" class="headerlink" title="泛型的具体应用"></a>泛型的具体应用</h1><blockquote><p>了解一下即可</p><p>场景:在接口的制定中.很多接口具有相同的或者类似的功能.比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dao层接口 - data access object - 数据访问对象层 - 数据持久层</span></span><br><span class="line"><span class="comment">//这一层专门和数据库[crud增删改查操作][文件_IO流操作]打交道</span></span><br><span class="line"><span class="comment">//教师的业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">  <span class="comment">//保存教师</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Teacher teacher)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line">   <span class="comment">// 保存学生</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再去写俩个具体的实现类分别是TeacherDaoImpl.java以及StudentDaoImpl.java</span></span><br><span class="line"><span class="comment">//这俩个实现类中 - 具体的代码,现阶段知识点 - 把单个java对象保存到文件中[IO流技术].</span></span><br><span class="line"><span class="comment">//未来 - 肯定是要把java对象保存到db中 - 持久化的操作[java内存中的对象保存到DB中]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关于dao层 - java如何操作数据库 - 原生技术jdbc,dao层框架 - Hibernate框架以及mybatis框架</span></span><br><span class="line"><span class="comment">//比如现在选取的是所谓的Hibernate框架</span></span><br></pre></td></tr></table></figure><p><code>Hibernate框架来把java的内存对象保存到DB中</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">session.save(user);<span class="comment">//具体的调用的是这个框架中的保存方法</span></span><br><span class="line">session.getTransaction().commit();<span class="comment">//提交一个事务</span></span><br></pre></td></tr></table></figure></blockquote><p><code>TeacherDaoImpl.java</code>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoImpl</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Teacher teacher)</span></span>&#123;</span><br><span class="line">    session.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">    session.save(teacher);<span class="comment">//具体的调用的是这个框架中的保存方法</span></span><br><span class="line">    session.getTransaction().commit();<span class="comment">//提交一个事务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StudentDaoImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    session.beginTransaction();<span class="comment">//开启一个事务</span></span><br><span class="line">    session.save(student);<span class="comment">//具体的调用的是这个框架中的保存方法</span></span><br><span class="line">    session.getTransaction().commit();<span class="comment">//提交一个事务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>发现在未来使用框架的时候,会发现很多步骤都是重复的.可能就涉及到具体的对象那一行的代码才会不一样而已</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.save(具体的java对象);</span><br></pre></td></tr></table></figure><p><code>考虑抽象出一个顶级的业务接口出来-IBaseDao&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 顶级的业务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:50 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//顶级的业务接口中应该存储的就是各个子接口中共性的方法</span></span><br><span class="line">    <span class="comment">//这些方法都有共同点 - 大部分的代码是一样的,仅仅是操作的对象不一样而已.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>制定顶级的接口的实现类BaseDaoImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 顶级接口的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        session.beginTransaction();//开启一个事务</span></span><br><span class="line"><span class="comment">//        session.save(t);//具体的调用的是这个框架中的保存方法</span></span><br><span class="line"><span class="comment">//        session.getTransaction().commit();//提交一个事务</span></span><br><span class="line"></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IStudentDao.java继承了顶级的业务接口</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 具体的业务接口去继承这个顶级的业务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taoKe</span><span class="params">()</span></span>;<span class="comment">//子接口中特有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ITeacherDao.java</code>继承了顶级的业务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">Teacher</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buKe</span><span class="params">()</span></span>;<span class="comment">//子接口中特有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>俩个具体的实现类 - 需要继承顶级的BaseDaoImpl.java - save方法已经实现好了.同时还需要各自实现自己的接口</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 具体的学生接口的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:55 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//泛型继承 - 指定了泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">Student</span>&gt;  <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taoKe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;逃课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 9:02 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">Teacher</span>&gt; <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buKe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;补课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>单元测试</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.app.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Student;</span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.app.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 8:56 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        IStudentDao studentDao = <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">        studentDao.save(s);</span><br><span class="line"></span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="number">1</span>,<span class="string">&quot;仓考试&quot;</span>);</span><br><span class="line">        ITeacherDao teacherDao = <span class="keyword">new</span> TeacherDaoImpl();</span><br><span class="line">        teacherDao.save(teacher);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><blockquote><p>枚举常量 - 类型安全的常量 - 公共的静态的常量[final]属性 - 不可变的</p></blockquote><blockquote><p>jdk5.0开始提供的,以前的作用就是用<strong>来替代常量接口的</strong></p><p>回忆常量接口 - 管理和维护项目中所有的常量的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConsts</span></span>&#123;</span><br><span class="line">  <span class="comment">//最全的写法 - 接口中只能出现公开的静态的常量属性</span></span><br><span class="line">  <span class="comment">//public static final int Car = 1;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//精简的写法</span></span><br><span class="line">  <span class="comment">//public int CAR = 1;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最精简的写法</span></span><br><span class="line">  <span class="keyword">int</span> CAR = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><blockquote><p>使用enum关键字来定义一个枚举类型的</p><p>switch()中的参数类型可以是byte,short,int,char,<strong>enum</strong>,String,Byte,Short,Integer</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote><ol><li><p>枚举常量,多个枚举常量,使用,隔开.最后一个枚举常量不需要使用逗号了.</p><p>如果最后一个枚举常量下面还有代码的话,那么需要使用分号隔开</p></li><li><p>允许存在构造 - 访问修饰符不能是公开的,protected</p></li><li><p>枚举类型是不能够被实例化的</p></li><li><p>枚举类型中可以提供普通属性</p></li><li><p><strong>每个枚举类型默认都会自动继承java.lang.Enum&lt;E extends Enum<E>&gt;</E></strong></p></li><li><p>枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法</p></li><li><p>枚举类型不支持再去extends另外一个枚举类型</p></li><li><p>枚举类型不支持再去手动extends另外一个类</p></li></ol></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>如果某些属性具有固定的一些标识,就可以考虑定义成枚举类型.</p><p>比如:User实体类中维护了一个性别属性Gender[性别的枚举类型]</p><p>比如:Order实体类也会存在固定的状态 - 未付款,已付款.已下单未付款.取消订单等…</p></blockquote><h2 id="字符串-gt-枚举常量"><a href="#字符串-gt-枚举常量" class="headerlink" title="字符串-&gt;枚举常量"></a>字符串-&gt;枚举常量</h2><blockquote><p>比如一个注册页面</p><table><thead><tr><th>用户名</th><th>tom</th></tr></thead><tbody><tr><td>性别</td><td>单选按钮 男  单选按钮 女</td></tr><tr><td></td><td>确定按钮</td></tr></tbody></table><p>未来.当点击确定按钮,后台接受到M,F - 后台接受到的数据都是字符串数据.</p><p>我们是不能够直接将这个字符串数据设置到实体类中的枚举常量属性上的.</p><p>每个自定义的枚举类型Gender.java默认都会继承java.lang.Enum&lt;E extends Enum<E>&gt;</E></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                String name)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.enums;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: String-&gt;枚举类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 10:10 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String gender = <span class="string">&quot;F&quot;</span>;<span class="comment">//接受到页面传过来的数据 - 都是字符串类型</span></span><br><span class="line">        <span class="comment">//字符串类型是不能够直接设置给实体类的那个枚举常量属性上的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(FString.class);</span></span><br><span class="line">       <span class="comment">// System.out.println(Integer.class);</span></span><br><span class="line">        <span class="comment">//Class&lt;?&gt; c = String.class;</span></span><br><span class="line">        <span class="comment">//System.out.println(c);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串转换成枚举常量类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意 - 字符串的值一定是和枚举常量的名称是保持一致的.</span></span><br><span class="line">        <span class="comment">//否则 - java.lang.IllegalArgumentException:</span></span><br><span class="line">        <span class="comment">//      No enum constant tech.aistar.day14.enums.Gender.S</span></span><br><span class="line">        Gender g = Enum.valueOf(Gender.class,gender);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>,g);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><blockquote><p>它是effective java作者极力推荐的写法 - 枚举实例 - 1. 枚举类型天生就是线程安全的.2. 可以防止序列化或者反射来破坏这种单例的.</p><p>单例 - 保证在整个应用程序中,某个类的具体的实例永远只有1个.</p><p>什么时候需要把类做成单例的 - 这个类是一个重量级的类[类的创建和销毁的成本比较高.]</p></blockquote><h2 id="枚举常量是类型安全的常量"><a href="#枚举常量是类型安全的常量" class="headerlink" title="枚举常量是类型安全的常量???"></a>枚举常量是类型安全的常量???</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span></span>&#123;</span><br><span class="line">  F,M</span><br><span class="line">&#125;</span><br><span class="line">因为使用枚举常量 - 第一步肯定是先加载枚举类型Gender - JVM通过类加载器[java.lang.ClassLoader]来加载枚举类型</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//使用到了synchronized关键字</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//.... 加载类,接口,枚举类型到JVM内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">很多线程都在调用Gender.M - &gt; 都想尝试加载Gender枚举类型到JVM内存.但是由于loadClass加载的那块代码使用到了<span class="keyword">synchronized</span>[锁]</span><br><span class="line">只能由一个线程进去执行,并且只会执行一次.</span><br><span class="line">  </span><br><span class="line">由于每个枚举常量F 本质 就是 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Gender F = <span class="keyword">new</span> Gender();<span class="comment">//使用到了static关键字</span></span><br><span class="line"><span class="comment">//意味着当枚举类型一旦被加载了,枚举常量立即就会被分配空间以及初始化,并且机会只有一次.所以在整个内存中F常量也就只会存在一份.</span></span><br><span class="line"><span class="comment">//无论在哪里被调用.无论被多少给线程调用 - 大家拿到的都是同一个/同一份那个枚举常量.</span></span><br></pre></td></tr></table></figure><h3 id="具体的代码的实现"><a href="#具体的代码的实现" class="headerlink" title="具体的代码的实现"></a>具体的代码的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 枚举单例实现方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 10:45 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton04</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部的枚举类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">        <span class="comment">//枚举常量的实例</span></span><br><span class="line">        INSTANCE;<span class="comment">//public static final SingletonEnum INSTANCE = new SingletonEnum();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//final修饰的变量要赋值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton04 instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举类型提供一个空参构造 - 枚举类型是不能new的</span></span><br><span class="line">        SingletonEnum()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton04();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提供一个普通方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外部类肯定是要提供一个方法,返回自己的一个唯一实例的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingle04</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举单例写法"><a href="#枚举单例写法" class="headerlink" title="枚举单例写法"></a>枚举单例写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 枚举单例 - 最精简的写法 - 多线程安全的写法 - 饿汉模式</span></span><br><span class="line"><span class="comment">  只有最外层的是枚举类型 - 序列化这个枚举类型的单例,才能阻止序列化破坏单例的模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 11:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public static final Singleton05 INSTANCE = new Singleton05();</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton05()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比较繁琐的操作的事情,费时费力的事情&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>对比饿汉模式的写法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 初始化一个变量,该变量就是该类的唯一实例[对象]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有化构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较费时费力的代码,可能需要更多的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton01...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公开的静态的方法来返回这个类的唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举单例阻止序列化的破坏"><a href="#枚举单例阻止序列化的破坏" class="headerlink" title="枚举单例阻止序列化的破坏"></a>枚举单例阻止序列化的破坏</h3><blockquote><ol><li>序列化单例对象s1</li><li>反序列化封装到单例对象s3</li><li>s1 == s3 ;// 仍然为true</li></ol></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day14.enums.Gender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 枚举单例 - 最精简的写法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 11:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public static final Singleton05 INSTANCE = new Singleton05();</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton05()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比较繁琐的操作的事情,费时费力的事情&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton05</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton05 s1 = Singleton05.getInstance();</span><br><span class="line"></span><br><span class="line">        Singleton05 s2 = Singleton05.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/tech/aistar/design/ss.txt&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">//对单例进行序列化操作</span></span><br><span class="line">            out.writeObject(s1);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/tech/aistar/design/ss.txt&quot;</span>)))&#123;</span><br><span class="line"></span><br><span class="line">            Singleton05 s3 = (Singleton05) in.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1 == s3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="枚举细节-抽象方法"><a href="#枚举细节-抽象方法" class="headerlink" title="枚举细节 - 抽象方法"></a>枚举细节 - 抽象方法</h2><blockquote><p>枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day14.enums;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 季节的枚举类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/9 1:43 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.SUMMER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.AUTUMN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.WINTER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Season <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Season.SPRING;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sign;</span><br><span class="line"></span><br><span class="line">    Season()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Season(String sign) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sign = sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个抽象方法 - 但是要求所有的枚举常量都要重写这个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Season <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSeason</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season s = Season.SPRING;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;-&quot;</span>+s.getSign());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//让程序睡一秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            s = s.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day13</title>
    <link href="http://example.com/2021/07/27/day13/"/>
    <id>http://example.com/2021/07/27/day13/</id>
    <published>2021-07-27T10:02:10.000Z</published>
    <updated>2022-01-07T09:02:59.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><blockquote><p>java.io.File[C] - File包含文件或者文件夹[目录directory]</p><p>作用:它是用来操作File本身的<strong>元</strong>信息的[比如支持File的创建,删除,获取File的名称,获取File的路径等信息]</p><p>它并不支持文件里面的内容的读写操作[文件内中的内容的读写操作是交给IO流去实现]</p><p>支持本地File以及远程File的操作的.</p><p>File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射.</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><blockquote><p>File(String path);//利用一个路径来构建一个File实例.这个路径可以是文件的路径,也可以是文件夹的路径</p><p>路径分成相对路径和绝对路径.</p><p>绝对路径 - windows操作系统是以盘符号开头的路径,Linux/mac以/开头的路径</p><p>相对路径 - 不是以盘符或者/开头的路径</p></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>boolean createNewFile();//创建一个文件,该方法是要抓取异常的.</p></li><li><p>String getAbsolutePath();//获取该File的绝对路径</p></li><li><p>String getName();//获取File的名称</p></li><li><p>String getParent();//获取该File的父目录的绝对路径</p></li><li><p>boolean exists();//判断File是否存在</p></li><li><p>boolean delete();//删除文件或者文件夹</p><p>6-1. 文件是否可以直接被删除的</p><p>6-2. 如果是空目录 - 直接删除的</p><p>6-2. <strong>如果是非空目录 - 将会删除失败 - 递归算法来实现的.</strong></p></li><li><p>boolean mkdir();//创建单层次的目录,一次只能创建一个目录</p></li><li><p>boolean mkdirs();//既可以创建单层次的目录,又可以同时创建多个不存在的目录.</p></li><li><p>boolean isFile();//判断File实例是否为文件的实例</p></li><li><p>boolean isDirectory();//判断file实例是否为文件夹的实例</p></li><li><p>String[] list();//返回的是File的名称,返回的是传入的路径下的第一层的内容.</p></li><li><p><strong>File[] listFiles();//返回的第一层的File实例</strong></p></li><li><p>File[] listFiles(FilenameFilter filter);//找到指定后缀/前缀/满足条件的这么一个File实例</p></li></ol></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li><p>传入一个目录,输出这个目录下的所有的内容.</p><p>如果是文件 - 直接输出名称</p><p>如果是文件夹 - 输出绝对路径</p></li></ol></blockquote><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><blockquote><p>删除一个非空目录</p></blockquote><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><blockquote><p>流是一种抽象概念，它代表了数据的<strong>无结构化传递</strong>。<strong>按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]<strong>进行</strong>有序的</strong>输入输出，<strong>数据被当成无结构的字节序或字符序列</strong>。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output)</p></blockquote><p><img src="/2021/07/27/day13/io01.jpeg"> </p><p><code>流想象成是数据传输的那个管道</code></p><p><code>磁盘中数据加载/读入到内存中 - 输入</code></p><p><img src="/2021/07/27/day13/io02.png"> </p><p><code>java内存中数据写出去到磁盘中 - 输出</code></p><p><img src="/2021/07/27/day13/io03.png">  </p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><blockquote><ol><li><p>按照流的方向 - 输入流和输出流</p></li><li><p>按照流的读取的单位不同 - 字节流[按照单个字节单个字节进行读写,文本文件或者二进制文件]和字符流[单个字符进行读写,只能操作文本字符文件]</p></li><li><p>按照流的功能 - 节点流[基础流]和拓展流[过滤流或者包装流] - 采用了”装饰器设计模式思想”</p><p>**节点流才具备真正操作文件的能力.**拓展流只是让流的功能更加强大而已,拓展流脱离了节点流的话,那么是不允许的.</p><p>拓展流的使用必须要建立在节点流的基础之上.</p></li></ol></blockquote><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><blockquote><ol><li>java.io.InputStream[C] - 字节输入流的顶级的抽象的父类<ul><li>java.io.FileInputStream[C] - 文件字节输入流 - 操作文件的读操作. - <strong>典型的节点流</strong></li><li>java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - <strong>典型的包装流</strong></li><li>java.io.FilterInputStream[C] - 过滤流<ul><li>java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流</li><li>java.io.DataInputStream[C] - 操作基本数据类型的字节输入流</li></ul></li></ul></li></ol></blockquote><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><blockquote><p>java.io.OutputStream[C] - 字节输出流的顶级的抽象的父类</p><ul><li>java.io.<strong>FileOutputStream[C]</strong> - 文件字节输出流 - 操作文件的写操作. - <strong>典型的节点流</strong></li><li>java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - <strong>典型的包装流</strong></li><li>java.io.FilterOutputStream[C] - 过滤流<ul><li>java.io.<strong>BufferedOutputStream[C]</strong> - 带缓存功能的流 - 缓冲流</li><li>java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流</li></ul></li></ul></blockquote><h1 id="InputStream常用方法"><a href="#InputStream常用方法" class="headerlink" title="InputStream常用方法"></a>InputStream常用方法</h1><blockquote><ol><li>void close();//关闭流,流本身就是一个对象[占内存 - 昂贵的资源]</li><li>abstract  int read();//单个字节单个字节的读取,如果读不到,返回-1</li><li><strong>int read(byte[] b);//从输入流读取一些字节数，并将它们存储到缓冲区 b</strong> 。</li></ol></blockquote><h1 id="OutputStream常用方法"><a href="#OutputStream常用方法" class="headerlink" title="OutputStream常用方法"></a>OutputStream常用方法</h1><blockquote><ol><li>void close();//关闭</li><li>abstract void write(int b);将指定的字节写入此输出流。</li><li><strong>void write(byte[] b, int off, int len);</strong></li></ol></blockquote><h1 id="IO流的编程步骤"><a href="#IO流的编程步骤" class="headerlink" title="IO流的编程步骤"></a>IO流的编程步骤</h1><blockquote><ol><li>确定流 - 选什么流</li><li>确定源头和目标</li><li>循环读取,循环写出 - while</li><li>关闭流</li></ol></blockquote><h1 id="缓冲流BufferedInputStream"><a href="#缓冲流BufferedInputStream" class="headerlink" title="缓冲流BufferedInputStream"></a>缓冲流BufferedInputStream</h1><blockquote><p>在它出来之前,可以可以单个字节单个字节进行读写操作 - 弊端:java程序和磁盘的IO交互比较频繁,性能就会低下.</p><p>采取了自定义的数组的方式.从磁盘文件中读取一定数量的字节先放入到缓冲数组中.然后再从缓冲数组中一次性写出到磁盘中.</p><p>减少了java程序和磁盘的IO交互 - 性能提高.</p></blockquote><blockquote><p>JDK中发现了这点,提供了缓冲流BufferedInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;<span class="comment">//默认的容量8kb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];<span class="comment">//内置的缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(in);</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];<span class="comment">//初始化内置的缓冲区数组 - 大小是8kb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>底层利用了”装饰器”思想.这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力.</p><p>构建带缓冲功能的流,必须要以节点流作为支撑</p></blockquote><blockquote><p><code>构架一个带缓冲功能的能够读取文件的字节输入流</code></p><p>BufferedInputStream in = new BufferedInputStream(new FileInputStream(“路径”));</p><p>BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(“路径”));</p></blockquote><h2 id="缓冲数组"><a href="#缓冲数组" class="headerlink" title="缓冲数组"></a>缓冲数组</h2><blockquote><p>BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么?</p></blockquote><blockquote><p><strong>内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 缓冲流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/5 2:18 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//jvm加载磁盘上的数据到内置的byte[]中</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/tech/aistar/day13/fast.gif&quot;</span>));</span><br><span class="line">            out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/tech/aistar/day13/fast_副本.gif&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自定义一个byte[]</span></span><br><span class="line">            <span class="comment">//真正的读</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                len = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span>(len==-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                out.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读过程"><a href="#读过程" class="headerlink" title="读过程"></a>读过程</h2><blockquote><ol><li>当初始化好缓冲流之后,jvm会立即读取磁盘中的数据到内置的缓冲数组中</li><li>当程序中循环读取到的时候 len = in.read(buf); = 程序是直接从内置的缓冲区[内置的缓冲数组中]</li><li>一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区.</li></ol></blockquote><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><blockquote><p>jdk7.0提供的写法</p><p>作用 - 把流的关闭交给JVM</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象的声明<span class="number">1</span>;资源对象的声明<span class="number">2</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(..)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 语法糖 - JVM去关闭流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/5 2:39 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAutoCloseDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自动关闭这些资源</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/tech/aistar/day13/fast.gif&quot;</span>));</span><br><span class="line">            BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/tech/aistar/day13/fasts.gif&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">//自定义一个byte[]</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                len = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span>(len==-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                out.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ObjectInputStream-ObjectOutputStream"><a href="#ObjectInputStream-ObjectOutputStream" class="headerlink" title="ObjectInputStream/ObjectOutputStream"></a>ObjectInputStream/ObjectOutputStream</h1><blockquote><p>操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑</p><p><code>构建一个能够读写对象类型的文件字节输入流/输出流</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;path&quot;</span>))</span><br></pre></td></tr></table></figure></blockquote><p><code>构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;path&quot;</span>)));</span><br></pre></td></tr></table></figure><p>利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响.</p><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><blockquote><p>也叫做 - 数据的持久化的过程. - 把内存中的java对象存储到磁盘的文件的过程.</p><p>注意点:</p><ol><li><p>如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口</p><p>如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常</p></li><li><p>保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口</p></li></ol><p>关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取.</p></blockquote><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有的属性比较敏感,比如员工的工资</span></span><br><span class="line"><span class="comment">//如果不希望持久化某个属性值 - 不希望这个属性的数据被写到磁盘中</span></span><br><span class="line"><span class="comment">//瞬态关键字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">double</span> price;</span><br></pre></td></tr></table></figure><h2 id="对象的反序列化"><a href="#对象的反序列化" class="headerlink" title="对象的反序列化"></a>对象的反序列化</h2><blockquote><p>java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上].</p></blockquote><h1 id="CURD操作①"><a href="#CURD操作①" class="headerlink" title="CURD操作①"></a>CURD操作①</h1><blockquote><p>实体类 - 接口 - 实现类 - 单元测试</p></blockquote><blockquote><p>操作文件中的数据</p><ul><li>tech.aistar.day13.prj<ul><li>entity - Phone.java[id,name,price]</li><li>dao - data access object [IPhoneDao.java]数据对象访问 - 数据持久层 - 和文件进行打交道的一层 - 接口<ul><li>impl - 接口的实现类PhoneDaoImpl.java</li></ul></li><li>test - 单元测试</li></ul></li></ul></blockquote><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><blockquote><p>文件夹的拷贝②</p></blockquote><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><blockquote><p>它和字节流的区别是读取的单位是不同的 .字节流是按照单个字节进行读写操作.</p><p>字符流是按照单个字符的单位进行读写操作.字符流专门用来处理的文本字符文件的.字节流是用来处理文本文件或者二进制文件的.</p></blockquote><h2 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h2><blockquote><p>java.io.Reader[C] - 顶级的字符输入流 - 抽象类</p><ul><li><p>BufferedReader[C] - 带缓冲功能的字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(in, defaultCharBufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提供的方法</span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span></span>;<span class="comment">//每次读取文本文件的一整行的数据,如果读取不到[到达文件的末尾了],返回false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的.</strong></p></li></ul></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符输入流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 1:40 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderHelloDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 确定流</span></span><br><span class="line">        <span class="comment">//2. 确定源头</span></span><br><span class="line">        <span class="comment">//3. 循环读取</span></span><br><span class="line">        <span class="comment">//4. 关闭流 - 可以采取语法糖 - JVM去自行关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//demo - 用来读取文本文件,然后将内容输出到控制台上去</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;src/tech/aistar/day13/Book.java&quot;</span>)))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一行一行进行读取</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环读取</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                line = in.readLine();<span class="comment">//读取一整行的数据,若读取不到,则返回false</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//循环退出的条件</span></span><br><span class="line">                <span class="keyword">if</span>(line == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h2><blockquote><p>java.io.Writer[C] - 顶级的字符输出流 - 抽象类</p><ul><li><p>PrintWriter[C] - 自带缓存功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter(Writer out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数是是否自动刷新缓存</span></span><br><span class="line"><span class="comment">//缓存里面的数据什么时候会被同步到磁盘上</span></span><br><span class="line"><span class="comment">//1. 缓存中的数据满的时候 - 会自动刷新</span></span><br><span class="line"><span class="comment">//2. 缓存中的数据还不足以撑满这个缓存 - close或者flush - 强制刷新缓存</span></span><br><span class="line">PrintWriter(Writer out, <span class="keyword">boolean</span> autoFlush);</span><br></pre></td></tr></table></figure></li><li><p><strong>FileWriter[C] -字符流中的节点流 - 具备真正的字符文件的读写操作的.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法:</span><br><span class="line"><span class="number">1.</span> FileWriter(String path);<span class="comment">//写到哪里去,目标的绝对/相对路径</span></span><br><span class="line"><span class="number">2.</span> FileWriter(String path,<span class="keyword">boolean</span> append);<span class="comment">//第二个参数代表的是是否追加写入.如果append设置成true.支持分批次的写</span></span><br><span class="line">   和分批次的读 - 都是字符串</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符输出流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 1:57 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterHelloDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建一个自动刷新,但是能够实现追加写入的功能.</span></span><br><span class="line">        <span class="comment">//第一个true - 代表的是是否追加写入 - true</span></span><br><span class="line">        <span class="comment">//第二个true - 是否自动刷新缓存,设置成true之后,那么就不需要在程序代码中手动刷新,不需要再去写out.flush();</span></span><br><span class="line">        <span class="comment">//            推荐 - 1. 构建一个自动刷新的输出流 2. 程序代码的之后还是推荐手动刷新out.flush()3. 依然需要关闭流 - jvm</span></span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out =</span><br><span class="line">                    <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;src/tech/aistar/day13/writer.txt&quot;</span>,<span class="keyword">true</span>),<span class="keyword">true</span>))&#123;</span><br><span class="line">            <span class="comment">//因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存.</span></span><br><span class="line">            <span class="comment">//有可能有部分学生的计算机,它没有达到强制刷新缓存的效果</span></span><br><span class="line">            <span class="comment">//场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//print方法以及println方法</span></span><br><span class="line">            <span class="comment">//print方法写入之后,后面是没有加一个\n</span></span><br><span class="line">            <span class="comment">//println方法写入之后,后面是有一个\n</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把内存中的数据持久化到磁盘中的文件中.</span></span><br><span class="line">            <span class="comment">//out.print(&quot;web前端很好玩!&quot;);</span></span><br><span class="line"></span><br><span class="line">            out.println(<span class="string">&quot;c不好玩!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//推荐在结束的时候,手动刷新一下缓存</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建一个不自动刷新,但是能够实现追加写入的功能.</span></span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;src/tech/aistar/day13/writer.txt&quot;</span>,<span class="keyword">true</span>)))&#123;</span><br><span class="line">            <span class="comment">//因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存.</span></span><br><span class="line">            <span class="comment">//有可能有部分学生的计算机,它没有达到强制刷新缓存的效果</span></span><br><span class="line">            <span class="comment">//场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//print方法以及println方法</span></span><br><span class="line">            <span class="comment">//print方法写入之后,后面是没有加一个\n</span></span><br><span class="line">            <span class="comment">//println方法写入之后,后面是有一个\n</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把内存中的数据持久化到磁盘中的文件中.</span></span><br><span class="line">            <span class="comment">//out.print(&quot;web前端很好玩!&quot;);</span></span><br><span class="line"></span><br><span class="line">            out.println(<span class="string">&quot;c不好玩!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//推荐在结束的时候,手动刷新一下缓存</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建的是一个不自动刷新,不追加写入的字符输出流</span></span><br><span class="line">        <span class="comment">//每次都会覆盖原来的文件,并且在第一次写入的时候,会自动创建这个文件的.</span></span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;src/tech/aistar/day13/writer.txt&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">//因为语法糖 - close()操作 - 底层就是关闭流之前,会强制刷新缓存.</span></span><br><span class="line">            <span class="comment">//有可能有部分学生的计算机,它没有达到强制刷新缓存的效果</span></span><br><span class="line">            <span class="comment">//场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//print方法以及println方法</span></span><br><span class="line">            <span class="comment">//print方法写入之后,后面是没有加一个\n</span></span><br><span class="line">            <span class="comment">//println方法写入之后,后面是有一个\n</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把内存中的数据持久化到磁盘中的文件中.</span></span><br><span class="line">            out.print(<span class="string">&quot;python很好玩!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//推荐在结束的时候,手动刷新一下缓存</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符流来实现文件的拷贝操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 2:37 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopyReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        copyFile(<span class="string">&quot;src/tech/aistar/day13/FileDemo.java&quot;</span>,<span class="string">&quot;src/tech/aistar/day13/FileDemo_副本.java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 原文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标文件的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src,String target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 构建流 - 源头和目标的确定</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(target),<span class="keyword">true</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 定义一个变量 - 用来保存每次读取到的一行数据</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 循环读取</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                line = in.readLine();<span class="comment">//读取一整行,读不到,则返回null</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//循环退出的条件</span></span><br><span class="line">                <span class="keyword">if</span>(line == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写一行出去</span></span><br><span class="line">                out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结笔试"><a href="#总结笔试" class="headerlink" title="总结笔试"></a>总结笔试</h1><blockquote><ol><li>常见的字节流和字符流</li><li>装饰器的设计模式</li><li>难一点的知识点 - <strong>同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别</strong></li><li>BufferedInputStream - 内置的缓冲数组 - 8kb</li></ol></blockquote><h1 id="补充-破坏单例"><a href="#补充-破坏单例" class="headerlink" title="补充 - 破坏单例"></a>补充 - 破坏单例</h1><blockquote><p><strong>单例设计模式 - 保证在整个应用程序中,某个类的具体的实例永远只有1个 - 多线程下也是一个 - 双重锁检测</strong></p><p>对象的序列化和反序列化可以破坏这种单例,如何破坏?</p><p><strong>解决方案: 单例的第四个版本 - 枚举类型来实现单例模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.design.singleton.version03.Singleton03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 对象的序列化和反序列化可以破坏单例的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/6 3:06 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton03 s1 = Singleton03.getInstance();</span><br><span class="line"></span><br><span class="line">        String path = <span class="string">&quot;src/tech/aistar/day13/singleton.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把这个对象写入到文件中</span></span><br><span class="line">        writeObject(s1,path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读</span></span><br><span class="line">        Singleton03 s2 = readObject(path);<span class="comment">//反序列化之后,并没有走构造,直接操作的内存</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象的序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Singleton03 s,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写</span></span><br><span class="line">            out.writeObject(s);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象的反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">readObject</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        Singleton03 s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path)))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读</span></span><br><span class="line">            s = (Singleton03) in.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day12</title>
    <link href="http://example.com/2021/07/26/day12/"/>
    <id>http://example.com/2021/07/26/day12/</id>
    <published>2021-07-26T10:02:10.000Z</published>
    <updated>2022-01-07T09:02:41.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h1><blockquote><ol><li>java.text.SimpleDateFormat - 日期格式处理类</li><li>线程不安全的类.</li></ol></blockquote><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><blockquote><ol><li><p>Date类型转换成String类型 - 按照指定的日期格式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pattern必须是一个有效的格式化模板,如果传入了一个非法模板</span></span><br><span class="line"><span class="comment">//那么就会抛出一个java.lang.IllegalArgumentException - 非法参数异常</span></span><br><span class="line"><span class="comment">// Illegal pattern character &#x27;q&#x27;</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(Date date)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>String类型转换成Date类型.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果构造中的pattern的格式和日期的字符串的格式不一致,那么在调用</span></span><br><span class="line"><span class="comment">//parse方法的时候就会抛出java.text.ParseException: Unparseable date: &quot;2020-09-03&quot;</span></span><br><span class="line"><span class="comment">//解析失败异常</span></span><br><span class="line"><span class="function">Date <span class="title">parse</span><span class="params">(String str)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="模板pattern"><a href="#模板pattern" class="headerlink" title="模板pattern"></a>模板pattern</h2><table><thead><tr><th>Letter</th><th>Date or Time Component</th><th>Presentation</th><th>Examples</th></tr></thead><tbody><tr><td><code>G</code></td><td>Era designator</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#text">Text</a></td><td><code>AD</code></td></tr><tr><td><code>y</code></td><td>Year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#year">Year</a></td><td><code>1996</code>; <code>96</code></td></tr><tr><td><code>Y</code></td><td>Week year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#year">Year</a></td><td><code>2009</code>; <code>09</code></td></tr><tr><td><code>M</code></td><td>Month in year (context sensitive)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#month">Month</a></td><td><code>July</code>; <code>Jul</code>; <code>07</code></td></tr><tr><td><code>L</code></td><td>Month in year (standalone form)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#month">Month</a></td><td><code>July</code>; <code>Jul</code>; <code>07</code></td></tr><tr><td><code>w</code></td><td>Week in year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>27</code></td></tr><tr><td><code>W</code></td><td>Week in month</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>2</code></td></tr><tr><td><code>D</code></td><td>Day in year</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>189</code></td></tr><tr><td><code>d</code></td><td>Day in month</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>10</code></td></tr><tr><td><code>F</code></td><td>Day of week in month</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>2</code></td></tr><tr><td><code>E</code></td><td>Day name in week</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#text">Text</a></td><td><code>Tuesday</code>; <code>Tue</code></td></tr><tr><td><code>u</code></td><td>Day number of week (1 = Monday, …, 7 = Sunday)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>1</code></td></tr><tr><td><code>a</code></td><td>Am/pm marker</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#text">Text</a></td><td><code>PM</code></td></tr><tr><td><code>H</code></td><td>Hour in day (0-23)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>0</code></td></tr><tr><td><code>k</code></td><td>Hour in day (1-24)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>24</code></td></tr><tr><td><code>K</code></td><td>Hour in am/pm (0-11)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>0</code></td></tr><tr><td><code>h</code></td><td>Hour in am/pm (1-12)</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>12</code></td></tr><tr><td><code>m</code></td><td>Minute in hour</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>30</code></td></tr><tr><td><code>s</code></td><td>Second in minute</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>55</code></td></tr><tr><td><code>S</code></td><td>Millisecond</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#number">Number</a></td><td><code>978</code></td></tr><tr><td><code>z</code></td><td>Time zone</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#timezone">General time zone</a></td><td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td></tr><tr><td><code>Z</code></td><td>Time zone</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#rfc822timezone">RFC 822 time zone</a></td><td><code>-0800</code></td></tr><tr><td><code>X</code></td><td>Time zone</td><td><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html#iso8601timezone">ISO 8601 time zone</a></td><td><code>-08</code>; <code>-0800</code>; <code>-08:00</code></td></tr></tbody></table><h2 id="日期工具类"><a href="#日期工具类" class="headerlink" title="日期工具类"></a>日期工具类</h2><blockquote><p>java.util.Date</p></blockquote><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><blockquote><p>api: java.math</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><blockquote><p><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/math/BigDecimal.html#BigDecimal-double-">BigDecimal</a></strong>(double val)</p><p>BigDecimal(String val);//处理小数精度的问题</p></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>BigDecimal add(BigDecimal augend)<br>返回 BigDecimal ，其值是 (this + augend) ，其标为 max(this.scale(), augend.scale()) 。</p></li><li><p>BigDecimal divide(BigDecimal divisor)</p><p>除法</p></li><li><p>BigDecimal multiply(BigDecimal multiplicand)</p><p>乘法</p></li><li><p>BigDecimal    subtract(BigDecimal subtrahend)</p><p>减法</p></li></ol></blockquote><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><blockquote><p>在java开发中如何处理小数精度丢失的问题</p><p>需要使用到的是<strong>BigDecimal(String val);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 处理小数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/4 9:27 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalHandlerFloatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">        BigDecimal d2 = <span class="keyword">new</span> BigDecimal(String.valueOf(<span class="number">0.2</span>));</span><br><span class="line"></span><br><span class="line">        BigDecimal result = d1.add(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BigDecimal-&gt;double/String</span></span><br><span class="line">        <span class="keyword">double</span> resultDouble = result.doubleValue();</span><br><span class="line">        System.out.println(resultDouble);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><blockquote><p>笔试题 - 递归算法求阶乘</p><p><strong>构造:BigInteger(String val);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> BigInteger.ONE;</span><br><span class="line">        BigInteger current = <span class="keyword">new</span> BigInteger(String.valueOf(n));</span><br><span class="line">        <span class="keyword">return</span> current.multiply(test(n-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h1 id="四种内部类"><a href="#四种内部类" class="headerlink" title="四种内部类"></a>四种内部类</h1><blockquote><p>看懂别人写的内部类语法即可</p></blockquote><blockquote><ol><li><p>成员内部类 - 把内部类看成是外部类的一个成员</p><p>a. 成员内部类不能再去定义静态成员</p><p>b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 对象名 = 外部类对象.new 内部类();</span><br></pre></td></tr></table></figure></li><li><p>静态内部类- 把内部类看成是外部类的一个静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 对象名 = <span class="keyword">new</span> 外部类.内部类();</span><br></pre></td></tr></table></figure><p>a. 内部是可以定义静态和非静态属性的</p><p>b. 内部的普通方法中是不允许访问外部类的非静态属性的.</p><p>c. 内部的普通方法中是允许访问外部类的静态属性的</p></li><li><p>局部内部类 - 内部类是出现在外部类的方法中.</p><p>a. 内部类是不允许使用访问修饰符,比如不能使用public</p><p>b. 不能定义静态属性的</p><p>c. 访问到外部类的静态和非静态成员的</p><p>d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new)</p></li><li><p>匿名内部类 - 必须掌握的</p><blockquote><p>好处 - 我们可以在程序中少写实现类</p><p>jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的.</p></blockquote></li></ol></blockquote><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><blockquote><p>IO流使用到了”装饰器”设计模式思想</p><p>装饰器模式（Decorator Pattern）<strong>允许向一个现有的对象添加新的功能，同时又不改变其结构</strong>。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p></blockquote><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><blockquote><p><em>Unified Modeling Language</em>- 统一建模语言</p></blockquote><blockquote><p>BA - 需求分析师</p><ol><li>powerndesigner </li><li>starUML</li></ol><p>掌握目标: 看懂箭头即可</p><p> 类与类之间由弱到强关系是:   <em><strong>*没关系 &gt;** **依赖 &gt; 关联 &gt; 聚合 &gt; 组合。*</strong></em></p></blockquote><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><blockquote><p>虚线+箭头&lt;——</p><p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//自己的功能</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//B类中的功能</span></span><br><span class="line">    b.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><blockquote><p>箭头 实线+箭头&lt;-</p></blockquote><blockquote><p>A类关联了B类 - A依赖于B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><blockquote><p>属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密.整体是可以决定局部的生命周期的.</p><p>箭头 - 实线+实心菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.uml.combination;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密.</span></span><br><span class="line"><span class="comment"> *            整体是可以决定局部的生命周期的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/4 10:34 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baby</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Eye eye;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Hand hand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eye = <span class="keyword">new</span> Eye();</span><br><span class="line">        <span class="keyword">this</span>.hand = <span class="keyword">new</span> Hand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baby b = <span class="keyword">new</span> Baby();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h2><blockquote><p>属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的</p><p>箭头 - 实线+空心菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Cpu cpu)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><blockquote><p>java.lang.Throwable - 异常和错误的顶级的类</p><p>两个分支:</p><ol><li><p>java.lang.Error - 错误 - 错误一旦发生,程序员是么有办法进行扭转的 - 不需要在代码中进行处理.</p><p>1-1. 子类<strong>VirtualMachineError</strong>虚拟机级别的错误</p><p>​         1-1-1. 子类java.lang.<strong>StackOverflowError</strong> 堆栈溢出 -  应用程序因为递归太深没有指定出口的时候.</p><p>​         1-1-2. 子类java.lang.<strong>OutOfMemoryError</strong> 内存泄漏 - [GC垃圾回收机制 - 后台自动回收垃圾对象]</p></li><li><p><strong>java.lang.Exception - 异常</strong> - 程序在运行的过程中发生了不正常的情况.</p></li></ol></blockquote><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><blockquote><p>运行时异常[RuntimeException]都是非运行时异常的子类[Exception]</p></blockquote><blockquote><ol><li><p>运行时异常 - 未检测异常</p><p><code>顶级的父类java.lang.RuntimeException</code></p><blockquote><ol><li><p>java.lang.NullPointerException - 空指针异常</p></li><li><p>java.util.InputMismatchException - 输入不匹配异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = sc.nextInt();<span class="comment">//只能获取整数.但是输入了一个字符串&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>java.lang.ArithmeticException - 分母为0</p></li><li><p>java.lang.IllegalArgumentException - 非法参数异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">构造中的模板如果传入了一个非法模板</span><br></pre></td></tr></table></figure></li><li><p>java.lang.IndexOutOfBoundsException - 下标越界异常 - 比如list.get(100);</p><p>5-1. java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常</p><p>5-2. java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常</p></li><li><p>java.util.NoSuchElementException - 不存在此元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">System.out.println(list.getFirst());<span class="comment">//获取栈顶元素,但是栈顶没有元素</span></span><br></pre></td></tr></table></figure></li><li><p>java.lang.ClassCastException - 类型转换失败异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型转换成子类类型之前,推荐先使用<span class="keyword">instanceof</span>关键字进行类型的判断</span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p>非运行时异常 - 已检测异常</p><blockquote><ol><li><p>java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配</p></li><li><p>InterruptedException - 中断异常 - Thread.sleep(1000);</p></li><li><p>java.lang.CloneNotSupportedException - 不允许被clone.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当调用对象的clone方法,但是这个对象没有去实现java.lang.Cloneable接口</span><br></pre></td></tr></table></figure></li><li><p>java.io.IOExcetion - IO流异常</p><p>4-1. java.io.EOFException - 已经读取到文件的末尾了.</p><p>4-2. java.io.FileNotFoundException - 文件找不到异常</p></li><li><p>java.sql.SQLException - SQL异常,比如程序中的sql语句要是写错了.</p></li></ol></blockquote></li></ol></blockquote><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><blockquote><ol><li><p>运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断.稍微谨慎一点.</p></li><li><p><strong>非运行时异常 - 编译期间就需要立即对其进行处理.处理的方式有俩种.一种是积极处理 - try..catch的方式</strong></p><p><strong>另外一种是消极处理.</strong></p></li></ol></blockquote><h3 id="积极处理方式"><a href="#积极处理方式" class="headerlink" title="积极处理方式"></a>积极处理方式</h3><blockquote><ol><li><p>语法一 - try….catch….catch….finally </p><p>推荐使用到的 - 因为针对每种不同的异常进行单独的日志记录,单独的异常处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//code..</span></span><br><span class="line">  <span class="comment">//code..</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e1)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e2)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//无论是否出现异常,都会执行</span></span><br><span class="line">&#125;</span><br><span class="line">注意:上方的异常类型不能是下方的异常类型的父类.</span><br></pre></td></tr></table></figure></li><li><p>语法二 - jdk7.0提供的新的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> | 异常类型<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>语法三 - 简单粗暴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常总父类)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="消极处理"><a href="#消极处理" class="headerlink" title="消极处理"></a>消极处理</h3><blockquote><p>比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了.</p><p>为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理.</p><p>原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃.</p></blockquote><blockquote><ol><li><p>直接在方法的签名[声明]上使用<strong>throws关键字+异常类型</strong>1,异常类型2</p></li><li><p>在方法体中使用<strong>throw+异常对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//System.out.println(&quot;异常的描述....&quot;);</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//throw + 运行时异常对象,不需要在方法的签名上抛出异常 - 本身运行时异常就不需要处理呀!</span></span><br><span class="line">    <span class="comment">//throw new RuntimeException(&quot;发生异常了...&quot;);</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//throw + 非运行时异常 配合 必须要在方法的签名上throws+非运行时异常类型</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;n:&quot;</span>+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>笔试题 - throws和throw有什么区别</p></blockquote><h1 id="笔试题1"><a href="#笔试题1" class="headerlink" title="笔试题1"></a>笔试题1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">  <span class="comment">//code..</span></span><br><span class="line">  <span class="keyword">return</span>;<span class="comment">//结束整个方法</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//无论是否出现异常,都会执行</span></span><br><span class="line">&#125;</span><br><span class="line">假设<span class="keyword">try</span>&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.</span><br><span class="line"><span class="number">1.</span> <span class="keyword">finally</span>中的代码执行否? - 肯定会执行</span><br><span class="line"><span class="number">2.</span> <span class="keyword">return</span>语句是在<span class="keyword">finally</span>块之前执行还是之后执行? - 之后</span><br></pre></td></tr></table></figure><h1 id="笔试题2"><a href="#笔试题2" class="headerlink" title="笔试题2"></a>笔试题2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day12.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 笔试题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/4 3:23 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(change());<span class="comment">//A&#123;age=200&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally中修改了基本数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//①</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//try可以直接和finally一起使用....</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//此处将i自增后的结果缓存起来了.并且这个缓存的结果就是作为最终返回出去的一个结果 - 对待基本数据类型.</span></span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ++i;<span class="comment">//③</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally修改了对象类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.age = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//return是在finally之后执行</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//对待对象类型 - finally中的修改对象的属性值,是对return的结果是产生了影响的.</span></span><br><span class="line">            a.age = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;A&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="笔试题3"><a href="#笔试题3" class="headerlink" title="笔试题3"></a>笔试题3</h1><blockquote><p>final和finally和finalize三者之间的区别? - 一点关系都没有</p><blockquote><ol><li><p>final </p><p>a. 修饰的局部变量一旦赋值成功,不可改变</p><p>b. 修饰的属性一旦赋值成功,不可改变</p><p>c. 修饰的类不可被继承</p><p>d. 修饰的方法不可被重写</p></li></ol></blockquote><blockquote><ol start="2"><li><p>finally</p><p>a. 一般是和try..catch搭配使用的.try块中无论是否出现异常,finally块中代码都会执行</p><p>b. finally块中一般写的是释放或者关闭资源的代码</p></li></ol></blockquote><blockquote><ol start="3"><li><p>finalize - Object类中提供的方法</p><p>a. 当GC想去回收一个垃圾对象之前,会去调用这个对象的finalize方法.是由JVM去调用.</p><p>b. 该方法未必一定会被调用得到.</p></li></ol></blockquote></blockquote><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><blockquote><p>项目中其实是专门包exception - 专门自定义自己的异常[大量的]</p><p>jdk内置的异常不够用,不符合实际的业务场景.</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><ol><li>写一个异常类继承java.lang.Exception</li><li>提供父类的5个构造方法即可</li></ol></blockquote><h2 id="思考为什么要自定义异常"><a href="#思考为什么要自定义异常" class="headerlink" title="思考为什么要自定义异常"></a>思考为什么要自定义异常</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;余额小于0&quot;</span>);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BalanceLtZeroException(<span class="string">&quot;余额小于0!&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - <strong>显示比如服务器正在维护/升级…</strong></p><p>我们应该提供一个<code>异常处理器</code> - 会监控软件程序在整个项目运行的过程中发生的一切异常.</p><p>一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面.</p><p>SpringMVC/SpringBoot - <code>异常处理器</code> - 只认识异常.</p></blockquote><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><blockquote><ol><li>重点围绕OO - 面向对象</li><li>三大特性 - 封装,继承,多态</li><li>抽象类和接口区别</li><li>四种访问修饰符的作用权限</li><li>方法的重载和方法的重写</li><li>单例 - 双重检测锁</li><li>简单工厂</li><li>static关键字的作用 - static练习</li></ol></blockquote><h1 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h1><ol start="0"><li><p>泛型</p></li><li><p><strong>IO流 - 大头</strong></p></li><li><p><strong>并发编程 - 多线程 - 大头中的大头 - 最难的最难的最难的</strong></p></li><li><p>反射技术 - 看懂框架的源码[反射技术 + 设计模式]</p></li><li><p>动态代理 - [jdk动态代理 + cglib动态代理]</p></li><li><p>枚举类型</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day11</title>
    <link href="http://example.com/2021/07/25/day11/"/>
    <id>http://example.com/2021/07/25/day11/</id>
    <published>2021-07-25T10:02:10.000Z</published>
    <updated>2022-01-07T09:02:20.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><p>就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用.</p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">api:java.util</span><br><span class="line">  </span><br><span class="line">Collection[I]</span><br><span class="line">  - List[I] - 有序可重复</span><br><span class="line">    - ArrayList[C] - 线程不安全</span><br><span class="line">    - LinkedList[C]</span><br><span class="line">    - Vector[C] - 使用方式和ArrayList一样,但是线程安全的</span><br><span class="line">  - 方法都是采用<span class="keyword">synchronized</span></span><br><span class="line">  - Set[I] - 无序不可重复</span><br><span class="line">    - HashSet[C]</span><br><span class="line">    - SortedSet[I]</span><br><span class="line">      - TreeSet[C]</span><br><span class="line">Map[I]</span><br><span class="line">  - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复.</span><br><span class="line">  - Hashtable[C]</span><br><span class="line">    - Properteis[C] - 属性文件在内存中的映射的对象</span><br></pre></td></tr></table></figure><h2 id="Collection-I"><a href="#Collection-I" class="headerlink" title="Collection[I]"></a>Collection[I]</h2><blockquote><ol><li>boolean add(E e);//向容器中添加一个元素</li><li>void clear();//清空容器</li><li>boolean contains(Object o);//判断容器中是否包含某个对象</li><li>boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true</li><li>Iterator<E>    iterator();// 获取集合对象的迭代器</E></li><li>boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个</li><li>int size();//返回集合中的数据的个数 - 集合的大小</li></ol></blockquote><h2 id="List-I"><a href="#List-I" class="headerlink" title="List[I]"></a>List[I]</h2><blockquote><p>特点 - 有序并且是可以重复的.</p><ol><li>E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1]</li><li>int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</li><li>E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素</li><li>Object[] toArray();//将集合转换成数组.</li></ol></blockquote><h1 id="ArrayList-C"><a href="#ArrayList-C" class="headerlink" title="ArrayList[C]"></a>ArrayList[C]</h1><blockquote><p>特点:有序可重复的,<strong>底层数据结构就是一个”动态增长”的数组.</strong></p><p>优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高.</p><p>缺点:增删效率会低.因为涉及到下标的移动.</p></blockquote><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就是真正的存储数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1. 初始化elementData,长度为0</span></span><br><span class="line">  <span class="comment">//2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  <span class="comment">//this.elementData = &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剖析add方法"><a href="#剖析add方法" class="headerlink" title="剖析add方法"></a>剖析add方法</h2><blockquote><p>ArrayList扩容的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">elementData[size++] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;<span class="comment">//第一次进来1</span></span><br><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//第一次minCapacity = 10</span></span><br><span class="line"> minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续ensureExplicitCapacity(minCapacity);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">modCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="comment">//第一次进来10-0&gt;0</span></span><br><span class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line"> grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grow(minCapacity)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一次</span></span><br><span class="line"><span class="comment">//oldCapacity = 0</span></span><br><span class="line"><span class="comment">//newCapacity = 0</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//第一次会进来</span></span><br><span class="line">  newCapacity = minCapacity;<span class="comment">//newCapacity = 10</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">  newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组</span></span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h2><blockquote><ol><li><p>直接输出</p></li><li><p>增强for循环 - 只读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常</span><br><span class="line">            </span><br><span class="line">实际的底层,调用迭代器对象中的next方法</span><br><span class="line">            </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//modCount是当初调用add方法,添加1个元素,modCount自增1个</span></span><br><span class="line">   <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">发现只要调用了remove方法 - modCount++</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>普通for</p></li><li><p>迭代器</p><p>因为不同的集合的底层的数据结构是不一样的.数据结构不一样,它的遍历方式不一样</p><p>为了访问/遍历不同数据结构的集合提供一种统一的遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1. 获取集合的迭代器</span></span><br><span class="line">Iterator&lt;Long&gt; iter = list.iterator();</span><br><span class="line"><span class="comment">//2. 调用hasNext方法</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;<span class="comment">//判断迭代器中是否仍有下一个元素可被迭代</span></span><br><span class="line">  Long p = iter.next();<span class="comment">//获取当前迭代的</span></span><br><span class="line">  System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>jdk8提供的新的遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;<span class="comment">//匿名内部类</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">    System.out.println(aLong);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda表达式来替代匿名内部类的写法</span></span><br><span class="line"><span class="comment">//配合函数式接口[只能包含一个抽象方法]</span></span><br><span class="line">System.out.println(<span class="string">&quot;======lambda====&quot;</span>);</span><br><span class="line">list.forEach(e -&gt; System.out.println(e));</span><br><span class="line">            </span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="LinkedList-C"><a href="#LinkedList-C" class="headerlink" title="LinkedList[C]"></a>LinkedList[C]</h1><blockquote><p>有序的序列,<strong>底层的数据结构双向链表</strong>,jdk6以及之前是双向循环链表</p><p>链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动.</p><p>适合解决栈列和队列的业务题型 - 贪吃蛇</p><p>栈列 - 先进后出</p><p>队列 - 先进先出</p></blockquote><h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><blockquote><p>相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址.</p></blockquote><blockquote><ol><li><p>单向链表</p><p>head - 头节点</p><p>tail - 尾节点</p><p>element - 节点中真正的保存的数据</p><p>next - 下一个节点的地址</p><p><img src="/2021/07/25/day11/link01.png"> </p></li><li><p>单向循环链表</p><p>尾节点的next又指向了头节点.</p><p><img src="/2021/07/25/day11/link02.png"> </p></li><li><p>双向链表 - LinkedList底层数据结构</p><p>增加了一个pre - 保存的是上一个节点的地址.</p><p><img src="/2021/07/25/day11/link03.png"> </p></li><li><p>双向循环链表</p><p><img src="/2021/07/25/day11/link04.png"> </p></li></ol></blockquote><h2 id="剖析源码"><a href="#剖析源码" class="headerlink" title="剖析源码"></a>剖析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node代表的是链表的节点 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   E item;<span class="comment">//真正的元素</span></span><br><span class="line">   Node&lt;E&gt; next;<span class="comment">//下一个节点的地址</span></span><br><span class="line">   Node&lt;E&gt; prev;<span class="comment">//上一个节点的地址</span></span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">     <span class="keyword">this</span>.item = element;</span><br><span class="line">     <span class="keyword">this</span>.next = next;</span><br><span class="line">     <span class="keyword">this</span>.prev = prev;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表如何插入一个新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第一次进入last最后一个节点Node - null</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//l = null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二次进入 l = new Node&lt;&gt;(null,&quot;ok&quot;,null)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次进入</span></span><br><span class="line">  <span class="comment">//newNode = new Node&lt;&gt;(null,&quot;ok&quot;,null)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二次进入</span></span><br><span class="line">  <span class="comment">//newNode =  new Node&lt;&gt;(链表中原来的最后一个节点l, &quot;java&quot;, null);</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//新插入的节点肯定是作为最后一个节点 - 尾节点</span></span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//第一次进入,链表之前没有任何元素</span></span><br><span class="line">    first = newNode;<span class="comment">//新的节点作为头节点</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//原来链表中的最后一个节点的next同时也指向新的节点</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>查找源码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//index = 3</span></span><br><span class="line">  <span class="comment">// 假设集合中有10个元素 = size = 10</span></span><br><span class="line"><span class="comment">//index&lt;5 - 链表的坐标</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;<span class="comment">//确定头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">      x = x.next;</span><br><span class="line">      <span class="comment">//① - x第二个 ,i=0</span></span><br><span class="line">      <span class="comment">//i=1  x第三个</span></span><br><span class="line">      <span class="comment">//i=2  x第四个</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//index&gt;=5</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>删除源码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   <span class="comment">//找到index对应的Node对象,传入到了unlink方法中.</span></span><br><span class="line">   <span class="keyword">return</span> unlink(node(index));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//防止删除的是头节点</span></span><br><span class="line">    first = next;<span class="comment">//需要删除的那个节点的下一个节点作为头节点了.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//删除的是中间节点</span></span><br><span class="line">    prev.next = next;<span class="comment">//原来节点的上一个节点的next指向原来节点的下一个节点</span></span><br><span class="line">    x.prev = <span class="keyword">null</span>;<span class="comment">//优化,更快让GC会回收pre指针.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是尾结点</span></span><br><span class="line">    last = prev;<span class="comment">//原来节点的上一个节点作为尾节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//删除的是中间节点</span></span><br><span class="line">    next.prev = prev;<span class="comment">//原来节点的下一个节点指向原来节点的上一个节点</span></span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  size--;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习-括号匹配"><a href="#练习-括号匹配" class="headerlink" title="练习-括号匹配"></a>练习-括号匹配</h2><p><img src="/2021/07/25/day11/bc.png"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11.homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 括号匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/29 1:51 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BracketsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入括号:&gt;&quot;</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(matches(line))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 将字符串转成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = line.toCharArray();</span><br><span class="line">        <span class="comment">//2. 新建一个LinkedList集合</span></span><br><span class="line">        LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//3. 将数组中的第一个元素压入栈顶</span></span><br><span class="line">        list.push(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//4. 从arr数组的第二个位置开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//()[]&#123;&#125;</span></span><br><span class="line">            <span class="comment">//获取当前的arr[i]</span></span><br><span class="line">            Character c = arr[i];</span><br><span class="line">            <span class="comment">//为了避免在栈顶已经没有元素的情况下还去获取栈顶元素,非空判断</span></span><br><span class="line">            <span class="keyword">if</span>(list.isEmpty())&#123;</span><br><span class="line">                list.push(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5. 先获取栈顶元素</span></span><br><span class="line">            Character top = list.getFirst();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 栈顶元素和当前的arr[i]进行匹配</span></span><br><span class="line">            <span class="keyword">if</span>(top.equals(<span class="string">&#x27;(&#x27;</span>)&amp;&amp;c.equals(<span class="string">&#x27;)&#x27;</span>) || top.equals(<span class="string">&#x27;&#123;&#x27;</span>)&amp;&amp;c.equals(<span class="string">&#x27;&#125;&#x27;</span>) || top.equals(<span class="string">&#x27;[&#x27;</span>)&amp;&amp;c.equals(<span class="string">&#x27;]&#x27;</span>))&#123;</span><br><span class="line">                <span class="comment">//弹出栈顶元素</span></span><br><span class="line">                list.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//继续将当前的arr[i]压入栈顶</span></span><br><span class="line">                list.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map-I"><a href="#Map-I" class="headerlink" title="Map[I]"></a>Map[I]</h1><h2 id="HashMap-C"><a href="#HashMap-C" class="headerlink" title="HashMap[C]"></a>HashMap[C]</h2><blockquote><p>数据存储的形式是key-value,针对key是无序不可重复的.</p><p>jdk8.x之前,底层的数据结构是桶数组+链表</p><p>jd8.0开始,底层的数据结构是<strong>桶数组+链表+红黑树</strong></p><p>桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的.</p></blockquote><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2021/07/25/day11/map.png"> </p><p><img src="/2021/07/25/day11/map2.png"> </p><h2 id="剖析put方法"><a href="#剖析put方法" class="headerlink" title="剖析put方法"></a>剖析put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash函数就是扰动函数</span></span><br><span class="line"><span class="comment">//1. 尽可能减少哈希冲突</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map数据结构图示中每个节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;<span class="comment">//单向链表</span></span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认值是null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hash(key)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第一次进来</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次进来,第二次肯定不走</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//第一次肯定会进来</span></span><br><span class="line">    <span class="comment">//1. 对tab进行一个初始化操作</span></span><br><span class="line">    <span class="comment">//2. 得到初始化数组的长度,赋值给了n</span></span><br><span class="line">    n = (tab = resize()).length;<span class="comment">//n=16</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次肯定判断结果为null</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//tab[i] = 新的节点</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//哈希碰撞了,哈希冲突了.</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="comment">//key值冲突了.</span></span><br><span class="line">      <span class="comment">//e = 数组中的旧的Node对象</span></span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">//hash虽然碰撞了,但是key是不一样</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//判断是否为红黑树结构</span></span><br><span class="line">      <span class="comment">//当链表的节点&gt;8个,链表结构转成红黑树结构</span></span><br><span class="line">      <span class="comment">//当红黑树节点&lt;6个,恢复成链表结构</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//链表结构</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//p代表的就是哈希碰撞位置的第一个Node对象</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//新的节点挂载到链表的末尾</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新的节点可能和链表结构中的某个节点的key也是一样的</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//e肯定是不为null</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="comment">//把旧的节点的value赋值给了oldValue,put方法的返回结果</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//新值覆盖旧值</span></span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>扩容方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">//第一进来就会执行到此处 , 16</span></span><br><span class="line">             <span class="comment">//扩容因子是0.75</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="comment">//初始化一个长度为16的数组</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/25/day11/put.png"> </p><h2 id="map集合的迭代方式"><a href="#map集合的迭代方式" class="headerlink" title="map集合的迭代方式"></a>map集合的迭代方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式 - 将map集合中所有的key全部取出来放入到一个Set集合中.</span></span><br><span class="line"><span class="comment">//set集合 - 无序不可重复,map集合的key也是无序不可重复.</span></span><br><span class="line">Set&lt;Integer&gt; sets = maps.keySet();</span><br><span class="line"><span class="comment">//遍历set集合</span></span><br><span class="line">Iterator&lt;Integer&gt; iter = sets.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">  Integer key = iter.next();</span><br><span class="line">  String value = maps.get(key);</span><br><span class="line">  System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式 - 将map集合中的每对key-value封装到了一个内置的Entry对象中</span></span><br><span class="line"><span class="comment">//然后将每个entry对象放入到Set集合中</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter2 = entries.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter2.hasNext())&#123;</span><br><span class="line">  Map.Entry&lt;Integer,String&gt; e = iter2.next();</span><br><span class="line">  Integer key = e.getKey();</span><br><span class="line">  String value = e.getValue();</span><br><span class="line">  System.out.println(key+<span class="string">&quot;-&gt;&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map作业"><a href="#Map作业" class="headerlink" title="Map作业"></a>Map作业</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,.....&#125;</span><br><span class="line"></span><br><span class="line">统计每个随机数出现的次数 - Map集合</span><br><span class="line">  </span><br><span class="line">String str = <span class="string">&quot;sfhdsfkdfdfjdfjdfdjfdsa&quot;</span>;</span><br><span class="line"></span><br><span class="line">String[] arr = [<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;php&quot;</span>,<span class="string">&quot;python&quot;</span>];</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;python java python java mysql java mysql php&quot;</span>;   spilt(<span class="string">&quot;\\s&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> 写一个程序统计每个品牌花费的总费用 - 统计类题型</span><br><span class="line"><span class="number">2.</span> 根据总费用降序排 - 可以暂时不做.          </span><br></pre></td></tr></table></figure><blockquote><p><a href="http://xzc.cn/sYtc8YkClM">http://xzc.cn/sYtc8YkClM</a> - 宝洁作业</p><p><a href="http://xzc.cn/p5acBgPAHf">http://xzc.cn/p5acBgPAHf</a> - <strong>基础弱的 - 1. 当天的代码2遍</strong></p><p>​                                                                    <strong>2. 解决了哪些问题? 列一下自己尚未解决的问题?</strong></p></blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="比较器接口Comparator"><a href="#比较器接口Comparator" class="headerlink" title="比较器接口Comparator"></a>比较器接口Comparator</h2><blockquote><p>jdk8.0开始,在List接口中已经定义了排序的方法</p><p>void sort(Comparator&lt;? super E&gt; c)</p><p>分析:java.util.Comparator<T>[I]函数式接口 - 允许使用lambda表达式 </T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tech.aistar.day10.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 集合排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/30 9:29 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSortDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book b1 = <span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">100.0d</span>);</span><br><span class="line">        Book b2 = <span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">200.0d</span>);</span><br><span class="line">        Book b3 = <span class="keyword">new</span> Book(<span class="number">3</span>,<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">200.0d</span>);</span><br><span class="line">        Book b4 = <span class="keyword">new</span> Book(<span class="number">4</span>,<span class="string">&quot;1004&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="number">300.0d</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bookList.add(b1);</span><br><span class="line">        bookList.add(b2);</span><br><span class="line">        bookList.add(b3);</span><br><span class="line">        bookList.add(b4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        bookList.sort(new Comparator&lt;Book&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Book o1, Book o2) &#123;</span></span><br><span class="line"><span class="comment">//                if(o1.getPrice()&gt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                    return -1;</span></span><br><span class="line"><span class="comment">//                else if(o1.getPrice()&lt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                    return 1;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据价格降序排</span></span><br><span class="line"><span class="comment">//        bookList.sort((o1,o2)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            if(o1.getPrice()&gt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                return -1;</span></span><br><span class="line"><span class="comment">//            else if(o1.getPrice()&lt;o2.getPrice())</span></span><br><span class="line"><span class="comment">//                return 1;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据编号降序排 - String类型</span></span><br><span class="line"><span class="comment">//        bookList.sort((o1, o2) -&gt; o2.getIsbn().compareTo(o1.getIsbn()));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据价格降序排,如果价格一样的话,按照编号继续降序排</span></span><br><span class="line">        bookList.sort((o1,o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.getPrice()&gt;o2.getPrice())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(o1.getPrice()&lt;o2.getPrice())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> o2.getIsbn().compareTo(o1.getIsbn());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="可比较接口"><a href="#可比较接口" class="headerlink" title="可比较接口"></a>可比较接口</h2><blockquote><p>排序的对象对应的实体类实现java.lang.Comparable<T>接口</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11.compares;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/30 10:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Teacher</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Teacher&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;id=&quot;</span>).append(id);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;, age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Teacher o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定制排序的规则</span></span><br><span class="line">        <span class="keyword">return</span> o.age - <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day11.compares;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/30 10:54 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTeacherSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher t1 = <span class="keyword">new</span> Teacher(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Teacher t2 = <span class="keyword">new</span> Teacher(<span class="number">2</span>,<span class="string">&quot;jack&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        Teacher t3 = <span class="keyword">new</span> Teacher(<span class="number">3</span>,<span class="string">&quot;james&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Teacher t4 = <span class="keyword">new</span> Teacher(<span class="number">4</span>,<span class="string">&quot;rose&quot;</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Teacher&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(t1);</span><br><span class="line">        list.add(t2);</span><br><span class="line">        list.add(t3);</span><br><span class="line">        list.add(t4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (Teacher teacher : list) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(teacher);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Teacher teacher : list) &#123;</span><br><span class="line">            System.out.println(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><blockquote><p>java.util.Collections[C] - 集合工具类</p><p>面试题 - Collection和Collections有什么区别?</p><ol><li><p>static <T> void    sort(List<T> list, Comparator&lt;? super T&gt; c)<br>根据指定的比较器引起的顺序对指定的列表进行排序。</T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(bookList,((o1, o2) -&gt; (<span class="keyword">int</span>) (o2.getPrice()-o1.getPrice())));</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口</T></li></ol></blockquote><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><blockquote><p>Set[I]接口下的实现类 - 存储的数据是无序不可重复复的.</p><p>添加数据到容器的原理:</p><ol><li>当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值.</li><li>如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置</li><li>如果这个哈希值在这之前出现过了.产生了哈希碰撞或者哈希冲突.但是这个时候,还不能确定哈希碰撞的俩个对象是同一个对象</li><li>继续调用对象的equals方法,如果返回true,说明是同一个对象.则拒绝添加.</li></ol><p>底层数据结构</p><ol><li>散列表</li><li>桶数组 + 链表 + 红黑树</li></ol></blockquote><blockquote><p>查看HashSet源码</p><p>Set<Teacher> sets = new HashSet&lt;&gt;();</Teacher></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//HashSet的底层是HashMap</span></span><br><span class="line">  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet的add方法的底层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的e是添加到容器中的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实际上还是在调用map的put方法</span></span><br><span class="line">  <span class="comment">//HashSet中添加的对象是作为了Map集合的key</span></span><br><span class="line">  <span class="comment">//Map的key具有什么特点 = HashSet中的数据有何特点.</span></span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="HashMap-和-HashTable-区别"><a href="#HashMap-和-HashTable-区别" class="headerlink" title="HashMap 和 HashTable 区别"></a>HashMap 和 HashTable 区别</h2><blockquote><p>HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null  key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下:</p><ol><li><p>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p></li><li><p>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</p></li><li><p>HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</p></li><li><p>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</p></li><li><p>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</p></li></ol></blockquote><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><blockquote><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</li></ol></blockquote><h2 id="List和Set区别"><a href="#List和Set区别" class="headerlink" title="List和Set区别"></a>List和Set区别</h2><blockquote><p>两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下：</p><ol><li>List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。</li><li> 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。</li><li> List可以通过下标来访问，而Set不能。</li></ol></blockquote><h2 id="HashSet和HashMap区别"><a href="#HashSet和HashMap区别" class="headerlink" title="HashSet和HashMap区别"></a>HashSet和HashMap区别</h2><blockquote><p>HashSet的底层是HashMap</p></blockquote><blockquote><table><thead><tr><th><em>HashMap</em></th><th><em>HashSet</em></th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap储存键值对</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用put()方法将元素放入map中</td><td>使用add()方法将元素放入set中</td></tr><tr><td>HashMap中使用键对象来计算hashcode值</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap比较快，因为是使用唯一的键来获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></blockquote><h2 id="ArrayList和HashSet区别"><a href="#ArrayList和HashSet区别" class="headerlink" title="ArrayList和HashSet区别"></a>ArrayList和HashSet区别</h2><blockquote><p>1.HashSet 是不重复的 而且是无序的!</p><p>​     唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数</p><p>​     HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分,</p><p>2.ArrayList是可重复的 有序的</p><p>​    特点：查询效率高，增删效率低 轻量级 线程不安全。</p><p>   arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快</p></blockquote><h2 id="HashSet和TreeSet区别"><a href="#HashSet和TreeSet区别" class="headerlink" title="HashSet和TreeSet区别"></a>HashSet和TreeSet区别</h2><blockquote><p><strong>一、HashSet</strong></p><p>HashSet内部的数据结构是哈希表，是线程不安全的。</p><p>HashSet当中，保证集合中元素是唯一的方法。</p><p>通过对象的hashCode和equals方法来完成对象唯一性的判断。</p><p>假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。</p><p>假如，结果是true，那么就要视作相同元素，不存。</p><p>假如，结果是false，那么就视为不同元素，存储。</p><p>注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。</p><p><strong>二、TreeSet</strong></p><p>TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。</p><p>TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。</p><p>TreeSet对元素进行排序的方式：</p><p>1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。</p><p>2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。</p><p>除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。</p><p>也就是其元素的存入和输出的顺序是相同的。</p></blockquote><h2 id="HashMap和TreeMap区别"><a href="#HashMap和TreeMap区别" class="headerlink" title="HashMap和TreeMap区别"></a>HashMap和TreeMap区别</h2><blockquote><p>HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。</p><p>另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。</p><p>HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。</p><p>TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。           </p></blockquote><h2 id="ArrayList和Vector区别"><a href="#ArrayList和Vector区别" class="headerlink" title="ArrayList和Vector区别"></a>ArrayList和Vector区别</h2><blockquote><ol><li>Vector是线程安全的，ArrayList不是线程安全的。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</li></ol></blockquote><h1 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h1><blockquote><p>贪吃蛇算法 - LinkedList-操作头和尾-适合解决队列和栈列的业务题目</p></blockquote><blockquote><h6 id="算法的思路"><a href="#算法的思路" class="headerlink" title="算法的思路"></a>算法的思路</h6><p>蛇移动,判断方向,#### - 坐标</p><ol><li>蛇头节点的坐标getFirst() -&gt; 移动之后的新的节点</li><li>不管新的节点是否为食物.蛇linkeList集合果断先将新的节点加入到该链表的头结点中.addFirst</li><li>判断新的节点如果是食物的节点,那么链表就不删除最后一个节点.否则删除链表的最后一个节点.</li></ol></blockquote><h1 id="TreeSet-C"><a href="#TreeSet-C" class="headerlink" title="TreeSet[C]"></a>TreeSet[C]</h1><blockquote><p>简单了解一下</p><p>Set[I] - SortedSet[I] - TreeSet[C] - 底层是TreeMap[C] - 使map集合的key根据定制的规则来进行排序.</p><p>Set - 无序不可重复的.</p><p>TreeSet - 不可重复的,但是可以根据定制的排序规则来进行排序.</p></blockquote><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><blockquote><p>java.util.stream.Stream;</p><p>它和传统的集合框架在性能上的比较.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day10</title>
    <link href="http://example.com/2021/07/24/day10/"/>
    <id>http://example.com/2021/07/24/day10/</id>
    <published>2021-07-24T10:02:10.000Z</published>
    <updated>2022-01-07T08:55:44.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h1><blockquote><p>每个基本类型都有其对应的包装类型[对象类型]</p><p>byte-&gt;Byte</p><p>short-&gt;Short</p><p><strong>int-&gt;Integer</strong></p><p>long-&gt;Long</p><p>float-&gt;Float</p><p><strong>double-&gt;Double</strong></p><p><strong>char-&gt;Character</strong></p><p>boolean-&gt;Boolean</p><p><strong>学习掌握目标</strong></p><ol><li><strong>包装类型的api的常用方法</strong></li><li><strong>包装类型和基本数据类型以及String类型三者之间的相互转换问题.</strong></li></ol></blockquote><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><blockquote><p>api:java.lang包,所有关于上面包装类型[数字]的共同的抽象的父类.</p><table><thead><tr><th><code>byte</code></th><th><code>byteValue()</code>返回指定号码作为值 <code>byte</code> ，这可能涉及舍入或截断。</th></tr></thead><tbody><tr><td><code>abstract double</code></td><td><code>doubleValue()</code>返回指定数字的值为 <code>double</code> ，可能涉及四舍五入。</td></tr><tr><td><code>abstract float</code></td><td><code>floatValue()</code>返回指定数字的值为 <code>float</code> ，可能涉及四舍五入。</td></tr><tr><td><code>abstract int</code></td><td><code>intValue()</code>返回指定号码作为值 <code>int</code> ，这可能涉及舍入或截断。</td></tr><tr><td><code>abstract long</code></td><td><code>longValue()</code>返回指定数字的值为 <code>long</code> ，可能涉及四舍五入或截断。</td></tr><tr><td><code>short</code></td><td><code>shortValue()</code>返回指定号码作为值 <code>short</code> ，这可能涉及舍入或截断。</td></tr></tbody></table></blockquote><p><code>提供的这些方法都是关于包装类型转换成对应的基本类型的方法</code></p><h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><blockquote><ol><li><p>Integer(int i);//利用int类型的整数来构建一个Integer对象 - int类型-&gt;Integer类型</p></li><li><p>Integer(String s);//此处的字符串一定是数字形式的字符串 - String类型-&gt;Integer类型</p><p>如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常</p></li></ol></blockquote><h2 id="自动解封箱"><a href="#自动解封箱" class="headerlink" title="自动解封箱"></a>自动解封箱</h2><blockquote><p>jdk5.x开始支持的新的功能</p></blockquote><blockquote><ol><li>封箱 - 基本数据类型可以自动转换成对应的包装类型</li><li>解箱 - 包装类型可以自动转换成对应的基本的数据类型</li></ol></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><ol><li><p>static Integer valueOf(int i);//将int-&gt;Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">128</span>,<span class="number">127</span>] -&gt; 比较的结果是<span class="keyword">true</span>,不在这个范围的是返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果[-128,127]之间,那么直接返回内部的缓冲数组中的数据</span></span><br><span class="line"><span class="comment">//如果不在这个范围,返回一个新的Integer对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Integer类内部有一个静态内部类</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">//缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">      cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> j = low;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  [-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false</span></span><br><span class="line"><span class="comment">//剖析自动封箱</span></span><br><span class="line">Integer a = <span class="number">127</span>;<span class="comment">//Integer a = Integer.valueOf(127);</span></span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">admindeMacBook-Pro:Desktop admin$ javap -c IntegerHello</span><br><span class="line">Compiled from <span class="string">&quot;IntegerHello.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerHello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IntegerHello</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">127</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: bipush        <span class="number">127</span></span><br><span class="line">       <span class="number">8</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="number">11</span>: astore_2</span><br><span class="line">      <span class="number">12</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">15</span>: aload_1</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">      <span class="number">19</span>: bipush        <span class="number">7</span></span><br><span class="line">      <span class="number">21</span>: if_icmpne     <span class="number">28</span></span><br><span class="line">      <span class="number">24</span>: iconst_1</span><br><span class="line">      <span class="number">25</span>: goto          <span class="number">29</span></span><br><span class="line">      <span class="number">28</span>: iconst_0</span><br><span class="line">      <span class="number">29</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line">      <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于进制转换的方法</p><p>2-1. static String toBinaryString(int n);//十进制n转换成对应的二进制</p><p>2-2. static String toHexString(int n);//十进制n转换成对应的十六进制</p><p>2-3. static String toOctalString(int n);//十进制n转换成对应的八进制</p></li><li><p>static int parseInt(String s);//将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常</p></li><li><p>static Integer valueOf(String s);//String-&gt;Integer</p></li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>包装类型和基本数据类型以及String类型三者之间的相互转换问题.</strong></p></blockquote><blockquote><ol><li><p>int-&gt;Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer的构造Integer(<span class="keyword">int</span> n)</span><br><span class="line"><span class="number">2.</span> jdk5<span class="number">.0</span>提供的自动封箱Integer a = <span class="number">10</span>;</span><br><span class="line"><span class="number">3.</span> java.lang.Integer提供的<span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Integer -&gt; int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;<span class="comment">//java.lang.Number提供的抽象方法,java.lang.Integer重写了该方法</span></span><br><span class="line"><span class="number">2.</span> jdk5<span class="number">.0</span>提供的自动解箱</span><br></pre></td></tr></table></figure></li><li><p>int-&gt;String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.String提供的方法<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>String-&gt;int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer类<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>String-&gt;Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer的构造Integer(String n)</span><br><span class="line"><span class="number">2.</span> java.lang.Integer的方法<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(String n)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Integer-&gt;String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang.Integer的<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2.</span> java.lang.String中提供了<span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><blockquote><p>笔试题:int和Integer之间的区别</p><ol><li>Integer是int的包装类；int是基本数据类型；</li><li>Integer变量必须实例化后才能使用；int变量不需要；</li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li><li>Integer的默认值是null；int的默认值是0。</li><li>泛型不支持int，但是支持Integer</li><li>int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。</li></ol></blockquote><h2 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h2><p><img src="/2021/07/24/day10/%E6%9D%A1%E5%BD%A2%E7%A0%81.png"> </p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><blockquote><p>java.lang.Object类是所有的类的基类,根类,超类</p><p>所有的类如果没有明确指定父类,都会默认继承Object类.</p></blockquote><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><blockquote><ol><li><p>boolean equals(Object obj);//对象之间的比较.默认仍然使用的是==</p><p><strong>“业内认可的一种说法” - 基本类型用==比较的值,对象类型用==比较的是地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的比较方式不符合实际的业务需要,因此需要重写equals方法</p><p>success版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="comment">//1. 非空性</span></span><br><span class="line">  <span class="keyword">if</span>(obj == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//2. 自反性</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == obj)<span class="comment">//p1.equals(p1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//3. 一致类型,判断具体的哪个属性是一致的,才认为返回true</span></span><br><span class="line">  <span class="comment">// p1.equals(user);</span></span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Product)&#123;</span><br><span class="line">    Product p = (Product) obj;</span><br><span class="line">    <span class="comment">//return this.id == p.id;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//id和name都一致的时候,才认为是同一个对象</span></span><br><span class="line">    <span class="comment">//return (this.id == p.id) &amp;&amp; (this.name.equals(p.name));</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//需求 - 认为产品的id以及这个产品对应的产品信息的id一致的时候认为返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id == p.id &amp;&amp; <span class="keyword">this</span>.getProductInfo().equals(p.productInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><blockquote><p>int hashCode();//返回对象的哈希值.一般是和equals方法是成对出现的.目的是为了<strong>提高性能.</strong></p></blockquote><blockquote><p>容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法</p><p>而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间]</p></blockquote><blockquote><p><strong><code>关于数字31</code> - 质数 - 1. 尽可能产生更多的哈希值  2. 让哈希碰撞/冲突尽可能少.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">  result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">  result = <span class="number">31</span> * result + (productInfo != <span class="keyword">null</span> ? productInfo.hashCode() : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>超前知识点</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day10.hashcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/28 2:01 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Course c1 = <span class="keyword">new</span> Course(<span class="number">1</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Course c2 = <span class="keyword">new</span> Course(<span class="number">2</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c3 = <span class="keyword">new</span> Course(<span class="number">3</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c4 = <span class="keyword">new</span> Course(<span class="number">4</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c5 = <span class="keyword">new</span> Course(<span class="number">5</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        Course c6 = <span class="keyword">new</span> Course(<span class="number">1</span>,<span class="string">&quot;oracle&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(c1 == c2);//false</span></span><br><span class="line"><span class="comment">//        System.out.println(c1.equals(c2));//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合 - &quot;容器&quot;,比数组更加强大的.</span></span><br><span class="line">        <span class="comment">//集合 - 里面存储的数据是无序不可重复的</span></span><br><span class="line">        <span class="comment">//不能存储同一个对象</span></span><br><span class="line">        Set&lt;Course&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//1. 当把某个对象放入到该容器之前,先调用了该对象的hashCode方法,得到一个哈希值</span></span><br><span class="line">        <span class="comment">//2. 根据这个哈希值就可以被分配一个内存地址</span></span><br><span class="line">        <span class="comment">//3. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用.那么就会直接将该对象放入到</span></span><br><span class="line">        <span class="comment">//   这个哈希值对应的在容器中的那个位置</span></span><br><span class="line">        <span class="comment">//4. 如果这个哈希值在这之前出现过.但是此时还不能说明这个对象和之前的那个对象是同一个对象?</span></span><br><span class="line">        <span class="comment">//   因为哈希值是通过哈希算法计算得到的,可能产生&quot;哈希冲突&quot; - &quot;哈希碰撞&quot;</span></span><br><span class="line">        <span class="comment">//5. 当哈希值一样的时候,那么才会去调用equals方法,如果equals方法仍然返回true,那么才</span></span><br><span class="line">        <span class="comment">//   最终确定这个对象曾经出现过,那么就拒绝添加.</span></span><br><span class="line">        sets.add(c1);</span><br><span class="line">        sets.add(c2);</span><br><span class="line">        sets.add(c3);</span><br><span class="line">        sets.add(c4);</span><br><span class="line">        sets.add(c5);</span><br><span class="line">        sets.add(c6);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Course c : sets) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><ol><li>如果俩个对象的hashcode值一样,那么equals比较,不一定返回true</li><li>如果俩个对象equals返回true,那么这俩个对象的哈希值必须要一样 - 数据的完整性.</li></ol></blockquote><h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><blockquote><p>== 和 equals的区别</p><ol><li>== 基本类型使用,比较的就是基本类型的数值</li><li>equals 对象类型使用.如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true.</li></ol></blockquote><h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><blockquote><p>protected Object clone();//默认的克隆方法是浅克隆</p></blockquote><h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><blockquote><p>浅拷贝,浅层复制,浅复制 - 默认的.</p><p>protected - public</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">Object中的clone方法 - <span class="keyword">native</span>修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常.</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Product copy = (Product) p1.clone();</span><br><span class="line"></span><br><span class="line">Product copy2 = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;mac&quot;</span>,<span class="number">1000.0d</span>);</span><br><span class="line"></span><br><span class="line">为什么需要使用clone,而不直接<span class="keyword">new</span>一个.</span><br><span class="line">clone方法它直接操作的堆里面的内存 - 效率是高于重新<span class="keyword">new</span>的.</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day10.obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/28 2:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCloneDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product p1 = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;mac&quot;</span>,<span class="number">1000.0d</span>);</span><br><span class="line">        ProductInfo info = <span class="keyword">new</span> ProductInfo(<span class="number">1</span>,<span class="string">&quot;good&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.setProductInfo(info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(p1 instanceof Cloneable);//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//浅拷贝</span></span><br><span class="line">            Product copy = (Product) p1.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1. 修饰基本数据类型以及字符串 - 原来的对象 - 是否对copy对象产生影响 - 不会</span></span><br><span class="line">            p1.setId(<span class="number">10</span>);</span><br><span class="line">            p1.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 修改对象类型 - 会对copy的对象产生影响的</span></span><br><span class="line">            p1.getProductInfo().setId(<span class="number">100</span>);</span><br><span class="line">            p1.getProductInfo().setInfo(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(copy);</span><br><span class="line">            System.out.println(copy.getProductInfo());</span><br><span class="line">            <span class="comment">//System.out.println(copy == p1);//false</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;<span class="comment">//不能被克隆的异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><blockquote><p>深层复制,深拷贝,深复制 - 需要自己重写clone里面的具体的代码的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深拷贝 - 修改原来对象中的任何类型的数据都不会对副本对象产生影响</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">  <span class="comment">//Product copy = (Product)p1.clone();</span></span><br><span class="line">  <span class="comment">//手动新建一个Product对象</span></span><br><span class="line">  Product product = <span class="keyword">new</span> Product();</span><br><span class="line">  product.setId(id);</span><br><span class="line">  product.setName(name);</span><br><span class="line">  product.setPrice(price);</span><br><span class="line"></span><br><span class="line">  ProductInfo infos = getProductInfo();</span><br><span class="line">  <span class="keyword">if</span>(infos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    ProductInfo pi = <span class="keyword">new</span> ProductInfo();</span><br><span class="line">    pi.setId(infos.getId());</span><br><span class="line">    pi.setInfo(infos.getInfo());</span><br><span class="line"></span><br><span class="line">    product.setProductInfo(pi);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><p>就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用.</p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api:java.util</span><br><span class="line">  </span><br><span class="line">Collection[I]</span><br><span class="line">  - List[I] - 有序可重复</span><br><span class="line">    - ArrayList[C]</span><br><span class="line">    - LinkedList[C]</span><br><span class="line">    - Vector[C]</span><br><span class="line">  - Set[I] - 无序不可重复</span><br><span class="line">    - HashSet[C]</span><br><span class="line">    - SortedSet[I]</span><br><span class="line">      - TreeSet[C]</span><br><span class="line">Map[I]</span><br><span class="line">  - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复.</span><br><span class="line">  - Hashtable[C]</span><br><span class="line">    - Properteis[C] - 属性文件在内存中的映射的对象</span><br></pre></td></tr></table></figure><h2 id="Collection-I"><a href="#Collection-I" class="headerlink" title="Collection[I]"></a>Collection[I]</h2><blockquote><ol><li>boolean add(E e);//向容器中添加一个元素</li><li>void clear();//清空容器</li><li>boolean contains(Object o);//判断容器中是否包含某个对象</li><li>boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true</li><li>Iterator<E>    iterator();// 获取集合对象的迭代器</E></li><li>boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个</li><li>int size();//返回集合中的数据的个数 - 集合的大小</li></ol></blockquote><h2 id="List-I"><a href="#List-I" class="headerlink" title="List[I]"></a>List[I]</h2><blockquote><p>特点 - 有序并且是可以重复的.</p><ol><li>E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1]</li><li>int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</li><li>E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素</li><li>Object[] toArray();//将集合转换成数组.</li></ol></blockquote><h1 id="ArrayList-C"><a href="#ArrayList-C" class="headerlink" title="ArrayList[C]"></a>ArrayList[C]</h1><blockquote><p>特点:有序可重复的,<strong>底层数据结构就是一个”动态增长”的数组.</strong></p><p>优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高.</p><p>缺点:增删效率会低.</p></blockquote><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就是真正的存储数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1. 初始化elementData,长度为0</span></span><br><span class="line">  <span class="comment">//2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  <span class="comment">//this.elementData = &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剖析add方法"><a href="#剖析add方法" class="headerlink" title="剖析add方法"></a>剖析add方法</h2><blockquote><p>ArrayList扩容的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;<span class="comment">//第一次进来1</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次minCapacity = 10</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续ensureExplicitCapacity(minCapacity);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="comment">//第一次进来10-0&gt;0</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grow(minCapacity)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次</span></span><br><span class="line">  <span class="comment">//oldCapacity = 0</span></span><br><span class="line">  <span class="comment">//newCapacity = 0</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//第一次会进来</span></span><br><span class="line">    newCapacity = minCapacity;<span class="comment">//newCapacity = 10</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h2><blockquote><ol><li><p>直接输出</p></li><li><p>增强for循环 - 只读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常</span><br><span class="line">      </span><br><span class="line">实际的底层,调用迭代器对象中的next方法</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//modCount是当初调用add方法,添加1个元素,modCount自增1个</span></span><br><span class="line">   <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">发现只要调用了remove方法 - modCount++</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day09</title>
    <link href="http://example.com/2021/07/23/day09/"/>
    <id>http://example.com/2021/07/23/day09/</id>
    <published>2021-07-23T10:02:10.000Z</published>
    <updated>2022-01-07T06:46:52.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-lang-String"><a href="#java-lang-String" class="headerlink" title="java.lang.String"></a>java.lang.String</h1><blockquote><p>Java中提供的处理字符串的类.</p><ol><li><p>不可变的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;eef&quot;</span>;<span class="comment">//ok,&quot;abc&quot;就变成了垃圾对象.</span></span><br></pre></td></tr></table></figure></li><li><p>字符串本质上就是一个字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final修饰的类不可被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//维护的是不可变的字符数组</span></span><br><span class="line">    <span class="comment">//String s = &quot;abc&quot;;//将&quot;abc&quot;打散,保存成value[]数组中.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="字符串构建的方式"><a href="#字符串构建的方式" class="headerlink" title="字符串构建的方式"></a>字符串构建的方式</h2><blockquote><ol><li><p>通过new关键字来构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了几个对象?</span></span><br><span class="line"><span class="comment">//1个或者2个</span></span><br><span class="line"><span class="comment">//①通过new关键字在堆里面创建一个字符串对象&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//②同时在&quot;串池&quot;里面扔一个对象&quot;abc&quot;[前提是串池中之前不存在&quot;abc&quot;]</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>直接通过”串池”/“字符串常量池”的方式来构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了几个对象?</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//它会在&quot;串池&quot;中创建一个&quot;abc&quot;字符串对象,然后将地址给了s1</span></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//&quot;串池&quot;中的特点:优先先到串池中查找是否已经存在&quot;abc&quot;对象,如果有直接返回地址给s2</span></span><br><span class="line"><span class="comment">//否则才会继续创建新的字符串对象</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="关于字符串的拼接"><a href="#关于字符串的拼接" class="headerlink" title="关于字符串的拼接"></a>关于字符串的拼接</h2><blockquote><p>字符串的拼接使用+,但是使用+的拼接效率非常低.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符串拼接效率低</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 2:15 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPlusDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test02();<span class="comment">//append</span></span><br><span class="line"></span><br><span class="line">        test01();<span class="comment">//+</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();<span class="comment">//获取当前系统时间的毫秒数</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            str+=i;<span class="comment">//str = str + i;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str拼接时间:&quot;</span>+(t2-t1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//java.lang.StringBuilder</span></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();<span class="comment">//获取当前系统时间的毫秒数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">           builder.append(i);<span class="comment">//拼接方式</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;append拼接时间:&quot;</span>+(t2-t1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>拼接效率的原因</code></p><blockquote><ol><li>+底层每次都会产生一个StringBuilder对象</li><li>+底层仍然是调用StringBuilder中的append方法</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">字符串使用+拼接的过程中,会产生新的对象 - 拼接效率低</span><br><span class="line"></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  </span><br><span class="line">admindeMacBook-Pro:Desktop admin$ javap -c HelloStr</span><br><span class="line">Compiled from <span class="string">&quot;HelloStr.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStr</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloStr</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc  放在了&quot;串池中&quot;</span></span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">       <span class="number">6</span>: dup                               <span class="comment">// &quot;abc&quot; -&gt; 堆里面</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc  &quot;串池中已经出现了&quot;</span></span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: astore_2</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = s1 + s2;<span class="comment">//会产生一个新的对象</span></span><br><span class="line"></span><br><span class="line">admindeMacBook-Pro:Desktop admin$ javap -c HelloStr</span><br><span class="line">Compiled from <span class="string">&quot;HelloStr.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStr</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloStr</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">       <span class="number">6</span>: dup</span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String def</span></span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: astore_2</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">                              <span class="comment">//字符串每次拼接+,都会产生一个新的StringBuilder对象</span></span><br><span class="line">      <span class="number">16</span>: dup</span><br><span class="line">      <span class="number">17</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">                          <span class="comment">//StringBuilder builder = new StringBuilder();</span></span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:</span></span><br><span class="line">                                          <span class="comment">//(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串的+,底层仍然是去调用StringBuilder类中提供的append方法</span></span><br><span class="line">      <span class="number">24</span>: aload_2</span><br><span class="line">      <span class="number">25</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">28</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">31</span>: astore_1</span><br><span class="line">      <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符串的各种比较</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 2:35 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCompare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//s1默认指向的是堆里面的字符串对象</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//intern()强制让s1指向串池的对象</span></span><br><span class="line">        System.out.println(s1.intern() == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;a&quot;</span> + s3;<span class="comment">//产生一个StringBuilder对象</span></span><br><span class="line">        String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;<span class="comment">//因为此处的&quot;a&quot;和&quot;b&quot;就是字符串常量</span></span><br><span class="line">                              <span class="comment">//jvm对待字符串常量的拼接 - &quot;a&quot;和&quot;b&quot;的拼接</span></span><br><span class="line">                              <span class="comment">//当成&quot;ab&quot;的整体,直接扔到常量池中.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s4 == s5);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> String s6 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="comment">//&quot;a&quot;+s6 =&gt; &quot;ab&quot;扔到常量池,没有产生新的对象.</span></span><br><span class="line">        String s7 = <span class="string">&quot;a&quot;</span> + s6;</span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String x1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String x2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(x1 == x2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//希望字符串的值是一样的,就希望返回true</span></span><br><span class="line">        System.out.println(x1.equals(x2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><blockquote><p>构造方法</p><p>String();</p><p>String(String val);</p><p>String(StringBuilder builder);//StringBuilder对象转换成String对象</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 字符串常用方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 3:02 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">// java.lang.StringIndexOutOfBoundsException</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));<span class="comment">//b</span></span><br><span class="line">        System.out.println(s.length());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        String result = s.concat(<span class="string">&quot;de&quot;</span>);<span class="comment">//原来的字符串的末尾添加新的字符串</span></span><br><span class="line">        System.out.println(result);<span class="comment">//abcde</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断字符串中是否包含某个序列</span></span><br><span class="line">        System.out.println(s.contains(<span class="string">&quot;bc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断前缀或者后缀</span></span><br><span class="line">        System.out.println(<span class="string">&quot;xxx.gif&quot;</span>.endsWith(<span class="string">&quot;.gif&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;javaScript&quot;</span>.startsWith(<span class="string">&quot;java&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(s));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略大小写的比较</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;abc&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换大写和小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.toUpperCase());<span class="comment">//ABC</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.toLowerCase());<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回指定字符第一次出现的字符串内的索引。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcabc&quot;</span>.indexOf(<span class="string">&quot;b&quot;</span>));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abcabc&quot;</span>.lastIndexOf(<span class="string">&quot;b&quot;</span>));<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.isEmpty());<span class="comment">//长度为0的字符串 - 返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;I Love Girl&quot;</span>.replace(<span class="string">&quot;Girl&quot;</span>,<span class="string">&quot;Java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串的切割</span></span><br><span class="line">        String ip = <span class="string">&quot;192:168:3:90&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String[] arr = ip.split(<span class="string">&quot;\\:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s1 : arr) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串转换成char类型数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr2 = <span class="string">&quot;白日依山尽&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr2) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String x1 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">        String x2 = x1.substring(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//[1,3)</span></span><br><span class="line">        System.out.println(x2);</span><br><span class="line"></span><br><span class="line">        System.out.println(x1.substring(<span class="number">1</span>));<span class="comment">//从1一直截取到最后bcde</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//trim() - 去除字符串左右两边的空格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;  ab c  &quot;</span>.trim().length());<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;       &quot;</span>.trim().length());<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int-&gt;String</span></span><br><span class="line">        String o = String.valueOf(<span class="number">10</span>);</span><br><span class="line">        System.out.println(o+<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="java-lang-StringBuilder"><a href="#java-lang-StringBuilder" class="headerlink" title="java.lang.StringBuilder"></a>java.lang.StringBuilder</h1><blockquote><p>它是一个可变的字符串 - final修饰,性能最高的.默认的容量16.线程不安全的</p><p>StringBuilder();</p><p>StringBuilder(String val);//String类型转换成StringBuilder类型</p></blockquote><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><blockquote><p>研究append方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder x = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">x.append(<span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line">StringBuilder类的父类<span class="function">AbstractStringBuilder</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> appendNull();</span><br><span class="line">  <span class="keyword">int</span> len = str.length();<span class="comment">//len = 3</span></span><br><span class="line">  <span class="comment">//count+len</span></span><br><span class="line">  <span class="comment">//count - 原来数组中已经存在的字符的长度</span></span><br><span class="line">  <span class="comment">//len - 需要存入的新的字符串长度</span></span><br><span class="line">  ensureCapacityInternal(count + len);<span class="comment">//3</span></span><br><span class="line">  str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">  count += len;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩容方法</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">    expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正的扩容方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;<span class="comment">//扩容,得到新的长度</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)<span class="comment">//扩容得不够,不够长</span></span><br><span class="line">    newCapacity = minimumCapacity;<span class="comment">//直接补充到最长的.</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;<span class="comment">//长度会溢出.</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    newCapacity = Integer.MAX_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 常用方法 - 可变的字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 4:20 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder x = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//String-&gt;StringBuilder</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line"></span><br><span class="line">        StringBuilder result = x.delete(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//[1,3)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);<span class="comment">//ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span>+x);<span class="comment">//ad</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x.deleteCharAt(<span class="number">0</span>));<span class="comment">//d 根据下标进行删除操作</span></span><br><span class="line"></span><br><span class="line">        x.insert(<span class="number">0</span>,<span class="string">&quot;管管&quot;</span>);</span><br><span class="line">        System.out.println(x);<span class="comment">//管管d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转字符串</span></span><br><span class="line">        System.out.println(x.reverse());<span class="comment">//d管管</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int n = 6723;</span></span><br><span class="line"><span class="comment">//        System.out.println(String.valueOf(n).length());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        StringBuilder y = new StringBuilder(String.valueOf(n));</span></span><br><span class="line"><span class="comment">//        System.out.println(y.reverse());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder-&gt;String</span></span><br><span class="line">        System.out.println(x.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>String类型和StringBuilder类型之间的相互转换问题</p><p>StringBuilder-&gt;String类型</p><ol><li>java.lang.StringBuilder中提供的String toString();</li><li>java.lang.String类中提供的构造方法String(StringBuilder builder);</li><li>java.lang.String类中提供的static String valueOf(Object obj);//面向父类编程    </li></ol></blockquote><blockquote><p>String-&gt;StringBuilder</p><ol><li>java.lang.StringBuilder中提供的构造StringBuilder(String val);</li></ol></blockquote><h1 id="java-lang-StringBuffer"><a href="#java-lang-StringBuffer" class="headerlink" title="java.lang.StringBuffer"></a>java.lang.StringBuffer</h1><blockquote><p>它的使用方式和StringBuilder是一模一样的.唯一区别是它是多线程安全的.可变的字符串</p><p>因为它里面的方法都使用<strong>synchronized</strong>关键字进行了修饰,重量级的对象.</p><p>性能低于StringBuilder</p></blockquote><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><blockquote><p>String,StringBuilder,StringBuffer三者的区别? - 查,<strong>补充完整</strong> - 作业</p><ol><li><p>三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点</p></li><li><p>不同点</p><p>2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的.</p><p>2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的.</p><p>2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String</p></li></ol></blockquote><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><p>两道笔试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从oldStr中删除指定的target字符串</span></span><br><span class="line"><span class="comment">//比如&quot;abcdebcef&quot;,&quot;bc&quot; -&gt; 返回&quot;adeef&quot;</span></span><br><span class="line"><span class="comment">//禁止使用replace方法</span></span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">delByStr</span><span class="params">(String oldStr,String target)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出俩个字符串中的最大长度的公串</span></span><br><span class="line"><span class="comment">//abcbcedfdfdepopoqqq</span></span><br><span class="line"><span class="comment">//fdfdbcbceoifdfdeqqa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bcbce fdfde</span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day08</title>
    <link href="http://example.com/2021/07/22/day08/"/>
    <id>http://example.com/2021/07/22/day08/</id>
    <published>2021-07-22T10:02:10.000Z</published>
    <updated>2022-01-07T06:46:31.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><blockquote><ol><li><strong>static修饰的成员是在JVM加载类的时候就会被立即分配空间以及初始化 - 只有1次</strong>,内存的实例只有1份</li><li>非静态的成员的是在每次创建对象的时候才会被分配空间以及初始化</li></ol></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><ol><li>static修饰符类 - 静态内部类[过]</li><li>修饰的属性 - 静态属性</li><li>方法 - 静态方法</li><li>代码块 - 静态代码块</li></ol></blockquote><h2 id="JVM加载类进内存的活动顺序"><a href="#JVM加载类进内存的活动顺序" class="headerlink" title="JVM加载类进内存的活动顺序"></a>JVM加载类进内存的活动顺序</h2><ol start="0"><li><p>JVM加载类进内存</p></li><li><p>给所有的静态属性分配空间以及初始化</p></li><li><p>给所有的静态方法分配空间以及初始化</p></li><li><p>调用静态代码块</p></li><li><p>如果创建了对象</p><p>4-1. 给这个对象的所有的非静态属性分配空间以及初始化</p><p>4-2. 给这个对象的所有的非静态方法分配空间</p><p>4-3. 调用普通代码块</p><p>4-4. 调用构造块</p></li></ol><h1 id="static关键字应用"><a href="#static关键字应用" class="headerlink" title="static关键字应用"></a>static关键字应用</h1><blockquote><p>设计模式 - 单例模式</p><p>如何保证某个类的对象在内存中永远只有1份.后期,某些类的创建和销毁的时间成本比较高.这些类有必要设计成单例的.</p><p>比如jdbc中的连接池对象[重量级的对象]</p></blockquote><h2 id="饿汉模式-多线程安全"><a href="#饿汉模式-多线程安全" class="headerlink" title="饿汉模式 多线程安全"></a>饿汉模式 多线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 将Singleton01设置成饿汉模式 - 单例的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 9:28 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 初始化一个变量,该变量就是该类的唯一实例[对象]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有化构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较费时费力的代码,可能需要更多的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton01...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公开的静态的方法来返回这个类的唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类的实例</span></span><br><span class="line">        Singleton01 s1 = Singleton01.getInstance();</span><br><span class="line">        Singleton01 s2 = Singleton01.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式-多线程不安全"><a href="#懒汉模式-多线程不安全" class="headerlink" title="懒汉模式 多线程不安全"></a>懒汉模式 多线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 懒汉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 9:35 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span>?instance = <span class="keyword">new</span> Singleton02():instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton02</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Singleton02 s1 = Singleton02.getInstance();</span></span><br><span class="line"><span class="comment">//        Singleton02 s2 = Singleton02.getInstance();</span></span><br><span class="line"><span class="comment">//        System.out.println(s1 == s2);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重检查锁-笔试脱手写的版本"><a href="#双重检查锁-笔试脱手写的版本" class="headerlink" title="双重检查锁 - 笔试脱手写的版本"></a>双重检查锁 - 笔试脱手写的版本</h2><blockquote><p>懒汉模式下 - 仍然是多线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:双重检查锁 - 笔试脱手写的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 10:07 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断.</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//跑得快的线程都会进入此处A,B</span></span><br><span class="line">            <span class="comment">//A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入</span></span><br><span class="line">            <span class="comment">//同步代码块去执行里面的代码</span></span><br><span class="line">            <span class="comment">//假设A线程抢到了,B就会在等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton03.class)&#123;</span><br><span class="line">                <span class="comment">//A进入判断instance==null</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//只要抢到&quot;锁&quot;的线程,如果此处没有非null判断</span></span><br><span class="line">                <span class="comment">//那么进入到这的线程都会去执行instance = new Singleton03();</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//由A线程进行实例的初始化</span></span><br><span class="line">                    <span class="comment">//A继续执行,等A执行完毕之后,那么A就会释放锁资源</span></span><br><span class="line">                    <span class="comment">//其他线程继续争抢锁资源.</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote><ol><li><p>可见性 - 忽略</p></li><li><p>禁止JVM的指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;<span class="comment">//原子性操作</span></span><br><span class="line">   </span><br><span class="line">Student s = <span class="keyword">new</span> Student();<span class="comment">//不是一个原子性操作</span></span><br><span class="line">①给s对象分配内存空间</span><br><span class="line">②调用构造块,执行构造函数 - 初始化动作</span><br><span class="line">③将引用s指向内存中的那个对象.</span><br><span class="line">     </span><br><span class="line">但是JVM内部会对这些指令进行一个优化操作.</span><br><span class="line">本来你的顺序应该是①-②-③,经过JVM指令重排之后,顺序有可能</span><br><span class="line">变成①-③-②</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.singleton.version03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:双重检查锁 - 笔试脱手写的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/27 10:07 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton03 instance;</span><br><span class="line">    <span class="comment">//private static Singleton03 instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有化构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//② - 跑得很慢的线程刚刚到达此处,其他线程判断instance是不为null的</span></span><br><span class="line">        <span class="comment">//但是instance可能指向的是一个&quot;半成品&quot; - A线程还没有完成构造方法.</span></span><br><span class="line">        <span class="comment">//其他线程可能会使用到这个&quot;半成品&quot;对象,肯定会有问题.</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton03.class)&#123;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//① - A线程可能执行到2步骤的时候,instance已经不为null</span></span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">//不是一个原子性操作,可能经过JVM指令重排</span></span><br><span class="line">                    <span class="comment">//1. 给instance对象分配空间</span></span><br><span class="line">                    <span class="comment">//2. 将对象的内存地址赋值给了instance</span></span><br><span class="line">                    <span class="comment">//3. 调用构造方法</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day07</title>
    <link href="http://example.com/2021/07/21/day07/"/>
    <id>http://example.com/2021/07/21/day07/</id>
    <published>2021-07-21T10:02:10.000Z</published>
    <updated>2022-01-07T06:46:10.979Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><blockquote><ol><li><p>抽象类天生就是用来被子类继承的.抽象类天生就是不能够被外部进行实例化的</p></li><li><p>抽象类使用abstract关键字来进行修饰 </p></li><li><p>抽象类中允许存在构造方法,普通属性,普通方法以及抽象方法.</p></li><li><p>普通类是没有资格去定义抽象方法</p></li><li><p>抽象方法也是使用abstract来修饰的,抽象方法是指没有方法体的方法.</p><p>抽象的方法天生也是用来被子类重写的.</p></li><li><p>抽象类是一种抽象的数据类型.</p></li></ol></blockquote><h2 id="抽象类的继承的特点"><a href="#抽象类的继承的特点" class="headerlink" title="抽象类的继承的特点"></a>抽象类的继承的特点</h2><blockquote><ol><li>如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中的所有的抽象方法.</li><li>如果某个子类继承了抽象类,不想重写抽象父类中的所有的抽象方法,那么需要将这个子类也定义成抽象类.</li></ol></blockquote><h1 id="不能一起混用的修饰符"><a href="#不能一起混用的修饰符" class="headerlink" title="不能一起混用的修饰符"></a>不能一起混用的修饰符</h1><blockquote><ol><li><p>final和abstract一起使用</p></li><li><p>private和abstract能不能一起修饰方法.</p></li><li><p>static和abstract不能一起用来修饰方法</p><p>static是不存在多态的.</p></li></ol></blockquote><h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><blockquote><p>模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。即：<strong>处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。处理步骤在父类中定义好，具体实现延迟到子类中定义 。</strong></p></blockquote><blockquote><p>抽象的类应用 -  模板方法设计模式.</p><p>模板类中只负责定义</p><ol><li>需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现.</li><li>做的事情的流程[步骤]</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 9:36 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定了需要完成的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//演员登台</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;<span class="comment">//演员表演</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;<span class="comment">//落幕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个不可变的方法,用来控制事情执行的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.play();</span><br><span class="line">        <span class="keyword">this</span>.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>模板方法的优点和缺点：</p><p><strong>优点</strong>：</p><ol><li>模板方法提供了一个很好的代码复用平台。</li><li>实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，符合 “开闭原则”。</li></ol><p><strong>缺点：</strong></p><p>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><blockquote><ol><li>属于抽象的数据类型,也是不能够被实例化的</li><li>接口中不允许定义普通属性的,不允许出现构造的.</li><li>jdk8.x允许在接口中使用<strong>default关键字来定义普通方法</strong>.</li><li>接口也是用来定义抽象的方法的.<strong>接口中的方法都是抽象的方法.</strong></li><li><strong>接口的属性都是公开的静态的常量属性.</strong></li><li>定义接口的关键字是interface,编译之后也是.class字节码文件</li><li>接口也是可以静态方法的.</li></ol></blockquote><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><blockquote><p>使用I开头或者able结尾</p></blockquote><h2 id="多态的另外应用"><a href="#多态的另外应用" class="headerlink" title="多态的另外应用"></a>多态的另外应用</h2><blockquote><p>面向接口编程</p><ol><li>对象的编译时类型写成接口,对象的运行时类型写成是实现类</li><li>方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类.</li><li>方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类.</li></ol></blockquote><h2 id="接口的规则"><a href="#接口的规则" class="headerlink" title="接口的规则"></a>接口的规则</h2><blockquote><ol><li><p>接口和类 - 类是可以去实现这个接口的.</p><blockquote><ol><li>接口天生是用来是<strong>实现类</strong>来实现的 - implements</li><li>普通的类去实现某个接口的话,那么必须要实现这个接口中所有的抽象方法</li><li>如果抽象的类去实现某个接口的话,那么可以选择实现或者不实现.</li><li>一个接口可以拥有多个实现类.</li><li>一个类可以同时实现多个接口,接口之间用逗号隔开.需要实现这些接口中所有的抽象方法.</li></ol></blockquote></li><li><p>接口和接口</p><blockquote><ol><li>一个接口可以继承多个接口,接口是支持多重继承的.</li></ol></blockquote></li></ol></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>提供了一种”契约机制”,屏蔽了底层的具体的实现,为了程序的拓展</p><p>作用 - 制定开发的这个软件中的功能 - “业务方法”</p></blockquote><h2 id="接口的分类"><a href="#接口的分类" class="headerlink" title="接口的分类"></a>接口的分类</h2><blockquote><ol><li><p>业务接口 - 该接口中只定义抽象方法</p></li><li><p>常量接口 - 该接口中只定义了常量属性,管理系统中所有的常量属性的.jdk5.x使用了枚举类型来替代了常量接口</p></li><li><p>标记接口 - 什么都没有,做标记的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aimpl</span> <span class="keyword">implements</span> <span class="title">IA</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">Aimpl a = <span class="keyword">new</span> Aimpl();</span><br><span class="line">System.out.println(a <span class="keyword">instanceof</span> IA);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>函数式接口 - jdk8.x - 配合jdk8.x - lambda表达式</p><p>里面只有一个抽象方法的接口 - @FunctionalInterface</p></li></ol></blockquote><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="设计模式概念"><a href="#设计模式概念" class="headerlink" title="设计模式概念"></a>设计模式概念</h2><p>设计模式（Design Pattern）<strong>是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结</strong>。</p><p>使用设计模式的目的：为了<strong>代码可重用性</strong>、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码<strong>编写真正工程化</strong>；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><p>项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，<strong>每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案</strong>，这也是设计模式能被广泛应用的原因。</p><h1 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h1><p>为什么要提倡“Design Pattern”呢？根本原因是为了<strong>代码复用，增加可维护性</strong>。那么怎么才能实现代码复用呢？面开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。<em><strong>其他几条，则可以看做是开闭原则的实现方法。</strong></em></p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><em><strong>简介:单一职责原则（Single Responsiblity Principle SRP）</strong></em></p><p><strong>接口或类只提供一种业务实现。</strong><br>单一职责原则宗旨是每个接口、类的功能，只能用来做专门的事，强调系统内业务职责唯一，避免职责扩散，做到业务统一管理.</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><em><strong>简介:总原则:开闭原则（Open Close Principle）</strong></em></p><p><strong>开闭原则就是说对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代 码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，<strong>我们需要使用接口和抽象类等</strong>，后面的具体设计中我们会提到这点。 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 </p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><em><strong>简介:里氏替换原则（Liskov Substitution Principle）</strong></em></p><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实 现抽象化的具体步骤的规范。<strong>里氏替换原则中，子类对父类的方法尽量不要重写和重载</strong>。<strong>因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</strong></p><p><strong>因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。</strong></p><ul><li>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><em><strong>简介:依赖倒转原则（Dependence Inversion Principle）</strong></em> </p><p><strong>这个是开闭原则的基础</strong>，具体内容：<strong>面向接口编程，依赖于抽象而不依赖于具体</strong>。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 </p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><em><strong>简介:接口隔离原则（Interface Segregation Principle</strong></em>）</p><p>这个原则的意思是：<strong>每个接口中不存在实现类用不到却必须实现的方法</strong>，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p><em><strong>简介:迪米特法则（最少知道原则）（Demeter Principle)</strong></em></p><p>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：<em><strong>只与直接的朋友通信</strong></em>。类之间只要有耦合关系，就叫朋友关系。<em><strong>耦合分为依赖、关联、聚合、组合等</strong></em>。<em><strong>我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友</strong></em>。<em><strong>局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部 变量出现在类中。</strong></em> </p><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><em><strong>简介:合成复用原则（Composite Reuse Principle)</strong></em></p><p>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式是属于<strong>创建型模式</strong>，<strong>但不属于23种GOF设计模式之一</strong>。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂一般分为：<strong>普通简单工厂</strong>、<strong>多方法简单工厂</strong>、<strong>静态方法简单工厂</strong>。 </p><p><strong>作用:把对象的创建和对象的使用分离</strong></p><p>User user = new User();//对象的创建和对象使用没有分离</p><h2 id="普通简单工厂-必须要脱手写出来的"><a href="#普通简单工厂-必须要脱手写出来的" class="headerlink" title="普通简单工厂 - 必须要脱手写出来的."></a>普通简单工厂 - 必须要脱手写出来的.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 根据传入的参数来返回某个具体的产品[对象]</span></span><br><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.simple01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 简单工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 3:19 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WX = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入的参数来返回某个具体的产品</span></span><br><span class="line">    <span class="comment">//多态的应用 - 面向接口编程</span></span><br><span class="line">    <span class="comment">//3. 方法的返回类型写成接口,方法的执行结果可以是这个接口的任意一个实现类.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        Sender sender = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">//对象的创建 - 复杂的过程...</span></span><br><span class="line">                sender = <span class="keyword">new</span> QQSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                sender = <span class="keyword">new</span> WXSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;参数不合法&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多方法简单工厂"><a href="#多方法简单工厂" class="headerlink" title="多方法简单工厂"></a>多方法简单工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.simple02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 多方法工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 3:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有几个产品,就定义几个方法</span></span><br><span class="line">    <span class="comment">//每个方法负责生成一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QQSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createWx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WXSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法简单工厂"><a href="#静态方法简单工厂" class="headerlink" title="静态方法简单工厂"></a>静态方法简单工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.design.factory.simple02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 多方法工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/23 3:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有几个产品,就定义几个方法</span></span><br><span class="line">    <span class="comment">//每个方法负责生成一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">createQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QQSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">createWx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WXSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂优缺点"><a href="#简单工厂优缺点" class="headerlink" title="简单工厂优缺点"></a>简单工厂优缺点</h2><p>优点：</p><ul><li>很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。</li></ul><p>缺点：</p><ul><li><p>任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大</p></li><li><p><strong>在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。</strong></p></li></ul><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，<strong>如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能， 直接增加新的工厂类就可以了，不需要修改之前的代码</strong>。</p><h2 id="工厂方法模式优缺点"><a href="#工厂方法模式优缺点" class="headerlink" title="工厂方法模式优缺点"></a>工厂方法模式优缺点</h2><p>优点：</p><ul><li>工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1）</li><li>同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，<strong>使得工厂类符合开闭原则。</strong></li></ul><p>缺点：</p><ul><li>相比简单工厂，实现略复杂。</li><li>对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。</li></ul><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。<strong>抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个<em>产品族</em>中的产品对象</strong>。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。</p><h2 id="抽象工厂模式优缺点"><a href="#抽象工厂模式优缺点" class="headerlink" title="抽象工厂模式优缺点"></a>抽象工厂模式优缺点</h2><p>优点： </p><ul><li>抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><p>​        缺点：</p><ul><li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。</li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><ol start="0"><li><p>循环</p><p><img src="/2021/07/21/day07/%E8%AF%95%E9%A2%98.jpg"> </p></li><li><p>OO题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Book[id,name,price...]</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>定义图书操作业务接口 IBookBiz</span><br><span class="line"></span><br><span class="line">有如下方法:</span><br><span class="line"><span class="comment">//添加图书</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Book b)</span></span>;</span><br><span class="line"><span class="comment">//根据图书name 来删除指定图书</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">deleteByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//打印出所有的图书信息</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">outputAllBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 定义 数组图书管理业务实现类(ArrayBookBiz) </span><br><span class="line">实现 IBookBiz接口，</span><br><span class="line">实现所有方法,</span><br><span class="line">提示，给出如下属性</span><br><span class="line">属性:</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//代表有效图书数量</span></span><br><span class="line"><span class="keyword">private</span> Book[] books = <span class="keyword">new</span> Book[CAPACITY];</span><br><span class="line">方法：</span><br><span class="line">  就是实现接口中的所有方法</span><br><span class="line"></span><br><span class="line">最后，写测试类，测试这三个方法.</span><br></pre></td></tr></table></figure></li><li><p>接口练习题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">接口更重要的作用：作为模块与模块之间一个协议，软件生产一直希望能够像硬件生产一样：主板可由一个厂家生产，显卡可由另一个厂家生产，用户只需要将显卡插到主板上的显卡插槽上，便可以协同工作了。（插槽——主板、显卡的标准接口已经确定，插槽就是接口）。显卡厂商去实现接口中所暴露出来的方法。主板只需要利用显卡的插槽去获取（调用）显卡的功能。</span><br><span class="line"><span class="number">1</span>、定义一个显卡接口VideoCard，此接口中有抽象方法：</span><br><span class="line"><span class="number">1</span>）videoRunning()：显示显卡运行信息 ;</span><br><span class="line"><span class="number">2</span>）videoClosing()：显示显卡停止工作时的信息;</span><br><span class="line"><span class="number">2</span>、定义一个芯片接口Cpu,此接口中有抽象方法：</span><br><span class="line"><span class="number">1</span>）cpuRunning()：显示显卡运行信息 ;</span><br><span class="line"><span class="number">2</span>）cpuClosing()：显示显卡停止工作时的信息;</span><br><span class="line"><span class="number">3</span>、定义类IntelCpu：实现Cpu接口的全部功能，其中包括：</span><br><span class="line"><span class="number">1</span>）无参构造方法：显示：” Make an Intel<span class="string">&#x27;s CPU”.</span></span><br><span class="line"><span class="string">2）实现Cpu接口的所有方法</span></span><br><span class="line"><span class="string">4、定义类DmengVideoCard：实现VideoCard接口的全部功能，其中包括：</span></span><br><span class="line"><span class="string">1）无参构造方法：显示：”Make a Dmeng&#x27;</span>s VideoCard”.</span><br><span class="line"><span class="number">2</span>）实现VideoCard接口的所有方法.</span><br><span class="line"><span class="number">5</span>、定义类Mainboard</span><br><span class="line"><span class="number">1</span>）创建有参构造体，传入显卡和芯片</span><br><span class="line"><span class="number">2</span>）run():显示主板运行信息</span><br><span class="line"><span class="number">3</span>）close():显示主板停止信息</span><br><span class="line"><span class="number">6</span>、定义一个Computer类，包含主函数main(),组装一台电脑，测试接口的应用，其中main()方法包括：</span><br><span class="line"><span class="number">1</span>）买一块Dmeng公司的显卡</span><br><span class="line"><span class="number">2</span>）买一块Intel公司的芯片</span><br><span class="line"><span class="number">3</span>）买一块主板:插上显卡、芯片</span><br><span class="line"><span class="number">4</span>）组装好后，开机运行显示显卡、芯片、主板等开机信息。</span><br><span class="line"><span class="number">5</span>）关机信息显示</span><br><span class="line"><span class="number">6</span>）创建openPC方法，打开电脑。</span><br><span class="line"><span class="number">7</span>）创建closePC方法，关闭电脑。</span><br></pre></td></tr></table></figure></li><li><p>预习题 - <strong>static关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1.</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cygnus</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">9</span>;  </span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> value = <span class="number">69</span>; </span><br><span class="line">           System.out.println(<span class="keyword">this</span>.value);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">           <span class="keyword">new</span> Cygnus().printValue();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   这个程序会有下面哪种结果？</span><br><span class="line">   A. 编译错误</span><br><span class="line">   B. 打印<span class="number">9</span></span><br><span class="line">   C. 打印<span class="number">69</span></span><br><span class="line">   D. 运行时抛出异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">2.</span> 写出以下程序的输出结果</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;base static&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;base constructor&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;test static&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">           System.out.println(<span class="string">&quot;test constructor&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">new</span> Test();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">3.</span> 写出以下程序的输出结果</span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;test static 1&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;test static 2&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">4.</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> x,y;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      x--;</span><br><span class="line">      myMethod( );</span><br><span class="line">      System.out.println(x+y+ ++x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">( )</span></span>&#123;</span><br><span class="line">     y=x++ + ++x;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   A.编译错误</span><br><span class="line">   B.输出：<span class="number">1</span></span><br><span class="line">   C.输出：<span class="number">2</span></span><br><span class="line">   D.输出：<span class="number">3</span></span><br><span class="line">   E.输出：<span class="number">7</span></span><br><span class="line">   F.输出：<span class="number">8</span></span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">5.</span> 阅读下列程序，选择哪一个是正确的输出结果 </span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;I’m A class &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;static A&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;I’m B class&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;static B&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="keyword">new</span> HelloB();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   A.<span class="keyword">static</span> A I’m A <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">B</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">   <span class="title">B</span>.<span class="title">I</span>’<span class="title">m</span> <span class="title">A</span> <span class="title">class</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span> <span class="title">static</span> <span class="title">A</span> <span class="title">static</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">   <span class="title">C</span>.<span class="title">static</span> <span class="title">A</span> <span class="title">static</span> <span class="title">B</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">A</span> <span class="title">class</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">   <span class="title">D</span>.<span class="title">I</span>’<span class="title">m</span> <span class="title">A</span> <span class="title">class</span> <span class="title">static</span> <span class="title">A</span> <span class="title">I</span>’<span class="title">m</span> <span class="title">B</span> <span class="title">class</span> <span class="title">static</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    ---------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="class">   6. 以下代码的输出结果是？</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> B t1 = <span class="keyword">new</span> B();</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> B t2 = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;构造块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态块&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           B t = <span class="keyword">new</span> B();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   A.静态块 构造块 构造块 构造块</span><br><span class="line">   B.构造块 静态块 构造块 构造块</span><br><span class="line">   C.构造块 构造块 静态块 构造块</span><br><span class="line">   D.构造块 构造块 构造块 静态块</span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">7.</span> 下面代码在main方法代码后可以正常使用的是（ ）</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">       <span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">           Test t = <span class="keyword">new</span> Test();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   A.t.a</span><br><span class="line">   B.<span class="keyword">this</span>.c</span><br><span class="line">   C.Test.b</span><br><span class="line">   D.Test.c</span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">8.</span> 下列程序执行后结果为( )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a - b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a + b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       A a = <span class="keyword">new</span> B();</span><br><span class="line">       B b = <span class="keyword">new</span> B();</span><br><span class="line">       System.out.println(<span class="string">&quot;Result=&quot;</span> + a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;Result=&quot;</span> + b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   A.Result=150Result=<span class="number">150</span></span><br><span class="line">   B.Result=100Result=<span class="number">100</span></span><br><span class="line">   C.Result=100Result=<span class="number">150</span></span><br><span class="line">   D.Result=150Result=<span class="number">100</span></span><br><span class="line">    ---------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">9.</span> 以下代码执行后输出结果为（ ）</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;blockA&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;blockB&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   A.blockAblockBblockA</span><br><span class="line">   B.blockAblockAblockB</span><br><span class="line">   C.blockBblockBblockA</span><br><span class="line">   D.blockBblockAblockB</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day06</title>
    <link href="http://example.com/2021/07/20/day06/"/>
    <id>http://example.com/2021/07/20/day06/</id>
    <published>2021-07-20T10:02:10.000Z</published>
    <updated>2022-01-07T06:45:51.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OO练习"><a href="#OO练习" class="headerlink" title="OO练习"></a>OO练习</h1><h2 id="业务类和实体类合二为一"><a href="#业务类和实体类合二为一" class="headerlink" title="业务类和实体类合二为一"></a>业务类和实体类合二为一</h2><blockquote><p>居然将业务方法放在了实体类中 - <strong>违背了设计原则 - “单一职责原则”.不要给一个类增加太多的负担</strong></p><p>实体类 - 主要是描述对象,数据在内存中的载体 - 注重的应该是数据的<strong>存储</strong></p><p>业务类 - 存放的是业务方法 - 在于<strong>操作</strong>这些数据</p></blockquote><blockquote><p>员工类[编号id,姓名name,工资salary]</p><p>业务方法[crud增删改查]放在实体类中 - 不合理的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>&#123;     </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一个上司拥有多个下属</span></span><br><span class="line">  <span class="comment">//一个下属对应一个上司</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//自关联</span></span><br><span class="line">  <span class="keyword">private</span> Emp[] emps;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造,getter/setter,toString</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//给上司添加一个下属</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmp</span><span class="params">(Emp e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数组的扩容Arrays.copyOf(数组对象,新的长度);</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出下属的个数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmpCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出某个上司所有的下属信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestEmp.java</span></span><br><span class="line">Emp boss = <span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">&quot;boss&quot;</span>,<span class="number">100.0</span>,<span class="keyword">new</span> Emp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">Emp e1 = <span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">&quot;boss&quot;</span>,<span class="number">100.0</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="业务类和实体类分开"><a href="#业务类和实体类分开" class="headerlink" title="业务类和实体类分开"></a>业务类和实体类分开</h2><blockquote><p>业务方法应该专门抽取出来放到一个业务类中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> balance;<span class="comment">//余额</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountBiz</span></span>&#123;</span><br><span class="line">  <span class="comment">//转钱</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">(Account acc1,Account acc2,<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//存钱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="继承Inheritance"><a href="#继承Inheritance" class="headerlink" title="继承Inheritance"></a>继承Inheritance</h1><blockquote><p>将多个具有共同特点的对象抽象出一个”父类”.</p><p><strong>父类中存储的是各个子类共同的特点[属性]或者功能[方法]</strong></p><p>继承的好处 - 提高了代码的复用性.使用多态的前提,为了代码的可拓展性.</p><p>继承的缺点 - 增加了类与类之间的关系.不太符合软件的设计原则”高内聚,低耦合”</p><p>​                      低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 没有关系</p><p>​                      高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强.</p><p>​                      实际开发中,可以采用设计原则**”合成复用原则”** - 来替代继承的使用.</p><p>使用extends关键字来表示某个类继承某个父类</p><p>比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">B 是 A的子类,A是B的父类,基类,超类.</span><br><span class="line"><span class="number">1.</span> A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父类是谁,那么这个类默认继承Object</span><br><span class="line"><span class="number">2.</span> 子类是可以访问到父类中所有的非私有的成员</span><br><span class="line"><span class="number">3.</span> java的类只支持单继承.一个类只能继承一个父类.避免出现网状结构,保证类的层次性.</span><br><span class="line">   java中的接口是支持多重继承.一个接口可以继承多个接口.</span><br><span class="line"><span class="number">4.</span> 继承具有传播性.C extends B    B extends A</span><br><span class="line">   C间接继承于A,C也是可以访问到A中的所有的非私有的成员</span><br><span class="line"><span class="number">5.</span> 不要滥用继承,前提B is A</span><br></pre></td></tr></table></figure></blockquote><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><blockquote><p>必须放在构造方法的首行</p></blockquote><blockquote><ol><li><p>调用父类的构造</p><p>在子类的构造中,如果没有出现任何的super语句.那么系统默认会给定super(); - 调用父类的空参构造</p></li><li><p>当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员]</p></li></ol></blockquote><h1 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态 - polymorphism"></a>多态 - polymorphism</h1><blockquote><p>对象有多种形态.发生前提是具有<strong>继承关系</strong></p></blockquote><blockquote><p>相同的消息可能会送给多个不同的类别之<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1">对象</a>，</p><p>而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作。</p></blockquote><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>进行类型的判断,只有为true的时候,才能够进行类型的转换[强制,向下]</p><p>如果没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常</p></blockquote><h2 id="三种场景应用"><a href="#三种场景应用" class="headerlink" title="三种场景应用"></a>三种场景应用</h2><blockquote><p>面向父类编程</p></blockquote><blockquote><ol><li><p>对象的编译时类型写成父类,对象的运行时类型写成子类</p><p><strong>编译时类型 对象名 = new 运行时类型();</strong></p><p>对象的编译时类型决定了对象的访问能力 - “对象名只能访问到编译时类型中定义的成员”</p><p>对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法”</p></li><li><p>方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象</p></li><li><p>方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象  - “简单工厂设计模式”</p></li></ol></blockquote><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><blockquote><p>不可更改,不可变</p></blockquote><blockquote><ol><li>final修饰的变量/属性 - 不能够重新赋值</li><li>final修饰的类 - 不能够被继承</li><li>final修饰的方法不能够被重写.</li></ol></blockquote><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><blockquote><p>访问修饰符 - 决定了这个成员可以在哪里能够被访问.</p></blockquote><table><thead><tr><th></th><th>所有包</th><th>子类[可以不同,同包]</th><th>同包</th><th>本类</th></tr></thead><tbody><tr><td>public 公共的,公开的</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected 受保护的</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>默认的</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>private 私有的</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><blockquote><p><strong>安全级别:private&gt;默认的&gt;protected&gt;public</strong>  </p><p>可见区域:public&gt;protected&gt;默认的&gt;private</p></blockquote><h1 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h1><blockquote><p>方法的重载和方法的重写有什么区别?</p><p>特点:</p><p>发生的前提是要有继承关系</p><ol><li>重写有个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致 - <strong>重构</strong></li><li>子类重写的方法的访问修饰符可以小于或者等于父类</li><li>方法名必须要一样.</li><li>子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法</li><li>参数列表必须要高度保持一致</li></ol></blockquote><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>设计一个形状类Shape,方法:求周长和求面积</span><br><span class="line">  形状类的子类:Rect(矩形),Circle(圆形)</span><br><span class="line">  Rect类的子类:Square(正方形)</span><br><span class="line">  不同的子类会有不同的计算周长和面积的方法</span><br><span class="line">  创建三个不同的形状对象</span><br><span class="line">  分别打印出每个对象的周长和面积</span><br><span class="line">  [girth() area() -&gt; 放在父类]</span><br><span class="line">  [每个子类需要重写这些方法!] - 不要想太多应用场景,语法!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>某公司的雇员分为以下若干类：</span><br><span class="line">Employee：这是所有员工总的父类，</span><br><span class="line">属性：员工的姓名,员工的生日Date。</span><br><span class="line">方法：getSalary(<span class="keyword">int</span> month) </span><br><span class="line">根据参数月份来确定工资，</span><br><span class="line">如果该月员工过生日，则公司会额外奖励<span class="number">100</span>元。</span><br><span class="line"></span><br><span class="line">SalariedEmployee：</span><br><span class="line">Employee的子类，拿固定工资的员工。属性：月薪</span><br><span class="line"></span><br><span class="line">HourlyEmployee：</span><br><span class="line">Employee的子类，按小时拿工资的员工，</span><br><span class="line">属性：每小时的工资、每月工作的小时数</span><br><span class="line">每月工作超出<span class="number">160</span>小时的部分按照<span class="number">1.5</span>倍工资发放。</span><br><span class="line"></span><br><span class="line">SalesEmployee：</span><br><span class="line">Employee的子类，销售人员，工资由月销售额和提成率决定。</span><br><span class="line">属性：月销售额、提成率</span><br><span class="line"></span><br><span class="line">BasedPlusSalesEmployee：</span><br><span class="line">SalesEmployee的子类，有固定底薪的销售人员，</span><br><span class="line">工资由底薪加上销售提成部分。属性：底薪。</span><br><span class="line"></span><br><span class="line">写一个函数，打印出某月每个员工的工资数额。</span><br><span class="line"></span><br><span class="line">注意：要求把每个类都做成完全封装，不允许非私有化属性。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day05</title>
    <link href="http://example.com/2021/07/19/day05/"/>
    <id>http://example.com/2021/07/19/day05/</id>
    <published>2021-07-19T10:02:10.000Z</published>
    <updated>2022-01-07T06:47:24.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><blockquote><p>api:<strong>java.util</strong>.Date[C] - 使用这个类之前,必须要导包import</p><p>这是java中提供的关于日期的处理,内置的对象类型.它本身是一个过时的类</p><p>里面提供了很多已经过时的方法.</p><p>目标:掌握这个类中提供的方法</p></blockquote><h2 id="api手册"><a href="#api手册" class="headerlink" title="api手册"></a>api手册</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p>作用:创建这个类的对象的方式</p></blockquote><blockquote><ol><li><p>观察提供的方法是静态的方法还是非静态的方法. - <strong>api手册方法摘要</strong></p><p>Date类中提供的方法几乎都是非静态的方法 - <strong>考虑如何构建这个对象?</strong></p></li><li><p>如何构建对象 - api手册的构造方法[面向对象]</p><p>简单理解构造方法 - “方法”,构造方法通过new关键字调用</p><ul><li><p><strong>Date();//Date d = new Date();//获取当前系统时间</strong></p></li><li><p>Date(int year, int month, int date);//已经过时的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">2021</span>-<span class="number">1900</span>,<span class="number">6</span>,<span class="number">21</span>);</span><br><span class="line">year - <span class="number">1900</span> =&gt; 实际的year</span><br><span class="line">month的范围是[<span class="number">0</span>,<span class="number">11</span>]</span><br></pre></td></tr></table></figure></li><li><p>Date(long date);//根据一个毫秒数来构建一个指定的日期类型 - 重新设置一个新的Date</p><p>Java中日期类型Date对象是不支持运算的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算三天之后的此时此刻</span><br><span class="line"><span class="keyword">long</span> afterThreeTime = <span class="keyword">new</span> Date().getTime()+<span class="number">3L</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">Date afterThreeDate = <span class="keyword">new</span> Date(afterThreeTime);</span><br><span class="line">System.out.println(afterThreeDate);</span><br></pre></td></tr></table></figure></li></ul></li></ol></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote><p>非静态方法 - 日期对象进行调用.</p><ul><li><p>long getTime();//返回当前日期的毫秒数的表现形式 - 获取当前系统时间的毫秒数.距离1970年1月1日</p><p>1970年是计算机的元年</p></li><li><p>get/set方法 - 过时的</p><ol><li>void setYear(int year);// year-1900</li><li>void setMonth(int month);//month的范围[0,11]</li><li>void setDate(int date);//设置今天是几号</li><li>void setHours(int hours);//设置小时</li><li>void setMinutes(int minutes);//设置分钟</li><li>void setSeconds(int seconds);//设置秒</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day05;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: java.util.Date 日期处理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/21 8:43 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建一个日期对象</span></span><br><span class="line">        <span class="comment">//alter + enter 快速导包</span></span><br><span class="line">        Date d = <span class="keyword">new</span> Date();<span class="comment">//空参构造方法</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//为什么此处输出的不是内存地址??? - OO - toString();</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//Wed Jul 21 08:45:03 CST 2021</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//2. 重载的构造方法 - 过时的构造</span></span><br><span class="line">        Date d2 = <span class="keyword">new</span> Date(<span class="number">2021</span>-<span class="number">1900</span>,<span class="number">6</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//3. 利用毫秒数来构建一个Date对象</span></span><br><span class="line">        Date d3 = <span class="keyword">new</span> Date(<span class="number">1626829161216L</span>);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;====常用方法===&quot;</span>);</span><br><span class="line">        <span class="comment">//4.. 获取当前日期的毫秒数</span></span><br><span class="line">        <span class="comment">//1秒 = 1000毫秒</span></span><br><span class="line">        <span class="keyword">long</span> nowTime = d.getTime();</span><br><span class="line">        System.out.println(nowTime);<span class="comment">//1626828910303</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//练习-计算三天之后的此时此刻</span></span><br><span class="line">        <span class="keyword">long</span> afterThreeTime = <span class="keyword">new</span> Date().getTime()+<span class="number">3L</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">        Date afterThreeDate = <span class="keyword">new</span> Date(afterThreeTime);</span><br><span class="line">        System.out.println(afterThreeDate);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;=====set设置/get获取======&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">      </span><br><span class="line">        now.setYear(<span class="number">2021</span>-<span class="number">1900</span>);<span class="comment">//设置年份</span></span><br><span class="line">        now.setMonth(<span class="number">6</span>);<span class="comment">//设置月份[0,11]</span></span><br><span class="line">        now.setDate(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;now:&quot;</span>+now);</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">int</span> year = now.getYear()+<span class="number">1900</span>;<span class="comment">//获取年份</span></span><br><span class="line">        System.out.println(<span class="string">&quot;year:&quot;</span>+year);</span><br><span class="line">              </span><br><span class="line">        System.out.println(<span class="string">&quot;month:&quot;</span>+now.getMonth());<span class="comment">//获取月份</span></span><br><span class="line">              </span><br><span class="line">        System.out.println(<span class="string">&quot;date:&quot;</span>+now.getDate());<span class="comment">//获取几号</span></span><br><span class="line">              </span><br><span class="line">        System.out.println(<span class="string">&quot;day:&quot;</span>+now.getDay()); <span class="comment">// 周几,周1-周6[1-6],周日是0</span></span><br><span class="line">              </span><br><span class="line">        System.out.println(<span class="string">&quot;hours:&quot;</span>+now.getHours());</span><br><span class="line">              </span><br><span class="line">        <span class="comment">//void setTime(long date);</span></span><br><span class="line">        <span class="comment">//构造 Date(long time);</span></span><br><span class="line">        Date dd = <span class="keyword">new</span> Date();</span><br><span class="line">        dd.setTime(<span class="number">1726830007794L</span>);</span><br><span class="line">        System.out.println(dd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><blockquote><p>日历类 - 超纲的内容</p><p>api - java.util.Calendar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span></span></span><br><span class="line"><span class="class"><span class="title">abstract</span>[修饰符]修饰的类是一个抽象类 - 不能够被<span class="title">new</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">构建<span class="title">Calendar</span>对象 - <span class="title">Calendar</span> <span class="title">cal</span> </span>= <span class="keyword">new</span> Calendar();<span class="comment">//error</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="api手册-1"><a href="#api手册-1" class="headerlink" title="api手册"></a>api手册</h2><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote><ol><li><p>static Calendar getInstance();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前系统的日历对象</span></span><br><span class="line">Calendar cal = Calendar.getInstance();<span class="comment">//底层使用到了简单工厂的设计模式[不需要了解暂时]</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>关于设置日历字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span><span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date)</span></span></span><br><span class="line"><span class="function">设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span><span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function">设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span><span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date, <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function">设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date -&gt; <span class="function">Calendar </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>单独针对单个字段一一进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">只要看到field</span><br><span class="line"><span class="comment">//公开的静态的常量属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> YEAR = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>关于获取日历字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">getTime</span><span class="params">()</span></span>;<span class="comment">//获取日历信息中关于日期部分的信息 - Calendar转成Date类型</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span>;<span class="comment">//关于获取日历指定字段的值</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><ol><li><p>毫秒数 -&gt; Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. java.util.Date中提供了构造方法Date(<span class="keyword">long</span> time);</span><br><span class="line">b. 上述类<span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Date -&gt; 毫秒数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该类中<span class="function"><span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Calendar -&gt; Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar类中提供了<span class="function">Date <span class="title">getTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Date -&gt; Calendar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar类中<span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 日历类java.util.Calendar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/21 9:30 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//超纲 - abstract是修饰符 - 修饰类 - 抽象的类</span></span><br><span class="line">        <span class="comment">//特点 - 不能够被new[不能够被实例化,具体化]</span></span><br><span class="line">        <span class="comment">//Calendar cal = new Calendar();//error</span></span><br><span class="line"></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//System.out.println(cal);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统一设置值</span></span><br><span class="line">        cal.set(<span class="number">2020</span>,<span class="number">6</span>,<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Calendar -&gt; Date</span></span><br><span class="line">        Date now = cal.getTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date -&gt; Calendar</span></span><br><span class="line">        Date d = <span class="keyword">new</span> Date(<span class="number">17818237347L</span>);</span><br><span class="line">        cal.setTime(d);</span><br><span class="line"></span><br><span class="line">        System.out.println(cal.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====单个字段一一赋值====&quot;</span>);</span><br><span class="line">        <span class="comment">//void set(int field,int value);</span></span><br><span class="line"></span><br><span class="line">        Calendar cd = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过字面量直接进行设置 - 可读性比较差</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Calendar中提供的一些公开的静态的常量属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//常量的好处 - 提供程序的可读性</span></span><br><span class="line">        cd.set(Calendar.YEAR,<span class="number">2021</span>);</span><br><span class="line">        cd.set(Calendar.MONTH,<span class="number">6</span>);</span><br><span class="line">        cd.set(Calendar.DAY_OF_MONTH,<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cd.getTime());<span class="comment">//Calendar-&gt;Date</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> year = cd.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = cd.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = cd.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(<span class="string">&quot;year:&quot;</span>+year);</span><br><span class="line">        System.out.println(<span class="string">&quot;month:&quot;</span>+month);</span><br><span class="line">        System.out.println(<span class="string">&quot;day:&quot;</span>+day);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取周几</span></span><br><span class="line">        <span class="keyword">int</span> week = cd.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        System.out.println(<span class="string">&quot;week:&quot;</span>+week);<span class="comment">//周日~周六,[1~7]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取键盘键盘输入"><a href="#获取键盘键盘输入" class="headerlink" title="获取键盘键盘输入"></a>获取键盘键盘输入</h1><blockquote><ol><li><p>java.util.Scanner键盘类</p></li><li><p>如何构建这个Scanner对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure></li><li><p>方法</p><p>3-1. int nextInt();//只能获取整数</p><p>3-2. double nextDouble();//获取小数</p><p>3-3. String nextLine();//获取字符串</p></li><li><p>注意点:nextLine不要和nextInt或者nextDouble混用.</p></li></ol></blockquote><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote><ol><li><p>java语言属于面向对象的语言</p></li><li><p>面向对象本身不是一门具体的技术,符合人类思维的思想.</p></li><li><p>宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析,</p><p>接着面向对象的设计,最终进行面向对象的编程.</p></li><li><p><strong>对象是数据在内存中的”载体”</strong></p></li></ol></blockquote><h2 id="重新认识类和对象"><a href="#重新认识类和对象" class="headerlink" title="重新认识类和对象"></a>重新认识类和对象</h2><blockquote><ol><li><p>类是抽象的概念,对象是具体的概念</p></li><li><p>类是构建对象的蓝图/模板,对象是类的具体的实例化[表现]</p></li><li><p>类是用来描述对象的.</p></li><li><p>比如:</p><p>​    类:水果    交通工具   学生</p><p>对象:榴莲    飞机           小三</p></li><li><p>比如:</p><table><thead><tr><th>id</th><th>username</th><th>age</th></tr></thead><tbody><tr><td>100</td><td>admin</td><td>18</td></tr><tr><td>101</td><td>tom</td><td>17</td></tr></tbody></table></li></ol></blockquote><h2 id="面向对象的思想"><a href="#面向对象的思想" class="headerlink" title="面向对象的思想"></a>面向对象的思想</h2><blockquote><p>核心:”一切皆对象”</p><p>①分析出系统中业务的关键对象 - <strong>“找对象”</strong> - 未来页面上显示的数据</p><p>②找出对象的**”属性”** - “对象拥有什么”</p><p>③分析出对象的”方法” - “对象可以干什么,对象的功能”</p><p>④找出对象与对象之间的关系.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="number">1</span> - 一个丈夫对应一个妻子,一个妻子对应一个丈夫.</span><br><span class="line">  </span><br><span class="line"><span class="number">1</span>:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - <span class="number">70</span>%</span><br><span class="line"></span><br><span class="line">N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择.</span><br><span class="line">  </span><br><span class="line">自关联 - 自己关联自己.</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法.</p></blockquote><blockquote><p>“相亲业务” - </p><ol><li>媒婆帮你找一个”对象”</li><li>你要查看”对象”的属性</li><li>询问”对象”的功能</li><li>分析你和”对象”是否来道🌩</li><li>考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现!</li></ol></blockquote><h2 id="面向过程的思想"><a href="#面向过程的思想" class="headerlink" title="面向过程的思想"></a>面向过程的思想</h2><blockquote><p>C是典型的面向过程的思想</p><p>①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现.</p></blockquote><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><blockquote><p>实体类就是用来描述对象的.</p><p>实体类中包含<strong>属性,构造方法,getter/setter方法,toString方法.</strong></p></blockquote><h2 id="如何定义属性"><a href="#如何定义属性" class="headerlink" title="如何定义属性"></a>如何定义属性</h2><blockquote><p>语法:</p><p>修饰符 数据类型 属性名 [=初始值];</p></blockquote><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><blockquote><p>public 公开的</p><p>private 私有的</p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><ol><li>八种基本数据类型</li><li>内置对象类型以及自定义对象类型.</li></ol></blockquote><h3 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h3><blockquote><p>参考变量的命名 - “小驼峰”</p></blockquote><h2 id="三大特征-封装性"><a href="#三大特征-封装性" class="headerlink" title="三大特征 - 封装性"></a>三大特征 - 封装性</h2><blockquote><p>封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制</p></blockquote><blockquote><ol><li><p>属性私有化</p></li><li><p>提供getter/setter方法</p><p>setter方法 - set属性名[首字母变大写] - 推荐的命名规则</p><p>setter方法这种设置值的好处</p><p>2-1. setter方法中是可以进行参数有效性判断的.</p><p>2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性”</p><p>2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">           </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">           </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">           </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> total;</span><br><span class="line">           </span><br><span class="line">  <span class="comment">//getter/setter - 提供好了</span></span><br><span class="line">           </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="keyword">this</span>.price * <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line">Orders o = <span class="keyword">new</span> Orders();</span><br><span class="line">o.setPrice(<span class="number">100.0</span>);</span><br><span class="line">o.setCount(<span class="number">10</span>);</span><br><span class="line">         </span><br><span class="line"><span class="comment">//o.setTotal(o.getPrice()*o.getCount());</span></span><br><span class="line">System.out.println(o.getTotal());</span><br><span class="line">         </span><br></pre></td></tr></table></figure><p>2-4. 并不是所有的属性都需要对外进行公开的.</p></li></ol></blockquote><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><blockquote><ol><li><p>作用1 - 当前对象,区分方法中参数和实体类中的定义的属性 - 当两者同名的时候.</p></li><li><p>调用当前实体类中已经存在的另外一个构造方法.</p><p>2-1. this()调动空参</p><p>2-2. this(参数1,参数2) - 带参构造</p><p>2-3. this调用构造的语句一定要在构造体的首行</p></li><li><p><strong>this和super语句的区别</strong></p></li></ol></blockquote><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><blockquote><ol><li><p>当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的</p></li><li><p>当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>java.lang.Object - 它是所有的类的根类,基类,超类,父类.</p><p>如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类</p><p>“User类是Object类的儿子” - 规定 - “<strong>子类可以调用父类中所有的公开的成员</strong>“</p></li></ol></blockquote><blockquote><ol start="4"><li><p>Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求</p><p>所以需要在实体类中重新重写这个toString方法.</p></li><li><p>当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写</p><p>之后的toString方法.</p></li></ol></blockquote><h1 id="构造方法-constructor"><a href="#构造方法-constructor" class="headerlink" title="构造方法-constructor"></a>构造方法-constructor</h1><blockquote><p>作用:创建对象的时候调用构造方法,通过new关键字</p><p>可以在创建对象的同时进行赋值操作,赋值的方式只有1次,setter赋值,可以多次赋值</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote><ol><li><p>当实体类中如果没有手动提供任何一个构造方法的时候,那么系统会自动分配一个</p><p>空参构造.如果实体类中一旦手动提供了带参构造之后,那么系统将不会再分配一个空参构造了.</p></li><li><p>定义的时候,不需要返回类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名([参数列表])&#123;</span><br><span class="line">  <span class="comment">//构造体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造允许重载的</p></li><li><p>实体类中推荐只用提供空参,全参</p></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day04</title>
    <link href="http://example.com/2021/07/18/day04/"/>
    <id>http://example.com/2021/07/18/day04/</id>
    <published>2021-07-18T10:02:10.000Z</published>
    <updated>2022-01-07T06:45:11.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><blockquote><ol><li>方法体中调用方法自己本身</li><li>递归算法的方法体中一定要出现递归的出口,否则会抛出java.lang.StackOverflowError - 堆栈溢出错误</li></ol></blockquote><blockquote><p>使用场景:适合解决<strong>大量的</strong>,<strong>重复性的</strong>业务题</p><p>缺点:性能比较低,将每次计算的结果都会保存在内存中.</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><blockquote><ol><li><p>求某个数的阶乘 ※</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jie</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果没有出口 - java.lang.StackOverflowError 堆栈溢出错误</span></span><br><span class="line">  <span class="comment">//1. 第一个位置都是1</span></span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 方法体中调用自己</span></span><br><span class="line">  <span class="keyword">return</span> n*jie(n-<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//     6*jie(5)</span></span><br><span class="line">  <span class="comment">//     6*5*4*3*2*1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列 ※</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列</span></span><br><span class="line"><span class="comment">//1 1 2 3 5 8 13 21 34 55 ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fei</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span> || n==<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fei(n-<span class="number">1</span>) + fei(n-<span class="number">2</span>);</span><br><span class="line">  <span class="comment">//n=4</span></span><br><span class="line">  <span class="comment">//fei(3)+fei(2)</span></span><br><span class="line">  <span class="comment">//fei(2) + fei(1) + fei(2)=3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求最大公约数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commonDivisor</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(m % n ==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> commonDivisor(n,m%n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求杨辉三角某行某列的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    1</span></span><br><span class="line"><span class="comment">     *    1 1</span></span><br><span class="line"><span class="comment">     *    1 2 1</span></span><br><span class="line"><span class="comment">     *    1 3 3 1</span></span><br><span class="line"><span class="comment">     *    1 4 6 4 1</span></span><br><span class="line"><span class="comment">     *    1 5 10 10 5 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 纵坐标 行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 横坐标 列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yang</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y==<span class="number">0</span> || x==y)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> yang(x-<span class="number">1</span>,y-<span class="number">1</span>) + yang(x-<span class="number">1</span>,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>打印直角三角形杨辉三角</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印直角三角形.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 打印的杨辉三角的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printYang</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=i ; j++) &#123;</span><br><span class="line">      System.out.print(yang(i,j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><blockquote><ol><li><p>数据类型 变量 = 初始化;</p></li><li><p>数据类型 - 八种基本数据类型以及对象类型</p></li><li><p>数组本身就是属于对象类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//arr的数据类型int[],整数型数组,int型数组</span></span><br></pre></td></tr></table></figure></li><li><p>元素类型[] 变量名 = new 元素类型[数组长度];</p></li><li><p>~~~java<br>int[][] 变量名 = new int[rows][cols]<br>元素类型决定了数组中可以存放的数据的类型<br>二维数组中的每个元素就是一维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 定义一个3行2列的int型二维数组</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br><span class="line">   int[][] arr = new int[3][2];</span><br><span class="line">   int arr[][] = new int[3][2];</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><blockquote><ol><li><p>通过下标一一赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p>定义二维数组的同时进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>先定义一个数组,然后是一行一行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//error</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//ok</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个不规则的二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">列可以省略不写</span><br><span class="line"><span class="keyword">int</span>[][] arr4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr4[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">arr4[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">arr4[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><blockquote><ol><li><p>通过下标一一输出</p></li><li><p>通过单层for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(Arrays.toString(arr[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双层for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="comment">//int[] temp = arr[i];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    System.out.print(arr[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>java.util.Arrays工具类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToString(arr));</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>增强for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 变量:数组对象名)&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : arr) &#123;</span><br><span class="line">   <span class="comment">// System.out.println(ints);</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> r : ints) &#123;</span><br><span class="line">     System.out.print(r+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">String[][] arr = <span class="keyword">new</span> String[<span class="number">4</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;白&quot;</span>,<span class="string">&quot;日&quot;</span>,<span class="string">&quot;依&quot;</span>,<span class="string">&quot;山&quot;</span>,<span class="string">&quot;尽&quot;</span>,<span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;黄&quot;</span>,<span class="string">&quot;河&quot;</span>,<span class="string">&quot;入&quot;</span>,<span class="string">&quot;海&quot;</span>,<span class="string">&quot;流&quot;</span>,<span class="string">&quot;.&quot;</span>&#125;;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;欲&quot;</span>,<span class="string">&quot;穷&quot;</span>,<span class="string">&quot;千&quot;</span>,<span class="string">&quot;里&quot;</span>,<span class="string">&quot;目&quot;</span>,<span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line">arr[<span class="number">3</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;更&quot;</span>,<span class="string">&quot;上&quot;</span>,<span class="string">&quot;一&quot;</span>,<span class="string">&quot;层&quot;</span>,<span class="string">&quot;楼&quot;</span>,<span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tech.aistar.day04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 古诗词 横变竖</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/20 3:06 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoemsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[][] arr = <span class="keyword">new</span> String[<span class="number">4</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">        arr[<span class="number">0</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;白&quot;</span>,<span class="string">&quot;日&quot;</span>,<span class="string">&quot;依&quot;</span>,<span class="string">&quot;山&quot;</span>,<span class="string">&quot;尽&quot;</span>,<span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;黄&quot;</span>,<span class="string">&quot;河&quot;</span>,<span class="string">&quot;入&quot;</span>,<span class="string">&quot;海&quot;</span>,<span class="string">&quot;流&quot;</span>,<span class="string">&quot;.&quot;</span>&#125;;</span><br><span class="line">        arr[<span class="number">2</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;欲&quot;</span>,<span class="string">&quot;穷&quot;</span>,<span class="string">&quot;千&quot;</span>,<span class="string">&quot;里&quot;</span>,<span class="string">&quot;目&quot;</span>,<span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line">        arr[<span class="number">3</span>]=<span class="keyword">new</span> String[]&#123;<span class="string">&quot;更&quot;</span>,<span class="string">&quot;上&quot;</span>,<span class="string">&quot;一&quot;</span>,<span class="string">&quot;层&quot;</span>,<span class="string">&quot;楼&quot;</span>,<span class="string">&quot;,&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        change(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String[][] arr)</span></span>&#123;</span><br><span class="line">        String[][] temp = <span class="keyword">new</span> String[<span class="number">6</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                temp[j][i] = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp[i].length; j++) &#123;</span><br><span class="line">                System.out.print(temp[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><blockquote><p><a href="http://xzc.cn/EhC5y656uG">http://xzc.cn/EhC5y656uG</a>    A    B      C</p><ol><li><p>二维数组输出直角的杨辉三角</p></li><li><p><strong>将1~5之间的随机整数,存储到一个长度为15的一维数组中.写一段程序.</strong></p><p><strong>统计每个随机数在这个数组中出现的次数.并且根据出现的次数进行降序排列.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr -&gt; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1.</span>..&#125;</span><br><span class="line">数组去重 - 个数temp -&gt; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">two[i] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;temp[i],count&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] two = <span class="keyword">new</span> <span class="keyword">int</span>[?][<span class="number">2</span>];</span><br><span class="line">   </span><br><span class="line">排序</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day03</title>
    <link href="http://example.com/2021/07/17/day03/"/>
    <id>http://example.com/2021/07/17/day03/</id>
    <published>2021-07-17T10:02:10.000Z</published>
    <updated>2022-01-07T07:27:19.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法的重载-overload"><a href="#方法的重载-overload" class="headerlink" title="方法的重载(@overload)"></a>方法的重载(@overload)</h1><blockquote><p>前提:</p><ol><li>重载的方法是存在于同一个类中 [前提]</li><li>重载的方法的方法名必须相同</li><li>重载的方法的参数列表必须不相同</li><li>重载的方法的返回类型可以不一样,可以一样</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add -&gt; 100&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>优点就是简化api - 方便调用的.</strong></p></blockquote><h1 id="学会使用api"><a href="#学会使用api" class="headerlink" title="学会使用api"></a>学会使用api</h1><blockquote><p>通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: java.lang.Math</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/19 8:59 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//绝对值</span></span><br><span class="line">        <span class="keyword">int</span> n = Math.abs(-<span class="number">10</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求随机数 - 伪随机的</span></span><br><span class="line">        <span class="comment">//static double random();//[0.0,1.0)之间的随机小数</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1,100]之间随机的整数</span></span><br><span class="line">        <span class="keyword">int</span> result = (<span class="keyword">int</span>) (Math.random()*<span class="number">100</span>+<span class="number">1</span>);<span class="comment">//[1,100]</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3,5]之间的随机整数</span></span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>) (Math.random()*<span class="number">3</span>+<span class="number">3</span>);</span><br><span class="line">        System.out.println(m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求俩个数中的最大值/最小值</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">10</span>,<span class="number">20</span>));<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//笔试填空题 -</span></span><br><span class="line">        <span class="comment">//返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。</span></span><br><span class="line">        <span class="comment">//floor方法.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.5</span>));<span class="comment">//3.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.0</span>));<span class="comment">//4.0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">3.5</span>));<span class="comment">//-4.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回参数中最接近的 long ，其中 long四舍五入为正无穷大。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Math.floor(a + 1/2)</span></span><br><span class="line">        System.out.println(Math.round(-<span class="number">3.5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开根</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">9</span>));<span class="comment">//3.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//次方</span></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h2><blockquote><p>三目运算符</p><ol><li><p>条件表达式 ? result1 : result2</p><p>表达式为true,结果就是result1,否则结果是result2</p></li><li><p>支持无限嵌套的 - 但是不推荐,可读性差</p><p>m ? (表达式?result1:result2):result2</p></li></ol></blockquote><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else.."></a>if…else..</h2><blockquote><ol><li><p>if语句单独使用场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;<span class="comment">//成立</span></span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>{}可以省略的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">  <span class="comment">//code...</span></span><br><span class="line">  </span><br><span class="line">如果<span class="keyword">if</span>&#123;&#125;中的代码只有<span class="number">1</span>行,那么&#123;&#125;可以省略,但是一定要缩进</span><br></pre></td></tr></table></figure></li><li><p>if…else…使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//条件成立</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//条件不成立</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果语句仍然只有一行,&#123;&#125;还是可以省略的</span></span><br><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">//code..</span></span><br></pre></td></tr></table></figure></li><li><p>多条件分支if…else if…else..if …  else…</p><p><strong>注意条件是互斥的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//条件成立</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//条件不成立</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//code..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>if..else语句可以无限嵌套使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//条件成立</span></span><br><span class="line">  <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">                   </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//条件不成立</span></span><br><span class="line">  <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//条件成立</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">      <span class="comment">//条件不成立</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">      <span class="comment">//code</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//code..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//code..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><blockquote><ol><li><p>买奶茶,每第二杯半价,单价是10元.求总价.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span> <span class="number">10</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>求某年某月最大天数</li></ol></blockquote><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch..case"></a>switch..case</h2><blockquote><p>没有if..else if..else灵活</p><p>语法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)/ /<span class="keyword">byte</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">char</span> String <span class="class"><span class="keyword">enum</span>[枚举类型]</span></span><br><span class="line"><span class="class">    //包装类型<span class="title">Byte</span> <span class="title">Short</span> <span class="title">Integer</span> <span class="title">Character</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> 值1:</span></span><br><span class="line"><span class="class">    //<span class="title">code</span></span></span><br><span class="line"><span class="class">    [<span class="title">break</span>]</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">    [<span class="keyword">break</span>];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">    [<span class="keyword">break</span>];</span><br><span class="line">    </span><br><span class="line">  [<span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//code..</span></span><br><span class="line">    [<span class="keyword">break</span>];]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当switch括号中的变量能够匹配到某个case后面的值的时候,那么就会进入到对应的case中去执行里面的程序</p></li><li><p>进入到某个case块中执行的过程中,只有遇到break语句才会跳出switch块.如果没有遇到break语句,那么程序会</p><p>自动进入到下一个case块中去执行.</p></li><li><p>default语句可以省略,也是可以随便放的,推荐放在末尾.如果switch括号中的变量没有匹配到任何的case后面的值</p><p>的时候,那么就会进入到default</p></li></ol></blockquote><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><blockquote><ol><li>属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环.</li><li>使用场景:当不知道循环多少次,但是知道循环退出的条件的时候 - 优先选择while循环.</li></ol><p>语法:</p><p>while(条件){</p><p>​    // 循环体…</p><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: while循环</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/19 10:53 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//while可以代替for的使用</span></span><br><span class="line">        <span class="comment">//&#x27;a&#x27;-&#x27;z&#x27;</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(c &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line">        <span class="comment">//&#x27;A&#x27; - &#x27;Z&#x27;</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">65</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;=<span class="number">90</span>)&#123;<span class="comment">//退出的条件</span></span><br><span class="line">            System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1-10</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//死循环...</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//死循环的内部一定要有打破循环的语句 - break</span></span><br><span class="line">            System.out.println(m);</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">10</span>) <span class="comment">// 循环退出的条件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote><ol><li><p>求俩个数的最大公约数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路:<span class="number">20</span> <span class="number">12</span> -&gt; <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">20</span> % <span class="number">12</span> = <span class="number">8</span></span><br><span class="line">    <span class="number">12</span> % <span class="number">8</span> = <span class="number">4</span></span><br><span class="line">    <span class="number">8</span>  % <span class="number">4</span> = <span class="number">0</span>    </span><br></pre></td></tr></table></figure></li><li><p>十进制转换二进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><blockquote><p>属于后置循环</p></blockquote><blockquote><ol><li><p>单层for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(①表达式<span class="number">1</span>;②表达式<span class="number">2</span>;③表达式<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//④循环体</span></span><br><span class="line">&#125;</span><br><span class="line">①表达式<span class="number">1</span> - 循环过程中的变量的初始化操作.比如<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        -  仅仅只会执行<span class="number">1</span>次.</span><br><span class="line">②表达式<span class="number">2</span> - 循环退出的条件.比如 i&lt;=<span class="number">10</span> </span><br><span class="line">         - 至少执行<span class="number">1</span>次</span><br><span class="line">③表达式<span class="number">3</span> - 循环过程中,变量因子的变化.i++</span><br><span class="line">         - 有可能是不执行,可能执行</span><br><span class="line">          </span><br><span class="line">执行顺序①-②[成立]-④-③-②[成立]-④-③.....</span><br></pre></td></tr></table></figure><p><code>怪异的写法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">//死循环 - break打破循环的语句</span></span><br><span class="line">&#125;</span><br><span class="line">三个表达式都是可以任意的省略不写,或者写到其他地方</span><br></pre></td></tr></table></figure><p><code>for循环的复合形态</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(同时定义若干个变量;条件;表达式)&#123;</span><br><span class="line">  <span class="comment">//循环体...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套for循环,嵌套的层数不建议超过三层.嵌套越多,性能越低.</p><p>2-1. 内外层无关 - 里面的for选中的使用可以单独执行.没有使用到外面for的循环的变量因子的.</p><p>2-2. 内外层相关 - 里面的for使用到了外面for循环的变量因子的</p></li><li><p><strong>练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的.</strong></p><p><strong>每打印4个换一行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day03;</span><br><span class="line">            </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示:</span></span><br><span class="line"><span class="comment"> * 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每打印4个换一行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/19 2:26 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForExerciseDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个计数器</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;=<span class="number">4</span> ; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;=<span class="number">4</span>; y++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;=<span class="number">4</span>; z++) &#123;</span><br><span class="line"><span class="comment">//                    System.out.print(x+&quot;&quot;+y+z);</span></span><br><span class="line">                    <span class="keyword">if</span>(x!=y &amp; x!=z &amp; y!=z)&#123;</span><br><span class="line">                        System.out.print(x*<span class="number">100</span>+y*<span class="number">10</span>+z+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                        count++;</span><br><span class="line"><span class="comment">//                        if(count % 4==0)&#123;</span></span><br><span class="line"><span class="comment">//                            System.out.println();</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line">            </span><br><span class="line">                        <span class="keyword">if</span>(count == <span class="number">4</span>)&#123;</span><br><span class="line">                            System.out.println();</span><br><span class="line">                            count = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="do-while"><a href="#do-while" class="headerlink" title="do..while.."></a>do..while..</h2><blockquote><p>属于前置循环 - 无论循环条件是否成立,优先先进入到循环体中执行一次.</p><p>然后再进行判断条件,决定下一次是否再次进入.</p><p>do{</p><p>   //循环体…</p><p>}while(条件);</p></blockquote><h1 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h1><blockquote><ol><li>break可以跳出swtich块</li><li>break可以打破它所在的那一层循环</li></ol></blockquote><h1 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h1><blockquote><p>出现在循环体中</p><p>跳过本轮循环,继续执行下一轮循环.</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><ol><li>数组的诞生 - 为了解决单个变量只能存储单个值的缺点.</li><li>数组本身也是属于数据结构[数组,栈,堆,树[红黑树],链表,图…]</li><li>数组是属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区</li><li>数组在内存中一定是一块连续的空间.</li><li><strong>数组的大小[长度,数组中存放的数据的个数]一旦确定了,不能改变.</strong></li><li>定义数组必不可少的俩个条件 - 元素类型/数组的长度要确定</li><li>数组容器</li></ol></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 元素类型[] 变量名 = <span class="keyword">new</span> 元素类型[size];<span class="comment">//size数组的大小</span></span><br><span class="line"><span class="number">2.</span> 元素类型 变量名[] = <span class="keyword">new</span> 元素类型[size];<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">元素类型就是数据类型[<span class="number">8</span>种基本数据类型,以及对象类型]</span><br><span class="line">作用 - 元素类型决定了这个数组中可以存放的数据的类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr的数据类型是什么?int[] -&gt; 整数型数组</span></span><br><span class="line"><span class="comment">// &quot;定义一个长度为3的int型数组&quot;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><blockquote><p>如果定义了数组,但是没有进行赋值操作,那么系统会默认分配一个默认值</p><p>默认值根据元素类型来决定了.</p><p>byte,short,int,long -&gt; 0</p><p>float,double -&gt; 0.0</p><p>boolean -&gt; false</p><p>char -&gt; 空格</p><p>对象类型 -&gt; null</p></blockquote><blockquote><ol><li><p>先定义数组,然后通过下标一一赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//数组的下标从[0,数组长度-1]范围</span></span><br><span class="line"><span class="comment">//如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>定义数组的同时进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>定义数组的同时进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;3,4,5&#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过普通for去赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">  arr[i] = (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><blockquote><ol><li><p>通过下标一一取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr[下标]);</span><br></pre></td></tr></table></figure></li><li><p>数组提供了属性length - 获取数组的长度</p><p>通过普通for循环进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用jdk5.x提供的增强for循环的语法</p><p><strong>属于只读的for</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(元素类型 元素变量:数组变量名)&#123;</span><br><span class="line">  System.out.println(元素);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e:arr2)&#123;<span class="comment">//此处的e不是代表下标,就是代表真正的元素</span></span><br><span class="line">   System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li>通过java.util.Arrays数组工具类中提供的static String toString(数组对象)来遍历数组</li></ol></blockquote><h2 id="拓展-数组的内存"><a href="#拓展-数组的内存" class="headerlink" title="拓展 - 数组的内存"></a>拓展 - 数组的内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过new关键字在Jvm的堆中开辟新的空间01,用来存储这个对象&#123;10,20,30&#125;</span></span><br><span class="line"><span class="comment">//然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1[存储在栈]</span></span><br><span class="line"><span class="comment">//&quot;结论&quot; - arr1的本质不是对象,只是一个引用变量而已</span></span><br><span class="line"><span class="comment">//&quot;结论&quot; - 引用和对象之间的关系</span></span><br><span class="line"><span class="comment">//        引用变量中存储的就是对象在堆空间中的内存地址</span></span><br><span class="line"><span class="comment">//        &quot;气球理论&quot; - 一个引用变量在同一个时刻,只能指向一个对象</span></span><br><span class="line"><span class="comment">//                 - &quot;一个对象可以在同一个时刻被多个引用指向&quot;</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过new关键字在Jvm的堆中开辟新的空间02,用来存储这个对象&#123;10,20,30&#125;</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr1 = arr2;<span class="comment">//arr1和arr2都是指向第二次创建出来的数组对象</span></span><br><span class="line">  <span class="comment">//原来第一次创建出来的对象就成为内存中的垃圾对象 - GC[垃圾回收线程进行回收,释放内存]</span></span><br><span class="line">  <span class="comment">//&quot;垃圾对象&quot; - 没有任何引用指向的对象</span></span><br></pre></td></tr></table></figure><h2 id="拓展-方法的参数传递方式"><a href="#拓展-方法的参数传递方式" class="headerlink" title="拓展 - 方法的参数传递方式"></a>拓展 - 方法的参数传递方式</h2><blockquote><ol><li>基本类型采用值传递</li><li>对象类型[引用类型]采用地址传递</li></ol></blockquote><blockquote><p>总结:**Java中只有值传递,没有地址传递.**比较特殊的是String类型[虽然是一个对象类型,但是具备基本类型传递的特点]</p></blockquote><h1 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h1><blockquote><p><strong>java.util.Arrays</strong></p><ol><li><p>static String toString(int[] arr);//输出数组</p></li><li><p>static int[] copyOf(int[] original, int newLength)<br>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</p></li><li><p>static void fill(boolean[] flag,boolean value);//给数组赋统一的值.</p></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day02</title>
    <link href="http://example.com/2021/07/16/day02/"/>
    <id>http://example.com/2021/07/16/day02/</id>
    <published>2021-07-16T10:02:10.000Z</published>
    <updated>2022-01-07T06:24:46.012Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 变量的定义和使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/16 8:35 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarInitDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">100</span>;<span class="comment">//使用频率很少</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开发中常用的整数型类型 - int,long</span></span><br><span class="line">        <span class="comment">//int类型可以初始化的值有哪些</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储一个二进制,只要0b二进制,1010对应的十进制</span></span><br><span class="line">        <span class="comment">//java中的int类型表示的是十进制的数据</span></span><br><span class="line">        <span class="comment">//1010 = 1*2^3+1+2^1 = 10</span></span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">0b1010</span>;</span><br><span class="line">        System.out.println(a1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java中使用单引号来表示一个字符</span></span><br><span class="line">        <span class="comment">//&#x27;a&#x27;-&gt;char类型-&gt;int类型</span></span><br><span class="line">        <span class="comment">//&#x27;a&#x27;对应的ascii码97</span></span><br><span class="line">        <span class="comment">//&#x27;A&#x27;对应的ascii码是65</span></span><br><span class="line">        <span class="comment">//&#x27;0&#x27;对应的ascii码是48</span></span><br><span class="line">        <span class="keyword">int</span> a2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(a2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java中以0开头的代表是八进制</span></span><br><span class="line">        <span class="comment">//八进制转换十进制032 = 3*8^1 + 2*8^0 = 26</span></span><br><span class="line">        <span class="keyword">int</span> a3 = <span class="number">032</span>;</span><br><span class="line">        System.out.println(a3);<span class="comment">//26</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//长整型 - long</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int类型-&gt;long类型</span></span><br><span class="line">        <span class="keyword">long</span> x1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推荐定义long的方式采用隐式转换</span></span><br><span class="line">        <span class="keyword">long</span> x2 = <span class="number">200L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdk7.x提供的 - 为了增强数字的可读性而已.</span></span><br><span class="line">        <span class="keyword">long</span> x3 = <span class="number">3_14_15_926L</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Date date = new Date(3L*24*60*60*100*1000*1000*2000);</span></span><br><span class="line"><span class="comment">//        System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//浮点数 - 并不是用来进行精确计算的</span></span><br><span class="line">        <span class="comment">//后面java.math.Decimal类解决小数计算的时候精度丢失的问题.</span></span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1.75</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推荐定义double</span></span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">5.67D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//float的精度是7或者8</span></span><br><span class="line">        <span class="comment">//double的精度是16</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//double类型强制转换成float类型</span></span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>) <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//隐式转换</span></span><br><span class="line">        <span class="keyword">float</span> f2 = <span class="number">3.14F</span>;</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//补充</span></span><br><span class="line">        <span class="comment">//数字进行计算的时候,都会转换成二进制进行计算</span></span><br><span class="line">        <span class="comment">//小数进行计算的时候,还是不可逆的</span></span><br><span class="line">        <span class="comment">//0.8999999999999999</span></span><br><span class="line">        System.out.println(<span class="number">2.0</span>-<span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0.9</span></span><br><span class="line">        System.out.println(<span class="number">2.0f</span> - <span class="number">1.1f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int-&gt;float  ×</span></span><br><span class="line">        <span class="comment">//int-&gt;double √</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">123456789</span>;</span><br><span class="line">        <span class="keyword">float</span> ft = n;</span><br><span class="line">        System.out.println(ft);<span class="comment">//1.23456792E8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> db = n;</span><br><span class="line">        System.out.println(db);<span class="comment">//1.23456789E8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1.234567565f</span>;</span><br><span class="line">        System.out.println(f3);<span class="comment">//1.2345675</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义布尔类型</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最特殊的是char类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">65</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h1><blockquote><p>java中是使用单引号表示char类型,使用双引号来表示字符串.</p><p><strong>java的底层的编码是unicode编码,char类型也是采用unicode编码</strong></p><p>unicode编码是双字节[16bit],所以存储一个汉字.</p><p>ascii码和unicode码的关系?</p><p>不同的国家,符号表示的方式不同,所以ascii码[0<del>127]不够用.所以unicode[0</del>65535]码诞生了,几乎</p><p>包含了所有国家的符号,unicode码包含ascii码.<strong>char类型在进行计算的时候会转换成ascii码来进行计算.</strong></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: char类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/16 9:14 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//java中是使用单引号表示char类型</span></span><br><span class="line">        <span class="comment">//char的空间大小也是确定的</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//十六进制</span></span><br><span class="line">        <span class="comment">//由数字0-9或者字母a-f/A-F,字母a代表就是数字10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cmd - 输入native2ascii -&gt; 输入中文</span></span><br><span class="line">        <span class="keyword">char</span> c2 = <span class="string">&#x27;\u34af&#x27;</span>;</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//char底层采用的是unicode编码,所以存储一个汉字</span></span><br><span class="line">        <span class="keyword">char</span> c3 = <span class="string">&#x27;星&#x27;</span>;</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c4 = <span class="number">48</span>;</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">char</span> c5 = (<span class="keyword">char</span>) m;</span><br><span class="line">        System.out.println(c5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//char类型在进行计算的时候会转换成ascii码来进行计算.</span></span><br><span class="line">        <span class="comment">//&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48</span></span><br><span class="line">        <span class="comment">//char类型的计算 - 进阶部分</span></span><br><span class="line">        <span class="keyword">char</span> n1 = <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;<span class="comment">//ok</span></span><br><span class="line">        System.out.println(n1);<span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> cc = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> nn = (<span class="keyword">char</span>) (cc + <span class="number">1</span>);</span><br><span class="line">        System.out.println(cc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//char-&gt;int</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span>;<span class="comment">//ok</span></span><br><span class="line">        System.out.println(result);<span class="comment">//195</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量的赋值方式"><a href="#变量的赋值方式" class="headerlink" title="变量的赋值方式"></a>变量的赋值方式</h1><blockquote><ol><li><p>单个赋值 int a = 10;</p></li><li><p>通过表达式赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//表达式:由字面量或者变量以及运算符号组成的合法的语句</span></span><br><span class="line"><span class="keyword">int</span> result = a + b;</span><br></pre></td></tr></table></figure></li><li><p>链式赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c=<span class="number">30</span>;<span class="comment">//同时声明了三个变量,并且都进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,c = <span class="number">100</span>;<span class="comment">//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用</span></span><br></pre></td></tr></table></figure></li><li><p>可以先定义变量,然后再进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></li><li><p>通过方法进行赋值 - 暂时了解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = getResult();</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义了一个方法 - 千万不要将它放在main方法中</span></span><br><span class="line"><span class="comment">     * java语法 - 方法体内部是不能够再去定义方法的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h1><blockquote><ol><li><p>局部变量 - 定义在方法体内部</p><blockquote><p>使用的范围就是在它所在的最近的那个{}中</p></blockquote></li><li><p>全局变量 - 定义在方法体外部的变量</p><blockquote><p>生命周期 - 面向对象</p></blockquote></li></ol></blockquote><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><blockquote><p>使用final修饰的变量 - 常量 - 不可改变的量</p><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 数据类型 变量 [= 初始值];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 局部变量和全局变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/16 10:04 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarAndGlobalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义全部变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">100</span>;<span class="comment">//静态变量 - 暂不了解</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码块</span></span><br><span class="line">        <span class="comment">//局部变量 - 定义在方法体内部</span></span><br><span class="line">        <span class="keyword">int</span> a= <span class="number">10</span>;</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            使用的范围就是在它所在的最近的那个&#123;&#125;中</span></span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(a);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">            System.out.println(b);<span class="comment">//ok</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用的范围就是在它所在的最近的那个&#123;&#125;中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(b);//error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问全局变量</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个常量 - 不可改变的量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//s = 200;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//final - b肯定不可变</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span> b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> result = b + <span class="number">1</span>;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> +    java语言中唯一重载[具有多个意义]的运算符   数值之间表示的加法运算,如果出现了<span class="string">&quot;字符串&quot;</span>,表示拼接[后面就会知道拼接效率很低]  <span class="number">2.</span> - 减法   * 乘法  <span class="number">3.</span> / 除法[配合计算过程中需要注意的结果的类型而已] - 取整  <span class="number">4.</span> % 取余/模   /和%结合使用,可以获取某个数字任意位上的数值.  <span class="number">5.</span> += -= *= /= %=   未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全.   底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作]     <span class="number">6.</span> ++和--   前++/后++ - 变量本身都会自增<span class="number">1</span>   前--/后-- - 变量本身都会自减<span class="number">1</span>   未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全.   底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作]</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个<span class="keyword">boolean</span>类型即可</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><blockquote><ol><li><p>&amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的.</p><p>为true - 所有的条件表达式都是返回true</p><p>短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行.</p><p>推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率.</p></li><li><p>|| - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的.</p><p>为true - 只要有一个表达式是true,那么结果就是true</p><p>短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行.</p><p>推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率.</p></li><li><p>! - 逻辑非,true成为false,false成为true</p></li></ol></blockquote><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><blockquote><ol><li><p>&amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式.</p><p>​     <strong>计算:都是1,结果才是1.只要出现1个0,那么结果就是0</strong></p><p>​     连接条件:为true - 所有的条件表达式都是返回true</p><pre><code><figure class="highlight plaintext"><figcaption><span>& 8 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式.</span><br><span class="line"></span><br><span class="line">   **计算:只要存在一个1,结果就是1**</span><br><span class="line"></span><br><span class="line">   连接条件:为true - 只要存在一个条件表达式为true.</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br><span class="line">   10 | 8 = ?  1    0    1   0| 1    0    0   0------------------  1    0    1   0  -&gt; 对应的十进制10</span><br></pre></td></tr></table></figure></code></pre></li><li><p>异或^</p><p>作用:进行计算的 - 相同为0,不同为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> ^ <span class="number">8</span> = <span class="number">2</span> <span class="number">1</span>    <span class="number">0</span>    <span class="number">1</span>   <span class="number">0</span>| <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>------------------  <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>   <span class="number">0</span>  -&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><p>   10 ^ 8 ^ 8 = 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>   <span class="number">0</span> <span class="number">1</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>-----------------      <span class="number">1</span>   <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    -&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>   结论:一个数字连续异或同一个数字俩次结果是它本身.<br>   可以进行加密和解密的操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">笔试题: 交换俩个变量的值,不允许出现第三方变量   <span class="keyword">package</span> tech.aistar.day02;      <span class="comment">/**    * 本类用来演示: 笔试题: 交换俩个变量的值,不允许出现第三方变量    *    * <span class="doctag">@author</span>: success    * <span class="doctag">@date</span>: 2021/7/16 11:09 上午    */</span>   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeVarValue</span> </span>&#123;       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;           <span class="comment">//1. 使用第三方变量           int a = 10;           int b = 20;           int temp = a;           a = b;           b = temp;           System.out.println(&quot;a:&quot;+a);           System.out.println(&quot;b:&quot;+b);              //一个数字连续异或同一个数字俩次结果是它本身.           int m = 100;           int n = 200;           m = m ^ n;//m = 100 ^ 200           n = m ^ n;//n = 100 ^ 200 ^ 200 = 100           m = m ^ n;//m = 100 ^ 200 ^ 100 = 200              System.out.println(&quot;m:&quot;+m);           System.out.println(&quot;n:&quot;+n);              //自创写法(success独家的) - 不推荐写 - 防止菜鸟看不懂           int x = 100;           int y = 200;              //y = 100 ^ 200 ^ 200 = 100           y = x ^ (x = y) ^ y;              System.out.println(&quot;x:&quot;+x);           System.out.println(&quot;y:&quot;+y);       &#125;   &#125;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="4"><li><p>取反~,1变0,0变成1</p></li><li><p>补码 - <strong>负数</strong>在计算机中的表现形式就是以补码的形式存在的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码 = 反码 + <span class="number">1</span>;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位<span class="number">.1</span>代表的是负数,<span class="number">0</span>代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-<span class="number">10</span>的二进制是多少?-<span class="number">10</span>的补码是多少?计算步骤:<span class="number">1.</span> -<span class="number">10</span>原码   <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000010102.</span> -<span class="number">10</span>的反码   <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001010</span>   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111101013.</span> -<span class="number">10</span>的补码 = 反码+<span class="number">1</span>   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11110101</span> +                                   <span class="number">1</span>  -------------------------------------   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11110110</span>    -&gt;  -<span class="number">10</span>的二进制计算~<span class="number">900000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000100111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11110110</span>  -&gt; ~<span class="number">9</span>取反的结果-<span class="number">10</span> = ~<span class="number">9</span>结论:-(x+<span class="number">1</span>) = ~x</span><br></pre></td></tr></table></figure></li><li><p>移位操作</p><blockquote><p>笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt; 向左移动<span class="number">2</span>&lt;&lt;<span class="number">2</span> =&gt; <span class="number">0010</span> &lt;&lt; <span class="number">2</span> = <span class="number">1000</span> = <span class="number">8</span>原题:请你用最高性能的方式计算出<span class="number">2</span>的<span class="number">3</span>次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-<span class="number">10</span> &gt;&gt; <span class="number">2</span> = -<span class="number">311111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11110110</span> &gt;&gt; <span class="number">211111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111101</span> -&gt; 负数的二进制,最高位是<span class="number">100000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000010</span> 取反 ~<span class="number">2</span>=-<span class="number">3</span>&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补<span class="number">0</span> -<span class="number">10</span> &gt;&gt;&gt; <span class="number">2</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11110110</span> &gt;&gt; <span class="number">2</span> <span class="number">00111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111101</span> -&gt; 计算出十进制 <span class="number">01000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>   -                                  <span class="number">3</span>-----------------------------------------     <span class="number">1073741821</span></span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><blockquote><p>练习-15&gt;&gt;2    -15&gt;&gt;&gt;2</p><p>-15 = ~14</p><p>11111111……   0001 &gt;&gt;&gt; 2</p></blockquote><blockquote><p>00111111 11111111 11111111 11111101</p></blockquote><blockquote><p>00111111 11111111 11111111 1111100 = 1073741820</p></blockquote><h1 id="方法-Method"><a href="#方法-Method" class="headerlink" title="方法 - Method"></a>方法 - Method</h1><blockquote><p>非常重要,如果没有跟上,直接出局.</p><p>相当于其他语言中函数function,功能是用来封装代码的逻辑.</p><p>把一段代码封装到方法中,方便以后复用,提高了代码的可维护性.</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名([参数列表]) [<span class="keyword">throws</span> 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><blockquote><p><strong>作用:就是决定了这个方法可以被调用的范围.</strong></p></blockquote><blockquote><ol><li><strong>public</strong> - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用.</li><li><strong>private</strong> - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的.</li><li>默认的</li><li>受保护的</li></ol></blockquote><h4 id="特殊修饰符-超纲的内容"><a href="#特殊修饰符-超纲的内容" class="headerlink" title="特殊修饰符[超纲的内容]"></a>特殊修饰符[超纲的内容]</h4><blockquote><ol><li><p>static - 静态的</p><p>如果使用static修饰的方法 - 静态方法</p><p>如果没有使用static修饰的方法 - 非静态方法</p></li><li><p>是否为静态的方法决定了这个方法被调用的方式.</p></li></ol></blockquote><h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><blockquote><ol><li><p>有返回类型</p><p>可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型]</p><p>方法体的最终的出口一定有return 返回值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 作用<span class="number">1</span> - 返回方法最终的执行结果       作用<span class="number">2</span> - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果.           方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换</span><br></pre></td></tr></table></figure></li><li><p>无返回类型 - void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不需要使用<span class="keyword">return</span>  + 返回值;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>该如何选择?</p><p>如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型</p><p>如果一个方法仅仅是为了输出,只要定义void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test01</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;    <span class="comment">//code...</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>  return m和n的最大公约数 //System.out.println(公约数)</code></pre><p>   }<br>   //int m = test01(20,12);//m-&gt;4</p><p>   public static int test02(int m,int n){<br>     int 公约数 = test01(m,n);<br>     return m<em>n/公约数;<br>   }<br>   int n = test02(20,12);//n-&gt;60=20</em>12/4=60</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><blockquote><p>参考变量名的命名规则 - 一模一样</p><p>标识符 - 给类,包,<strong>变量,方法</strong>取的名称</p></blockquote><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><blockquote><ol><li>无参列表</li><li>带参列表</li><li>可变长列表</li></ol></blockquote><h2 id="该如何定义方法"><a href="#该如何定义方法" class="headerlink" title="该如何定义方法"></a>该如何定义方法</h2><blockquote><ol><li><strong>方法体内部不能够再去定义方法了</strong></li><li><strong>main方法仍然是程序的主入口.</strong></li><li>自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的</li></ol></blockquote><h2 id="方法的调用方式"><a href="#方法的调用方式" class="headerlink" title="方法的调用方式"></a>方法的调用方式</h2><blockquote><p><em><strong>取决于这个方法是静态的还是非静态的 - static</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day02.method;</span><br><span class="line"><span class="comment">/** * 本类用来演示: 方法的定义 * * <span class="doctag">@author</span>: success * <span class="doctag">@date</span>: 2021/7/16 2:20 下午 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHelloDemo</span> </span>&#123;    <span class="comment">/**     * main - 仍然是程序的主入口     * <span class="doctag">@param</span> args     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//类中的方法 - 类里面的成员        //static - 静态的成员被初始化的时机        //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化        //在这个阶段,压根就没有对象的概念,只有类.        //结论 - 静态的成员属于类的,并且初始化的时机有且1次.        //属于谁,就由谁去调用!        //1. 调用静态的方法,直接通过类.方法名([参数])        //类 - 该静态方法所在的当前类        MethodHelloDemo.sub();        //non-static -&gt; 非静态的成员被初始化的时机?        //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化        //如果没有创建对象,就不会初始化这些非静态成员.        //结论: 非静态成员是属于对象的.属于谁,由谁调用.        //2. 非静态方法 - 通过对象去调用        //调用哪个类中的方法,就去创建哪个类的对象        //后面的OO知识点 -&gt; 类名 变量 = new 类名();        //创建了一个 MethodHelloDemo对象,m就是对象名        MethodHelloDemo m = new MethodHelloDemo();        m.add();    &#125;    /**     * 定义了公开的非静态的无返回类型的方法     */    public void add()&#123;        System.out.println(&quot;add...&quot;);    &#125;    /**     * 定义了公开的静态的无返回类型的方法     */    public static void sub()&#123;        System.out.println(&quot;sub...&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ol><li><p><em><strong>静态方法中只能够直接调用静态方法</strong></em></p></li><li><p><em><strong>非静态方法中可以直接调用非静态方法以及静态方法</strong></em></p></li><li><p><em><strong>通用的原则 - 类名.静态方法或者对象.非静态方法</strong></em></p></li><li><p><em><strong>静态方法属于类拥有的,非静态方法属于对象拥有的</strong></em></p></li><li><p><em><strong>静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次.</strong></em></p><p><em><strong>而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化</strong></em></p></li></ol></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> tech.aistar.day02.method;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;* 本类用来演示:</span></span><br><span class="line"><span class="comment">&gt;*</span></span><br><span class="line"><span class="comment">&gt;* <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment">&gt;* <span class="doctag">@date</span>: 2021/7/16 2:43 下午</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDetailDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义了全局变量</span></span><br><span class="line">  <span class="comment">//属性,方法 =&gt; 成员</span></span><br><span class="line">  <span class="comment">//非静态的属性</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">10</span>;<span class="comment">//等创建对象的时候,才会分配空间和初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态属性-初始化的时机优先于静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//此时n还未初始化</span></span><br><span class="line">      <span class="comment">//System.out.println(n);//编译错误</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//System.out.println(m);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用test03 - 非静态的</span></span><br><span class="line">      StaticDetailDemo s = <span class="keyword">new</span> StaticDetailDemo();</span><br><span class="line">      s.test03();</span><br><span class="line"></span><br><span class="line">      System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非静态的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test01..&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;test02...&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//自定义的方法中是可以调用自己自定义的方法的</span></span><br><span class="line">      <span class="comment">//1. 另外一个静态方法test04</span></span><br><span class="line">      StaticDetailDemo.test04();</span><br><span class="line">      <span class="comment">//静态方法中可以直接调用静态方法</span></span><br><span class="line">      test04();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 另外一个非静态方法test03</span></span><br><span class="line">      StaticDetailDemo s1 = <span class="keyword">new</span> StaticDetailDemo();</span><br><span class="line">      s1.test03();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//static int n = 20;//非静态方法中不允许定义静态的局部变量</span></span><br><span class="line">      System.out.println(<span class="string">&quot;test03..&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//非静态方法中调用静态方法 - 类名.方法</span></span><br><span class="line">      <span class="comment">//StaticDetailDemo.test04();//ok</span></span><br><span class="line"></span><br><span class="line">      test04();<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用.</span></span><br><span class="line">      test01();<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//实际上省略了一个关键字this</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//this代表的是当前对象</span></span><br><span class="line">      <span class="comment">//当前对象 - 调用该方法[test03]的对象</span></span><br><span class="line">      <span class="comment">//this.test01();</span></span><br><span class="line">      System.out.println(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;test04..&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="方法调用补充"><a href="#方法调用补充" class="headerlink" title="方法调用补充"></a>方法调用补充</h2><blockquote><ol><li><p>方法的调用者和方法的定义者在同一个类中.</p></li><li><p>方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中.</p><p>只能使用通用的原则类名.静态方法或者对象.非静态方法</p></li><li><p>方法的调用者和方法的定义者是存在于<strong>不同包</strong>下的不同类中.</p><p>必须先通过<strong>import</strong>关键字进行导包操作.</p><p>使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import</p></li><li><p>递归算法 - <strong>错误的写法 - 方法内部直接调用自己</strong></p></li></ol></blockquote><h2 id="private-和-public-该选择使用"><a href="#private-和-public-该选择使用" class="headerlink" title="private 和 public 该选择使用"></a>private 和 public 该选择使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 牛叉的工具类</span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 牛叉的方法<span class="number">01</span>()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//肯定是会被外面的人调用的...</span></span><br><span class="line">    <span class="comment">//内部的代码的业务逻辑非常负责,由很多小的功能组成的</span></span><br><span class="line">    小的牛叉方法<span class="number">01</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> 小的牛叉方法<span class="number">01</span>()&#123;</span><br><span class="line">    <span class="comment">//专门封装了小的功能.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 牛叉的方法<span class="number">02</span>()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//肯定是会被外面的人调用的...</span></span><br><span class="line">     <span class="comment">//内部的代码的业务逻辑非常负责,由很多小的功能组成的</span></span><br><span class="line">     小的牛叉方法<span class="number">01</span>();</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>day01</title>
    <link href="http://example.com/2021/07/15/day01/"/>
    <id>http://example.com/2021/07/15/day01/</id>
    <published>2021-07-15T09:54:17.000Z</published>
    <updated>2022-01-07T06:24:14.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java能做什么"><a href="#Java能做什么" class="headerlink" title="Java能做什么"></a>Java能做什么</h1><blockquote><ol><li><p>传统的项目 - 简单的,公司内部使用的,不会存在高并发的问题.</p><p>教务管理系统,OA自动化办公系统,CRM客户关系管理系统,ERP企业资源计划系统</p></li><li><p>B2C - 典型的电子商务模式,涉及到高并发的业务</p><p>企业2客户 - 企业卖自己的服务或者产品</p></li><li><p>C2B2C - 新型的模式 - 淘宝</p><p>平台 - 对双方进行监管</p><p>卖家</p><p>买家</p></li><li><p>大数据 - 一定是对业务非常熟悉[数据分析,数据非常敏感]</p></li></ol></blockquote><h1 id="Java的历史"><a href="#Java的历史" class="headerlink" title="Java的历史"></a>Java的历史</h1><blockquote><ol><li><p>原先是属于SUN公司[Stanford University Network 斯坦福网络大学]</p><p>Sun Microsystem - 太阳微电子公司</p></li><li><p>后来在2010年10月份被Oracle公司[出名的产品-oracle数据库 - NO.1]</p><p>74亿美金收购 - <a href="http://www.oracle.com/">www.oracle.com</a></p></li><li><p>前身Oak语言[橡树],印度尼西亚的<strong>爪哇</strong>岛[咖啡豆 - javabean]</p></li><li><p>诞生于1995年5月23日,96年正式推出jdk1.0版本.</p></li><li><p>商用的jdk版本 - <strong>jdk8.x</strong> , jdk11.x ,jdk16.x</p></li><li><p>java之父 - james gosling 詹姆斯 高斯林</p></li></ol></blockquote><h1 id="Java支持的三个平台"><a href="#Java支持的三个平台" class="headerlink" title="Java支持的三个平台"></a>Java支持的三个平台</h1><blockquote><p>原先的名称j2se , j2ee, j2me</p><ol><li><p>JavaSE - Java Standard Editional - Java标准版</p><p>适合做<strong>桌面应用程序[维护比较麻烦,服务器端如果更新,客户端需要更新]</strong>,包含了java里面的基础的语法,核心</p></li><li><p>JavaEE - 2018年 - JakartaEE - 雅佳达EE - Java Enterprise Editional - Java企业版</p><p>是一套技术的规范的体系.不是一门具体的技术.里面包含了13种核心技术</p><p>比如jdbc,servlet等遵守javaee的规范.现在javaee里面的核心技术已经使用不多了</p><p>现在普遍都在使用spring全家桶中的技术.</p><p>适合做web应用程序[web网站]</p></li><li><p>JavaME - Java Micro Editional - Java微型版,适合做手持设备 - “不用”</p></li></ol></blockquote><h1 id="检测一下jdk的环境变量是否配置成功"><a href="#检测一下jdk的环境变量是否配置成功" class="headerlink" title="检测一下jdk的环境变量是否配置成功"></a>检测一下jdk的环境变量是否配置成功</h1><blockquote><p>打开终端,输入cmd - 输入java -version</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admindeMacBook-Pro:Desktop admin$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_66&quot;</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_66</span>-b17)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.66</span>-b17, mixed mode)</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h2><blockquote><p>Java.zip - 解压缩 - 比如放在D盘</p></blockquote><blockquote><p>所有的软件不要放在中文目录下,不要放在带有特殊符号的目录下[programe files(x86)]</p><p>尽量不要放在C盘[权限的问题,拒绝你的访问的]</p></blockquote><blockquote><p>桌面 - 右击计算机 - 属性 - 高级系统设置 - 环境变量(N) - 定位到系统变量</p><ol><li><p>新建</p><p>变量名:JAVA_HOME</p><p>变量值:jdk1.8.0_66的绝对路径</p><p>确定</p></li><li><p>找到内置的变量名Path - 编辑 - 新建</p><p>%JAVA_HOME%\bin</p></li><li><p>关闭刚所有打开的设置窗口,重新打开终端[黑窗口]</p><p>win+r - cmd -&gt;输入  java -version</p></li></ol></blockquote><h1 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h1><blockquote><ol><li>简单</li><li>可移植性</li><li>面向对象 - 核心</li><li>与平台无关性[跨平台性,跨操作系统平台]</li><li>安全性 - 本身是属于强类型的语言.在编译期间就要确定数据的类型.</li></ol></blockquote><h1 id="JDK和JRE和JVM"><a href="#JDK和JRE和JVM" class="headerlink" title="JDK和JRE和JVM"></a>JDK和JRE和JVM</h1><blockquote><p><strong>三者之间的区别</strong> -  简单题 - 笔试</p><ol><li><p>JDK - Java Development Kit - Java开发工具包,针对于开发者的.包含了很多开发工具</p><p>比如java.exe , javac.exe, javadoc.exe , jar.exe等</p><p><strong>JDK中是包含JRE的</strong></p></li><li><p>JRE - Java Runtime Enviroment - Java运行时环境,包含了很多核心的内库.</p><p>针对于使用java语言开发出来软件的用户.如果一个用户仅仅想运行一个java程序的话</p><p>那么计算机中只需要安装jre即可.</p><p><strong>JRE包含JVM</strong></p></li><li><p>JVM - Java Virtual Machine - Java虚拟机 - 后期重点详细介绍jvm[笔试的大头 - 内存模型]</p><p>jvm本身就是用C语言编写的 - jvm的源码通读一遍.</p><p><strong>java程序并不是直接在计算机中进行跑的.而是在虚拟机上执行的.虚拟机是安装在操作系统上的.</strong></p><p><strong>注意的是java语言是跨平台的[使用java语言编写的程序可以运行在不同的os上],但是jvm不是跨平台的</strong></p><p><strong>不同的操作系统需要安装不同的jvm</strong></p></li></ol></blockquote><h1 id="HelloWorld程序"><a href="#HelloWorld程序" class="headerlink" title="HelloWorld程序"></a>HelloWorld程序</h1><blockquote><p>java的基础单元是类class</p><p><strong>类的命名</strong> - 标识符的命名</p><ol><li><p>只能由字母,数字,下划线,$符号组成,但是不能以数字开头</p></li><li><p>推荐使用”大驼峰”命名规则,单词首字母必须要大写.其余单词小写</p></li><li><p>不能是jdk中内置的对象类型[String,System]</p></li><li><p>不能是java中的一些关键字,关键字[java语言赋予了这些单词具备一定的语法含义]</p><p>byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue,class,</p><p>public,private,protected等</p></li><li><p>不能是java中的保留关键字 - goto,const</p></li><li><p>不推荐使用中文,防止出现乱码问题.</p></li><li><p>不推荐使用中文的拼音</p></li><li><p>推荐见名知意</p></li><li><p>不能是以下三个字面量 - true,false,null</p></li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><ol><li><p>在D盘根目下新建一个文件HelloWorld.java</p><p>java的源文件就是以.java为后缀的文件</p></li><li><p>记事本打开HelloWorld.java文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编程语言中,只要出现了符号,一定必须都是英文输入法下的</span></span><br><span class="line"><span class="comment">//整体的结构</span></span><br><span class="line"><span class="comment">//java是以类作为基础的单位的 - 定义类</span></span><br><span class="line"><span class="comment">//关键是class</span></span><br><span class="line"><span class="comment">//类的名称要和文件的名称高度保持一致</span></span><br><span class="line"><span class="comment">//&#123;&#125; - block - 块 - 代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;<span class="comment">//1. 类</span></span><br><span class="line">    <span class="comment">//规范 - 缩进四个空格</span></span><br><span class="line">    <span class="comment">//定义一个main方法 - 程序的&quot;大门&quot;</span></span><br><span class="line">    <span class="comment">//运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main</span></span><br><span class="line">    <span class="comment">//方法中去执行</span></span><br><span class="line">    <span class="comment">//今天先记住语法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//2. 方法</span></span><br><span class="line">       <span class="comment">//方法体,现阶段代码一定是放在方法体内部的.</span></span><br><span class="line">       <span class="comment">//jdk中提供了内置的对象[拥有一些功能],提供好了,开发者就可以直接使用</span></span><br><span class="line">       <span class="comment">//java.lang.System类 - 向控制台输出一句话</span></span><br><span class="line">       System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);<span class="comment">//3. 具体的程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>java源代码是不能够直接执行的.因为计算机是不识别java语言程序的.</p><p>需要对.java为后缀的源文件进行一个<strong>编译操作</strong>.如果一旦语法发生了问题,都会导致编译失败.</p><p>假设HelloWorld.java文件是放在D盘根目录下,需要打开终端,然后通过dos命令进入到D盘</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:/<span class="title">User</span>/<span class="title">admin</span>&gt;<span class="title">d</span>:</span></span><br><span class="line"><span class="function"><span class="title">D</span>:/&gt;<span class="title">javac</span> <span class="title">HelloWorld.java</span></span></span><br></pre></td></tr></table></figure><p><code>效果,javac.exe工具其实就是在调用jdk中的编译器,作用:就是.java源文件编译成.class字节码文件</code></p></li><li><p>思考如何运行一个java程序呢?</p><p>利用java.exe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:/&gt;java HelloWorld</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><blockquote><ol><li>编写.java源代码</li><li>javac.exe - 编译</li><li>java.exe - 执行</li></ol></blockquote><h2 id="Java程序的执行的原理"><a href="#Java程序的执行的原理" class="headerlink" title="Java程序的执行的原理"></a>Java程序的执行的原理</h2><p><img src="/2021/07/15/day01/Users\HP\Desktop\j03s_tech\note\imgs\jvm.png">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.java源文件 -&gt; 经过jdk中的编译器,成为.class字节码文件 -&gt; 经过jvm中的解释器[进行逐行翻译(解释)]</span><br><span class="line">-&gt; 机器能够识别的符号</span><br><span class="line"></span><br><span class="line">java属于解释型的语言,<span class="string">&quot;JVM把它YY成以.class字节码为指令的CPU&quot;</span></span><br><span class="line"></span><br><span class="line">编译型语言 - C语言,将这个语言编写的程序直接编译成计算机能够执行的程序.比如C语言写的代码可以直接编译成可执行文件 xx.exe</span><br><span class="line"></span><br><span class="line">C语言执行的性能高于java语言(每次执行都会经过jvm解释器进行解释)</span><br></pre></td></tr></table></figure><h1 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h1><blockquote><ol><li><p>eclipse[日食] - 免费的,IBM公司的产品[收购SUN公司的] </p></li><li><p>idea - 最好的,收费的</p><p>d:/aistar/j03s_student</p></li></ol></blockquote><h1 id="Java中的包-package"><a href="#Java中的包-package" class="headerlink" title="Java中的包-package"></a>Java中的包-package</h1><blockquote><ol><li><p>包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用.</p></li><li><p>包的命名规则</p><p>2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录</p><p>2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号</p><p>​       com.baidu.car   tech.aistar</p><p>2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中.</p></li><li><p>一旦创建了package,需要在类文件的<strong>首行</strong>采用<strong>package关键字来声明包.</strong></p></li></ol></blockquote><h1 id="java中三种注释"><a href="#java中三种注释" class="headerlink" title="java中三种注释"></a>java中三种注释</h1><blockquote><ol><li><p>单行注释 //   ctrl+/  添加/取消注释</p></li><li><p>多行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  多行注释的内容 - 注释的内容是不会经过jdk的编译器的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>文档注释</p><blockquote><p>可以生成文档树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 放在类上面</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 放在方法上</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><h1 id="main方法细节"><a href="#main方法细节" class="headerlink" title="main方法细节"></a>main方法细节</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>[公开的,公共的] <span class="keyword">static</span>[静态的] - 都是属于后期学习OO中的修饰符</span><br><span class="line">修饰符在使用的时候,之间是没有顺序的.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;...&#125;    <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;...&#125;   <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk8中方法的参数支持可变长参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;...&#125;  <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//args - 我们传给虚拟机的参数</span></span><br></pre></td></tr></table></figure><h1 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h1><blockquote><ol><li><p>System.out.println(); // 换行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>\n和\r</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day01;<span class="comment">/** * 本类用来演示: \n \r * * <span class="doctag">@author</span>: success * <span class="doctag">@date</span>: 2021/7/15 3:18 下午 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NrDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//相当于是System.out.println(&quot;hello&quot;);        System.out.print(&quot;hello\n&quot;);//输出之后不换行        System.out.println(&quot;world&quot;);        // \n - 当输出完毕之后,光标停在下一行的起始位置 - 换行        // \r - 当输出完毕之后,光标停在当前行的起始位置 回车        // \n\r 诞生的场景就是早期的打字机        //外面的终端执行的结果是 - veyy    √        //伪终端显示的结果是 - ve        System.out.println(&quot;Loyy\rve&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><blockquote><p>\ 是代表转义字符</p></blockquote><blockquote><ol><li><p>\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行</p></li><li><p>\r - 当输出完毕之后,光标停在当前行的起始位置 回车</p></li><li><p>\b - 退格</p></li><li><p>\t - 制表符,相当于tab键,默认是空4格</p></li><li><p>双引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>单引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>单个\</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本类用来演示: 特殊字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: success</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/7/15 3:35 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//\b - 退格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;xxx\byy&quot;</span>);<span class="comment">//xxyy</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//\t - 制表符,相当于tab键,默认是空4格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello\tworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出 james:&quot;success is good boy&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双引号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;james:\&quot;success is good boy\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// \ 转义含义</span></span><br><span class="line">        <span class="comment">//单个\</span></span><br><span class="line">        System.out.println(<span class="string">&quot;D:\\temp\\news&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出\\</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote><p><strong>编程的核心就是从定义变量开始</strong></p><p>java语言是一个<strong>强类型的语言</strong>[在编译期间必须要确定好数据的类型],javascript弱类型的语言</p><p>变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作.</p><p>但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库) - JVM内存</p><p>“JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据”</p><p>java中是如何定义和存储简单的这些数据呢?</p><p><strong>就是通过数据类型以及变量来定义和存储的.</strong></p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>java中的数据类型有两大块</p><ol><li><p><strong>基本数据类型(8种)</strong> - 编程思想中将void归纳为第9种</p><p>数据类型决定了存储数据的这块空间的大小,并且这个大小一旦确定了,将不能够改变了.</p></li><li><p>对象类型(无数种)</p><p>2-1. 内置对象类型 - System,String - Jdk中提供的类</p><p>2-2. 自定义对象类型 - 自己定义的那些类HelloWorld,SignDemo</p></li></ol></blockquote><h3 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h3><table><thead><tr><th></th><th>名称</th><th>大小</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节</td><td>占1个字节8bit</td><td>-128~127</td><td>0</td></tr><tr><td>short</td><td>短整型</td><td>占2个字节16bit</td><td>-2^15~2^15-1</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>占4个字节32bit</td><td>-2^31~2^31-1</td><td>0</td></tr><tr><td>long</td><td>长整型</td><td>占8个字节64bit</td><td>-2^63~2^63-1</td><td>0</td></tr><tr><td>float</td><td>单精度浮点数</td><td>占4个字节32bit</td><td>+-(3.4*10^38)</td><td>0.0</td></tr><tr><td>double</td><td>双精度浮点数</td><td>占8个字节64bit</td><td>+-(1.798*10^308)</td><td>0.0</td></tr><tr><td>char</td><td>字符</td><td>占2个字节16bit</td><td>0~65535</td><td>‘\u0000’空格</td></tr><tr><td>boolean</td><td>布尔类型</td><td>占1个字节8bit</td><td>true/false</td><td>false</td></tr></tbody></table><h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><blockquote><p>变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰”</p><p>“小驼峰” - 首字母小写,其余每个单词的首字母大写.比如<strong>studentAge</strong></p></blockquote><p><code>语法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 [= 变量值];</span><br></pre></td></tr></table></figure><h2 id="剖析变量的背后"><a href="#剖析变量的背后" class="headerlink" title="剖析变量的背后"></a>剖析变量的背后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day01;<span class="comment">/** * 本类用来演示: 变量入门 * * <span class="doctag">@author</span>: success * <span class="doctag">@date</span>: 2021/7/15 3:43 下午 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//数据类型 变量名 [= 变量值];        byte b = 10;        //代码的背后 - 埋了个&quot;种子&quot;,&quot;发芽&quot;        //1. 数据肯定是存储在JVM内存中的        //2. 定义在方法内部的变量 - 局部变量[JVM的栈区]        //3. 局部变量的生命周期是伴随着方法(main)的调用的开始和结束        //讲解的本质        //流程        //1. JVM加载VarDemo.class到内存        //2. JVM找到main方法想要去执行里面的程序        //3. 此处需要申请一块区域来保存数据10        //   3-1. 区域的大小由前面的数据类型来决定的 - int类型 - 区域4个字节32bit的大小        //   3-2. 栈里面的区域的大小一旦被确定了,就不能改变 - 肯定有的时候会有内存的浪费        //   3-3. 虽然空间浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot;        //4. 只要是内存中的空间,这个空间必然会有一个地址,所以变量的存在是为了给这个区域取了个名字        //   变量是为了方便用户来通过它访问到这个空间中存储的具体的那个值的        //把整数10赋值给一个int类型的变量a        int a = 10;        System.out.println(a);        // == 比较的就是&quot;坑 - 区域&quot;里面存储的数据        System.out.println(b == a);//true    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><blockquote><p>常识规定</p><p>a. java中看到一个整数,默认就是int类型</p><p>b. java中看到一个小数,默认就是double类型</p><p>c. 大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方.</p></blockquote><blockquote><ol><li><p>自动转换</p><p>小的数据类型可以自动转换成大的数据类型.</p><p><strong>byte-&gt;short-&gt;int-&gt;long</strong></p><p><strong>char-&gt;int</strong></p><p><strong>int-&gt;double</strong></p></li><li><p>强制类型转换</p><p>大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MaxType 变量<span class="number">1</span> = 值<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">MinType 变量<span class="number">2</span> = (MinType)变量<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>隐式转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>-&gt;<span class="keyword">long</span></span><br><span class="line">整数后面添加l/L</span><br><span class="line">      </span><br><span class="line"><span class="keyword">double</span>-&gt;<span class="keyword">float</span></span><br><span class="line">小数后面加上f/F</span><br><span class="line">      </span><br><span class="line">推荐在<span class="keyword">double</span>后面加上d/D - 提高语义</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="note" scheme="http://example.com/categories/note/"/>
    
    
    <category term="coreJava" scheme="http://example.com/tags/coreJava/"/>
    
  </entry>
  
  <entry>
    <title>hexo-blog搭建</title>
    <link href="http://example.com/2021/07/13/hexoA/"/>
    <id>http://example.com/2021/07/13/hexoA/</id>
    <published>2021-07-13T07:20:57.000Z</published>
    <updated>2022-01-07T06:26:06.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="hexo-github搭建博客服务器"><a href="#hexo-github搭建博客服务器" class="headerlink" title="hexo+github搭建博客服务器"></a>hexo+github搭建博客服务器</h1><blockquote><ol><li>csdn,简书,有道笔记 - <strong>广告比较多</strong></li><li>hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/<strong>阿里云服务器</strong></li></ol></blockquote><h1 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h1><blockquote><ol><li>非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的]</li><li>D:/node-v14.17.3-win-x64</li></ol></blockquote><h2 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h2><blockquote><ol><li><p>桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N)</p></li><li><p>定位到下方的系统变量</p></li><li><p>定位到变量名 - Path - 编辑 - 新建</p></li><li><p>D:/node-v14.17.3-win-x64</p></li><li><p>一定要关闭所有的环境变量配置的窗口 - 确定</p></li><li><p>打开终端[如果终端已经打开了,关闭 - 重新打开]</p><p>win[微软图标]+r - 输入cmd  - 输入如下指令检测nodejs是否配置成功</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="number">6</span>.<span class="number">14</span>.<span class="number">5</span> 出现版本号,则说明配置成功</span><br><span class="line">      </span><br><span class="line">如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否</span><br><span class="line">成功配置到了<span class="built_in">path</span>中</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="简单认识npm"><a href="#简单认识npm" class="headerlink" title="简单认识npm"></a>简单认识npm</h2><blockquote><p>npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具.</p><p>通过npm可以安装,共享,分发代码,管理项目依赖关系.</p><p>类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具]</p></blockquote><h2 id="npm简单使用"><a href="#npm简单使用" class="headerlink" title="npm简单使用"></a>npm简单使用</h2><h3 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h3><blockquote><p>为了下载速度变快,修改npm的镜像</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>验证一下,镜像是否成功修改了</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">https://<span class="title">registry.npm.taobao.org</span>/</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="简单使用-不需要操作"><a href="#简单使用-不需要操作" class="headerlink" title="简单使用 - 不需要操作"></a>简单使用 - 不需要操作</h2><blockquote><ol><li><p>下载bootstrap</p><p>npm install 框架名称  - 默认下载的是最新的版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bootstrap@<span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="Hexo官网"><a href="#Hexo官网" class="headerlink" title="Hexo官网"></a>Hexo官网</h1><blockquote><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><ol><li><p>假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录]</p></li><li><p>win+r - 打开终端</p></li><li><p>通过dos命令进入到hello-hexo目录中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:/<span class="title">User</span>/<span class="title">admin</span>&gt;<span class="title">d</span>:</span></span><br><span class="line"><span class="function"><span class="title">D</span>:&gt;<span class="title">cd</span> <span class="title">hello</span>-<span class="title">hexo</span></span></span><br><span class="line"><span class="function"><span class="title">D</span>:/<span class="title">hello</span>-<span class="title">hexo</span>&gt;<span class="title">npm</span> <span class="title">install</span> <span class="title">hexo</span>-<span class="title">cli</span> -<span class="title">g</span></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="创建真正的博客目录"><a href="#创建真正的博客目录" class="headerlink" title="创建真正的博客目录"></a>创建真正的博客目录</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:/<span class="title">hello</span>-<span class="title">hexo</span>&gt;<span class="title">hexo</span> <span class="title">init</span> <span class="title">hello</span>-<span class="title">blog</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-blog</span><br><span class="line"><span class="function">D:/<span class="title">hello</span>-<span class="title">hexo</span>/<span class="title">hello</span>-<span class="title">blog</span>&gt;<span class="title">npm</span> <span class="title">install</span></span></span><br></pre></td></tr></table></figure><h2 id="测试-启动博客服务器"><a href="#测试-启动博客服务器" class="headerlink" title="测试 - 启动博客服务器"></a>测试 - 启动博客服务器</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:/<span class="title">hello</span>-<span class="title">hexo</span>/<span class="title">hello</span>-<span class="title">blog</span>&gt;<span class="title">hexo</span> <span class="title">s</span></span></span><br></pre></td></tr></table></figure><p><code>关闭服务器</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+c</span><br></pre></td></tr></table></figure><p><em><strong>打开浏览器输入:localhost:4000</strong></em></p><h2 id="常用主题模板"><a href="#常用主题模板" class="headerlink" title="常用主题模板"></a>常用主题模板</h2><blockquote><p><a href="https://blog.csdn.net/zgd826237710/article/details/99671027">https://blog.csdn.net/zgd826237710/article/details/99671027</a></p><p>使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,<strong>重新打开终端</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></blockquote><h2 id="注册码云账号"><a href="#注册码云账号" class="headerlink" title="注册码云账号"></a>注册码云账号</h2><blockquote><p>推荐用QQ注册一下</p><p>本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下</p><p>C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = 码云的QQ邮箱</span><br><span class="line">name = 用户名</span><br></pre></td></tr></table></figure></blockquote><h2 id="安装模板"><a href="#安装模板" class="headerlink" title="安装模板"></a>安装模板</h2><blockquote><p>通过cmd进入到hello-blog目录中的themes目录中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:/<span class="title">hello</span>-<span class="title">hexo</span>/<span class="title">hello</span>-<span class="title">blog</span>&gt;<span class="title">cd</span> <span class="title">themes</span></span></span><br><span class="line"><span class="function"><span class="title">D</span>://<span class="title">hello</span>-<span class="title">hexo</span>/<span class="title">hello</span>-<span class="title">blog</span>/<span class="title">themes</span>&gt;<span class="title">git</span> <span class="title">clone</span> <span class="title">https</span>://<span class="title">gitee.com</span>/<span class="title">guancg</span>/<span class="title">hexo</span>-<span class="title">theme</span>-<span class="title">pure.git</span></span></span><br></pre></td></tr></table></figure></blockquote><p>或者直接从github上直接clone</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git</span><br></pre></td></tr></table></figure><h1 id="更新主题配置"><a href="#更新主题配置" class="headerlink" title="更新主题配置"></a>更新主题配置</h1><blockquote><ol><li><p>指定新的主题</p><p>hello-blog目录下的_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-pure</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>重启服务器hexo s</li></ol></blockquote><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><p>hexo-theme-pure/_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">overriden</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">亲爱的管管</span></span><br><span class="line">  <span class="attr">author_title:</span> <span class="string">高级打字员</span></span><br><span class="line">  <span class="attr">author_description:</span> <span class="string">个人简介。</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">SuZhou,</span> <span class="string">China</span></span><br></pre></td></tr></table></figure><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><blockquote><p>语法的编辑器 - <a href="https://typora.io/">https://typora.io/</a></p><p>文件的后缀是md</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">常用语法如下:</span><br><span class="line"></span><br><span class="line">1. 标题的语法:</span><br><span class="line">1~6标题 - # 一级标题    ## 二级标题   </span><br><span class="line"></span><br><span class="line">2. 代码块 - java,js,mysql...</span><br><span class="line"></span><br><span class="line">​~~~java 敲enter键</span><br><span class="line"></span><br><span class="line">3. 列表</span><br><span class="line">3-1. 无序列表</span><br><span class="line">     * 列表名称</span><br><span class="line"></span><br><span class="line">     有序列表</span><br><span class="line">     1. 列表名称</span><br><span class="line"></span><br><span class="line">4. 高亮显示</span><br><span class="line">   `高亮显示内容`</span><br><span class="line"></span><br><span class="line">5. 加粗字体</span><br><span class="line">   **粗体**</span><br><span class="line"></span><br><span class="line">6. 斜体</span><br><span class="line">   *斜体*</span><br><span class="line"></span><br><span class="line">7. 粗+斜</span><br><span class="line">   ***粗斜***</span><br><span class="line"></span><br><span class="line">8. 段落</span><br><span class="line">   &gt; 空格</span><br><span class="line"></span><br><span class="line">9. 引入外部图片</span><br><span class="line">   ![](xx.png)</span><br><span class="line"></span><br><span class="line">10. 表格</span><br></pre></td></tr></table></figure></blockquote><h1 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D://<span class="title">hello</span>-<span class="title">hexo</span>/<span class="title">hello</span>-<span class="title">blog</span>&gt;<span class="title">hexo</span> <span class="title">n</span> <span class="title">java</span></span></span><br></pre></td></tr></table></figure><p>效果:hello-blog目录下的source/_ports/自动生成一个java.md文件</p><p>重启blog服务器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D://<span class="title">hello</span>-<span class="title">hexo</span>/<span class="title">hello</span>-<span class="title">blog</span>&gt;<span class="title">hexo</span> <span class="title">s</span></span></span><br></pre></td></tr></table></figure><h1 id="主题的侧边栏"><a href="#主题的侧边栏" class="headerlink" title="主题的侧边栏"></a>主题的侧边栏</h1><blockquote><p>侧边栏的链接生效</p><p>将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹</p><p>拷贝一份放入到hello-blog目录下的source目录中即可</p></blockquote><h1 id="文章的分类和标签"><a href="#文章的分类和标签" class="headerlink" title="文章的分类和标签"></a>文章的分类和标签</h1><blockquote><p>只需要在文章的.md文件的自动生成的头部添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: java</span><br><span class="line">date: 2021-07-13 08:44:42</span><br><span class="line">categories: java</span><br><span class="line">tags: java</span><br></pre></td></tr></table></figure></blockquote><h1 id="博客的语言环境设置"><a href="#博客的语言环境设置" class="headerlink" title="博客的语言环境设置"></a>博客的语言环境设置</h1><blockquote><p>设置中文</p><p>hello-blog下的_config.yml文件中</p><p>language: zh-CN</p></blockquote><h1 id="图片显示问题"><a href="#图片显示问题" class="headerlink" title="图片显示问题"></a>图片显示问题</h1><blockquote><ol><li><p>安装插件 - npm install <a href="https://gitee.com/guancg/hexo-asset-image.git">https://gitee.com/guancg/hexo-asset-image.git</a> –save</p></li><li><p>需要到hello-blog/_config.yml文件中进行配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>hexo n 机器学习</p><p><code>效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中</code></p></li><li><p>hexo s</p></li></ol></blockquote><h1 id="内置搜索的功能"><a href="#内置搜索的功能" class="headerlink" title="内置搜索的功能"></a>内置搜索的功能</h1><blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">insight:</span> <span class="literal">true</span> <span class="comment"># you need to install `hexo-generator-json-content` before using Insight Search</span></span><br><span class="line"><span class="attr">baidu:</span> <span class="literal">false</span> <span class="comment"># you need to disable other search engines to use Baidu search</span></span><br></pre></td></tr></table></figure><p>安装内置搜索插件</p><p>npm i -S hexo-generator-json-content</p></blockquote><h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><blockquote><p>不需要本地数据库进行存储的,用的是第三方的.</p><p>LeanCloud - 官网地址 - <a href="https://www.leancloud.cn/">https://www.leancloud.cn/</a></p><p>注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证</p><p>appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz</p><p>appKey - 3hn4ijEgSzJeRV4nkmXThmGV</p></blockquote><p><code>在hexo-theme-pure\_config.yml文件中配置</code></p><blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span> <span class="comment"># Valine. https://valine.js.org</span></span><br><span class="line"> <span class="attr">appid:</span> <span class="string">sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line"> <span class="attr">appkey:</span> <span class="string">3hn4ijEgSzJeRV4nkmXThmGV#</span> <span class="string">your</span> <span class="string">leancloud</span> <span class="string">application</span> <span class="string">appkey</span></span><br><span class="line"> <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"> <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"> <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"> <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"> <span class="attr">meta:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"> <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"> <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># Article reading statistic https://valine.js.org/visitor.html</span></span><br></pre></td></tr></table></figure></blockquote><p>#字数统计&amp;阅读时长</p><blockquote><ol><li><p>npm i -S hexo-wordcount</p></li><li><p>hexo-theme-pure_config.yml文件中配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">postCount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span>  <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span>  <span class="comment"># 阅读时长预计 </span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="附件-优秀插件"><a href="#附件-优秀插件" class="headerlink" title="附件-优秀插件"></a>附件-优秀插件</h1><blockquote><ol><li><p>显示图片</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://gitee.com/guancg/hexo-asset-image.git --save</span><br></pre></td></tr></table></figure></li><li><p>内置搜索</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-json-content</span><br></pre></td></tr></table></figure></li><li><p>字数统计&amp;阅读时长</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-wordcount</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>github部署</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="github注册一下"><a href="#github注册一下" class="headerlink" title="github注册一下"></a>github注册一下</h1><blockquote><p>github.com</p></blockquote><blockquote><p>chrome浏览器 + iguge - <a href="https://iguge.app/">https://iguge.app/</a></p></blockquote><blockquote><p>新建的仓库的名称必须是<strong>guancgsuccess.github.io</strong></p><p>仓库地址 - <a href="https://github.com/guancgsuccess/guancgsuccess.github.io.git">https://github.com/guancgsuccess/guancgsuccess.github.io.git</a></p></blockquote><blockquote><p>安装github部署插件</p><p>npm install hexo-deployer-git –save</p></blockquote><blockquote><p>hello-blog/_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">&#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p><code>hexo三连操作</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>浏览器输入 - guancgsuccess.github.io</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="know" scheme="http://example.com/categories/know/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java</title>
    <link href="http://example.com/2021/07/12/java/"/>
    <id>http://example.com/2021/07/12/java/</id>
    <published>2021-07-12T08:51:44.000Z</published>
    <updated>2021-07-15T11:19:22.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="无聊的知识"><a href="#无聊的知识" class="headerlink" title="无聊的知识"></a>无聊的知识</h1><blockquote><ul><li><p>java</p><ol><li><p>1</p></li><li><blockquote><ol><li>1</li><li> 2</li><li>3</li></ol></blockquote></li></ol></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psvm</span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>粗体:  <strong>粗</strong></p><p>斜体：<em>斜</em></p><p>粗斜体：<em><strong>粗斜</strong></em></p><p>高亮体：<code>高亮</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>111</th><th align="right">1</th><th align="center">11</th></tr></thead><tbody><tr><td>222</td><td align="right">2</td><td align="center">22</td></tr><tr><td>333</td><td align="right">3</td><td align="center">33</td></tr></tbody></table><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/2021/07/12/java/chixing\hello-hexo\hello-blog\111.jpg"></p><p>结束  7.12</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="test" scheme="http://example.com/categories/test/"/>
    
    
    <category term="test" scheme="http://example.com/tags/test/"/>
    
  </entry>
  
</feed>
